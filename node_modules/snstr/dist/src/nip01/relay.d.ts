import { NostrEvent, Filter, RelayEvent, RelayEventCallbacks, PublishOptions, PublishResponse, SubscriptionOptions } from "../types/nostr";
import { RelayConnectionOptions } from "../types/protocol";
export declare class Relay {
    private url;
    private ws;
    private connected;
    private subscriptions;
    private eventHandlers;
    private connectionPromise;
    private connectionTimeout;
    private logger;
    private eventBuffers;
    private eventBufferAccessTimes;
    private maxEventBuffers;
    private maxEventsPerBuffer;
    private bufferFlushInterval;
    private bufferFlushDelay;
    private reconnectAttempts;
    private reconnectTimer;
    private autoReconnect;
    private maxReconnectAttempts;
    private maxReconnectDelay;
    private replaceableEvents;
    private replaceableEventAccessTimes;
    private maxReplaceableEventPubkeys;
    private maxReplaceableEventsPerPubkey;
    private addressableEvents;
    private addressableEventAccessTimes;
    private maxAddressableEvents;
    private pendingValidationCounts;
    private pendingEoseSubscriptions;
    constructor(url: string, options?: RelayConnectionOptions);
    connect(): Promise<boolean>;
    disconnect(): void;
    /**
     * Schedule a reconnection attempt with exponential backoff
     */
    private scheduleReconnect;
    /**
     * Cancel any scheduled reconnection attempt
     */
    private cancelReconnect;
    /**
     * Reset the reconnection attempt counter
     */
    private resetReconnectAttempts;
    /**
     * Enable or disable automatic reconnection
     */
    setAutoReconnect(enable: boolean): void;
    /**
     * Set the maximum number of reconnection attempts
     * @param max Maximum number of attempts (0 for unlimited)
     */
    setMaxReconnectAttempts(max: number): void;
    /**
     * Set the maximum delay between reconnection attempts
     * @param maxDelayMs Maximum delay in milliseconds
     */
    setMaxReconnectDelay(maxDelayMs: number): void;
    on<E extends RelayEvent>(event: E, callback: RelayEventCallbacks[E]): void;
    off<E extends RelayEvent>(event: E, callback: RelayEventCallbacks[E]): void;
    publish(event: NostrEvent, options?: PublishOptions): Promise<PublishResponse>;
    subscribe(filters: Filter[], onEvent: (event: NostrEvent) => void, onEOSE?: () => void, options?: SubscriptionOptions): string;
    unsubscribe(id: string): void;
    private handleMessage;
    /**
     * Process a validated event - called only after both basic and async validation
     */
    private processValidatedEvent;
    private isHexString;
    /**
     * Perform basic synchronous validation of an event
     *
     * This checks:
     * 1. Required fields are present with correct types
     * 2. Fields have valid formats (lengths, structure)
     * 3. Timestamps are reasonable
     */
    private performBasicValidation;
    /**
     * Validate an event (deprecated - use async validation directly)
     * Maintained for backward compatibility with existing code
     */
    private validateEvent;
    /**
     * Perform async validations on an event
     *
     * This includes:
     * 1. Verifying the event ID matches the hash of serialized data
     * 2. Verifying the signature is valid
     *
     * These operations are computationally expensive, so they're performed
     * asynchronously to avoid blocking the main thread.
     */
    private validateEventAsync;
    private triggerEvent;
    /**
     * Set connection timeout in milliseconds
     * @param timeout Timeout in milliseconds
     */
    setConnectionTimeout(timeout: number): void;
    /**
     * Get the current connection timeout in milliseconds
     */
    getConnectionTimeout(): number;
    /**
     * Get all subscription IDs for this relay
     * @returns A Set containing all active subscription IDs
     */
    getSubscriptionIds(): Set<string>;
    /**
     * Get the current buffer flush delay in milliseconds
     */
    getBufferFlushDelay(): number;
    /**
     * Set up the interval to flush event buffers
     */
    private setupBufferFlush;
    /**
     * Clear the buffer flush interval
     */
    private clearBufferFlush;
    /**
     * Flush all event buffers for all subscriptions
     */
    private flushAllBuffers;
    private incrementPendingValidation;
    private decrementPendingValidation;
    private markEosePending;
    private maybeFinalizeEOSE;
    /**
     * Flush the event buffer for a specific subscription
     */
    private flushSubscriptionBuffer;
    /**
     * Sort events according to NIP-01 specification:
     * 1. created_at timestamp (descending - newer events first)
     * 2. event id (lexical ascending) if timestamps are the same
     */
    private sortEvents;
    private addToEventBuffer;
    private evictOldestEventBuffer;
    private processReplaceableEvent;
    private evictOldestReplaceablePubkey;
    private processAddressableEvent;
    private evictOldestAddressableEvent;
    getLatestReplaceableEvent(pubkey: string, kind: number): NostrEvent | undefined;
    getLatestAddressableEvent(kind: number, pubkey: string, dTagValue?: string): NostrEvent | undefined;
    /**
     * Get all addressable events for a specific pubkey
     *
     * @param pubkey The public key of the user
     * @returns Array of addressable events
     */
    getAddressableEventsByPubkey(pubkey: string): NostrEvent[];
    /**
     * Get all addressable events for a specific kind
     *
     * @param kind The kind of event to retrieve (30000-39999)
     * @returns Array of addressable events
     */
    getAddressableEventsByKind(kind: number): NostrEvent[];
    private parseOkMessage;
    private isNostrEvent;
    private _isValidNip01FilterIdentifier;
}
