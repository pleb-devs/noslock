import { Relay } from "./relay";
import { NostrEvent, Filter, PublishOptions, PublishResponse } from "../types/nostr";
import { RelayConnectionOptions } from "../types/protocol";
/**
 * Result enum for removeRelay operations to provide clear error diagnostics
 */
export declare enum RemoveRelayResult {
    /** The relay was successfully removed */
    Removed = "removed",
    /** No relay was found with the given URL */
    NotFound = "not_found",
    /** The provided URL is invalid and cannot be normalized */
    InvalidUrl = "invalid_url"
}
export declare class RelayPool {
    private relays;
    private relayOptions?;
    constructor(relayUrls?: string[], options?: {
        relayOptions?: RelayConnectionOptions;
    });
    /**
     * Normalize a relay URL by preprocessing, case normalizing, and validating.
     * This ensures consistent URL keys in the relay map and prevents duplicates.
     *
     * @param url - The input URL string to normalize
     * @returns The canonicalized URL
     * @throws Error if the URL is invalid or normalization fails
     */
    private normalizeRelayUrl;
    /**
     * Add a relay to the pool or update an existing relay's configuration.
     *
     * @param url - The relay URL to add
     * @param options - Connection options for the relay
     * @returns The relay instance (new or existing)
     *
     * Note: If the relay already exists, most options will be merged into the existing
     * relay's configuration. However, `bufferFlushDelay` can only be set during
     * relay construction and will be ignored for existing relays.
     */
    addRelay(url: string, options?: RelayConnectionOptions): Relay;
    removeRelay(url: string): RemoveRelayResult;
    ensureRelay(url: string): Promise<Relay>;
    /**
     * Close relay connections. Invalid relay URLs are ignored.
     * @param relayUrls Optional array of relay URLs to close. If not provided, all relays are closed.
     */
    close(relayUrls?: string[]): Promise<void>;
    publish(relays: string[], event: NostrEvent, options?: PublishOptions): Promise<PublishResponse>[];
    subscribe(relays: string[], filters: Filter[], onEvent: (event: NostrEvent, relay: string) => void, onEOSE?: () => void): Promise<{
        close: () => void;
    }>;
    querySync(relays: string[], filter: Filter, options?: {
        timeout?: number;
    }): Promise<NostrEvent[]>;
    get(relays: string[], filter: Filter, options?: {
        timeout?: number;
    }): Promise<NostrEvent | null>;
}
