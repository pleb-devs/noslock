"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NIP46Method = void 0;
exports.initializeCrypto = initializeCrypto;
exports.generateRequestId = generateRequestId;
exports.createRequest = createRequest;
exports.createSuccessResponse = createSuccessResponse;
exports.createErrorResponse = createErrorResponse;
/**
 * NIP-46 Request and Response Utilities
 *
 * This module contains types and helper functions for NIP-46 request/response handling.
 */
const types_1 = require("../types");
Object.defineProperty(exports, "NIP46Method", { enumerable: true, get: function () { return types_1.NIP46Method; } });
// Cache for the dynamically imported crypto module
let nodeCryptoModule = null;
let cryptoInitialized = false;
/**
 * Initialize crypto module for ESM environments
 * This should be called once during application startup if using ESM
 */
async function initializeCrypto() {
    if (typeof process !== "undefined" &&
        process.versions &&
        process.versions.node &&
        !cryptoInitialized) {
        try {
            nodeCryptoModule = await Promise.resolve().then(() => __importStar(require("crypto")));
            cryptoInitialized = true;
        }
        catch (error) {
            // Ignore error - will fall back to globalThis.crypto
        }
    }
}
/**
 * Generate a cryptographically secure random request ID
 * Uses crypto.randomBytes in Node.js or crypto.getRandomValues in browsers
 */
function generateRequestId() {
    // Use Node.js crypto if available
    if (typeof process !== "undefined" &&
        process.versions &&
        process.versions.node) {
        // First try the cached module from dynamic import
        if (nodeCryptoModule && nodeCryptoModule.randomBytes) {
            return nodeCryptoModule.randomBytes(16).toString("hex");
        }
        try {
            // Try CommonJS require for backward compatibility
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const crypto = require("crypto");
            return crypto.randomBytes(16).toString("hex");
        }
        catch (error) {
            // If require fails, we're in an ESM environment
            // Use globalThis.crypto which is available in modern Node.js (v15+)
            if (typeof globalThis.crypto !== "undefined" && globalThis.crypto.getRandomValues) {
                const array = new Uint8Array(16);
                globalThis.crypto.getRandomValues(array);
                return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join("");
            }
            // Don't fall back to weak randomness - fail securely
            throw new Error("Secure random number generation not available. This is required for NIP-46 security. " +
                "For ESM environments, ensure globalThis.crypto is available or call initializeCrypto() at startup.");
        }
    }
    // Use Web Crypto API if available (browsers)
    if (typeof crypto !== "undefined" && crypto.getRandomValues) {
        const array = new Uint8Array(16);
        crypto.getRandomValues(array);
        return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join("");
    }
    // SECURITY: Never fall back to Math.random() for cryptographic purposes
    // This would create predictable IDs that could be exploited for:
    // - Replay attacks
    // - Session hijacking
    // - Authentication bypass
    throw new Error("Cryptographically secure random number generation not available. NIP-46 requires crypto.getRandomValues() or Node.js crypto module for security.");
}
/**
 * Create a NIP-46 request object
 */
function createRequest(method, params) {
    return {
        id: generateRequestId(),
        method,
        params,
    };
}
/**
 * Create a success response
 */
function createSuccessResponse(id, result) {
    return { id, result };
}
/**
 * Create an error response
 */
function createErrorResponse(id, error) {
    return { id, error };
}
