import { NostrEvent } from "../types/nostr";
import { NIP46ClientOptions, NIP46UnsignedEventData } from "./types";
export declare class NostrRemoteSignerClient {
    private nostr;
    private clientKeypair;
    private signerPubkey;
    private userPubkey;
    private pendingRequests;
    private options;
    private authWindow;
    private connected;
    private subId;
    private logger;
    private debug;
    private pendingAuthChallenges;
    constructor(options?: NIP46ClientOptions);
    /**
     * Set up subscription to receive responses from the signer
     */
    private setupSubscription;
    /**
     * Clean up resources and reset state
     */
    private cleanup;
    /**
     * Connect to a remote signer
     * @throws {Error} If connection fails or validation fails
     * @returns {string} "ack" or required secret value (NOT the user pubkey)
     */
    connect(connectionString: string): Promise<string>;
    /**
     * Disconnect from the remote signer
     */
    disconnect(): Promise<void>;
    /**
     * Sign an event
     * @throws {Error} If signing fails
     */
    signEvent(eventData: NIP46UnsignedEventData): Promise<NostrEvent>;
    /**
     * Get the user's public key (must be called after connect())
     * This is required by NIP-46 spec - clients must differentiate between
     * remote-signer-pubkey and user-pubkey
     */
    getUserPublicKey(): Promise<string>;
    /**
     * @deprecated Use getUserPublicKey() instead. This method name doesn't clearly
     * indicate it's getting the USER's public key, not the signer's public key.
     */
    getPublicKey(): Promise<string>;
    /**
     * Ping the signer
     * @throws {Error} If ping fails
     */
    ping(): Promise<string>;
    /**
     * Encrypt data with NIP-44
     * @throws {Error} If encryption fails
     */
    nip44Encrypt(thirdPartyPubkey: string, plaintext: string): Promise<string>;
    /**
     * Decrypt data with NIP-44
     * @throws {Error} If decryption fails
     */
    nip44Decrypt(thirdPartyPubkey: string, ciphertext: string): Promise<string>;
    /**
     * Get relay list
     * @throws {Error} If request fails
     */
    getRelays(): Promise<string[]>;
    /**
     * Encrypt data with NIP-04
     * @throws {Error} If encryption fails
     */
    nip04Encrypt(thirdPartyPubkey: string, plaintext: string): Promise<string>;
    /**
     * Decrypt data with NIP-04
     * @throws {Error} If decryption fails
     */
    nip04Decrypt(thirdPartyPubkey: string, ciphertext: string): Promise<string>;
    /**
     * Send a request to the signer and wait for response
     * @private
     */
    private sendRequest;
    /**
     * Send encrypted request to signer
     * @private
     */
    private sendEncryptedRequest;
    /**
     * Handle incoming response from signer
     * @private
     */
    private handleResponse;
    /**
     * Decrypt response content
     * @private
     */
    private decryptContent;
    /**
     * Handle auth challenge from signer
     * @private
     */
    private handleAuthChallenge;
    /**
     * Monitor auth window for completion
     * @private
     */
    private monitorAuthWindow;
    /**
     * Handle auth timeout
     * @private
     */
    private handleAuthTimeout;
    /**
     * Generate a unique request ID
     * @private
     */
    private generateRequestId;
    /**
     * Generate a connection string for this client
     * @static
     */
    static generateConnectionString(clientPubkey: string, options?: NIP46ClientOptions): string;
}
