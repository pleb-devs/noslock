"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.GIFT_WRAP_KIND = exports.SEAL_KIND = exports.FILE_KIND = exports.DM_KIND = void 0;
exports.initializeCrypto = initializeCrypto;
exports.createDirectMessage = createDirectMessage;
exports.decryptDirectMessage = decryptDirectMessage;
const nip44_1 = require("../nip44");
const crypto_1 = require("../utils/crypto");
const event_1 = require("../nip01/event");
// Cache for the dynamically imported crypto module
let nodeCryptoModule = null;
let cryptoInitialized = false;
/**
 * Initialize crypto module for ESM environments
 * This should be called once during application startup if using ESM
 */
async function initializeCrypto() {
    if (typeof process !== "undefined" &&
        process.versions &&
        process.versions.node &&
        !cryptoInitialized) {
        try {
            nodeCryptoModule = await Promise.resolve().then(() => __importStar(require("crypto")));
            cryptoInitialized = true;
        }
        catch (error) {
            // Ignore error - will fall back to globalThis.crypto
        }
    }
}
/**
 * Generate a timestamp up to two days in the past.
 * Used to obscure creation time as recommended by the spec.
 */
function randomTimestampInPast() {
    const twoDays = 2 * 24 * 60 * 60 * 1000;
    // Use secure random for gift wrap timing (security critical)
    const secureRandomValue = (() => {
        if (typeof crypto !== "undefined" && crypto.getRandomValues) {
            const array = new Uint32Array(1);
            crypto.getRandomValues(array);
            return array[0] / (0xffffffff + 1);
        }
        else if (typeof process !== "undefined" &&
            process.versions &&
            process.versions.node) {
            // Try to use pre-imported crypto module first
            if (nodeCryptoModule) {
                return nodeCryptoModule.randomInt(0, 0x100000000) / 0x100000000;
            }
            // Fallback to require for CommonJS environments
            try {
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                const nodeCrypto = require("crypto");
                return nodeCrypto.randomInt(0, 0x100000000) / 0x100000000;
            }
            catch (requireError) {
                // If require fails in ESM, throw informative error
                throw new Error("No secure random source available for gift wrap timing. In ESM environments, call initializeCrypto() before using NIP-17 functions.");
            }
        }
        throw new Error("No secure random source available for gift wrap timing");
    })();
    const offset = Math.floor(secureRandomValue * twoDays);
    return Math.floor((Date.now() - offset) / 1000);
}
/** Constant for text message kind */
exports.DM_KIND = 14;
/** Constant for file message kind */
exports.FILE_KIND = 15;
/** Kind for seal events */
exports.SEAL_KIND = 13;
/** Kind for gift wrap events */
exports.GIFT_WRAP_KIND = 1059;
/**
 * Create a gift wrapped direct message event for a single receiver.
 *
 * The returned event is a kind 1059 event containing a sealed kind 13 event,
 * which in turn wraps the unsigned kind 14 rumor.
 */
async function createDirectMessage(message, senderPrivateKey, receiverPublicKey) {
    const senderPub = (0, crypto_1.getPublicKey)(senderPrivateKey);
    const rumor = {
        pubkey: senderPub,
        created_at: randomTimestampInPast(),
        kind: exports.DM_KIND,
        tags: [["p", receiverPublicKey]],
        content: message,
    };
    const sealedContent = (0, nip44_1.encrypt)(JSON.stringify(rumor), senderPrivateKey, receiverPublicKey);
    const seal = {
        pubkey: senderPub,
        created_at: randomTimestampInPast(),
        kind: exports.SEAL_KIND,
        content: sealedContent,
        tags: [],
    };
    const signedSeal = await (0, event_1.createSignedEvent)(seal, senderPrivateKey);
    const ephemeral = await (0, crypto_1.generateKeypair)();
    const wrappedContent = (0, nip44_1.encrypt)(JSON.stringify(signedSeal), ephemeral.privateKey, receiverPublicKey);
    const wrap = {
        pubkey: ephemeral.publicKey,
        created_at: randomTimestampInPast(),
        kind: exports.GIFT_WRAP_KIND,
        content: wrappedContent,
        tags: [["p", receiverPublicKey]],
    };
    const signedWrap = await (0, event_1.createSignedEvent)(wrap, ephemeral.privateKey);
    return signedWrap;
}
/**
 * Decrypt a gift wrapped direct message.
 *
 * Returns the inner kind 14 rumor event.
 */
function decryptDirectMessage(giftWrap, receiverPrivateKey) {
    if (giftWrap.kind !== exports.GIFT_WRAP_KIND) {
        throw new Error("Invalid gift wrap kind");
    }
    const sealJson = (0, nip44_1.decrypt)(giftWrap.content, receiverPrivateKey, giftWrap.pubkey);
    const seal = JSON.parse(sealJson);
    if (seal.kind !== exports.SEAL_KIND) {
        throw new Error("Invalid seal kind");
    }
    const validSeal = (0, crypto_1.verifySignature)(seal.id, seal.sig, seal.pubkey);
    if (!validSeal) {
        throw new Error("Invalid seal signature");
    }
    const rumorJson = (0, nip44_1.decrypt)(seal.content, receiverPrivateKey, seal.pubkey);
    const rumor = JSON.parse(rumorJson);
    if (rumor.pubkey !== seal.pubkey) {
        throw new Error("Sender mismatch between seal and rumor");
    }
    if (rumor.kind !== exports.DM_KIND && rumor.kind !== exports.FILE_KIND) {
        throw new Error("Invalid rumor kind");
    }
    return rumor;
}
