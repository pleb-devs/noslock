"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateRelayUrl = validateRelayUrl;
exports.encodeBech32 = encodeBech32;
exports.decodeBech32 = decodeBech32;
exports.encodePublicKey = encodePublicKey;
exports.decodePublicKey = decodePublicKey;
exports.encodePrivateKey = encodePrivateKey;
exports.decodePrivateKey = decodePrivateKey;
exports.encodeNoteId = encodeNoteId;
exports.decodeNoteId = decodeNoteId;
exports.encodeProfile = encodeProfile;
exports.decodeProfile = decodeProfile;
exports.encodeEvent = encodeEvent;
exports.decodeEvent = decodeEvent;
exports.encodeAddress = encodeAddress;
exports.decodeAddress = decodeAddress;
exports.decode = decode;
const base_1 = require("@scure/base");
const types_1 = require("./types");
// Re-export types
__exportStar(require("./types"), exports);
// Default limit for bech32 length (standard is 90, but we use higher for TLV)
// Apparently some users even breaking through 1500 limit, lets raise it to 5000 like nostr-tools
// https://github.com/nbd-wtf/nostr-tools/issues/74
const DEFAULT_LIMIT = 5000;
// TLV size limits - these are reasonable limits to prevent abuse
const MAX_RELAY_URL_LENGTH = 512; // Max length for a relay URL
const MAX_IDENTIFIER_LENGTH = 1024; // Max length for an identifier (d tag)
const MAX_TLV_ENTRIES = 20; // Max number of TLV entries to prevent DoS (reduced from 100)
/**
 * Validates a relay URL format
 * Relay URLs must start with wss:// or ws:// and contain a valid hostname
 * No credentials are allowed in URLs
 * @deprecated Use isValidRelayUrl from './secure' instead. Will be removed in next major version.
 */
function validateRelayUrl(url) {
    return (0, secure_1.isValidRelayUrl)(url);
}
/**
 * Helper function to safely encode using bech32 with a higher limit
 */
function encodeBech32WithLimit(prefix, words, limit = DEFAULT_LIMIT) {
    try {
        // Use a type assertion for the prefix since we know it's valid in our context
        return base_1.bech32.encode(prefix, words, limit);
    }
    catch (error) {
        throw new Error(`Failed to encode bech32: ${error instanceof Error ? error.message : "unknown error"}`);
    }
}
/**
 * Helper function to safely decode bech32 strings with a higher limit
 */
function decodeBech32WithLimit(bech32Str, limit = DEFAULT_LIMIT) {
    try {
        // Use a type assertion for the input since we know it's valid in our context
        return base_1.bech32.decode(bech32Str, limit);
    }
    catch (error) {
        throw new Error(`Failed to decode bech32: ${error instanceof Error ? error.message : "unknown error"}`);
    }
}
/**
 * Encodes a hex string to a bech32 string with the given prefix
 */
function encodeBech32(prefix, data) {
    const dataBytes = hexToBytes(data);
    const words = base_1.bech32.toWords(dataBytes);
    return base_1.bech32.encode(prefix, words);
}
/**
 * Decodes a bech32 string to a hex string
 */
function decodeBech32(bech32Str) {
    // First, check if the prefix is valid without full decoding
    // This ensures 'Invalid prefix' errors take precedence over other errors
    const hrp = bech32Str.slice(0, bech32Str.indexOf("1"));
    try {
        const { prefix, words } = base_1.bech32.decode(bech32Str);
        const bytes = base_1.bech32.fromWords(words);
        const data = bytesToHex(bytes);
        return { prefix, data };
    }
    catch (error) {
        // If the error is about invalid length but we got a valid hrp,
        // we want to prioritize prefix validation errors for consistency
        if (error instanceof Error &&
            error.message.includes("invalid string length") &&
            !Object.values(types_1.Prefix).includes(hrp)) {
            throw new Error(`Invalid prefix: expected valid prefix, got '${hrp}'`);
        }
        throw error;
    }
}
/**
 * Encodes a public key to npub format
 */
function encodePublicKey(publicKey) {
    if (typeof publicKey !== "string") {
        throw new Error("Invalid public key: input must be a string.");
    }
    // hexToBytes will validate format, non-empty, but we also need to check exact length.
    const bytes = hexToBytes(publicKey); // hexToBytes validates format, non-even length, non-hex chars
    if (bytes.length !== 32) {
        throw new Error(`Invalid public key hex: expected 32 bytes (64 hex chars), got ${bytes.length} bytes (${publicKey.length} hex chars). Ensure it is not empty and has correct length.`);
    }
    const words = base_1.bech32.toWords(bytes);
    return encodeBech32WithLimit(types_1.Prefix.PublicKey, words);
}
/**
 * Helper function to create a consistent error handling approach
 * that distinguishes between specialized errors and general decoding errors
 */
function handleDecodingError(error, entityType) {
    // Only pass through specific error types we want to preserve
    if (error instanceof Error) {
        // Special case: handle string length errors for bech32 strings with wrong prefixes
        if (error.message.includes("invalid string length") &&
            error.message.includes("Expected") &&
            error.message.includes(")")) {
            // Extract the actual string from the error message
            const match = error.message.match(/\(([^)]+)\)/);
            if (match && match[1]) {
                const bech32Str = match[1];
                const actualPrefix = bech32Str.split("1")[0];
                const expectedPrefix = getExpectedPrefixForEntityType(entityType);
                if (actualPrefix && expectedPrefix && actualPrefix !== expectedPrefix) {
                    throw new Error(`Invalid prefix: expected '${expectedPrefix}', got '${actualPrefix}'`);
                }
            }
        }
        // Pass through these error types directly as they have specific context
        if (error.message.startsWith("Invalid prefix") ||
            error.message.startsWith("TLV type") ||
            error.message.startsWith("Missing") ||
            error.message.includes("should be") ||
            error.message.startsWith("Invalid TLV structure") ||
            error.message.startsWith("Invalid relay URL") ||
            error.message.includes("too long") ||
            error.message.includes("exceeds maximum")) {
            throw error;
        }
        // If it's a bech32 error, provide better context
        if (error.message.startsWith("Failed to decode bech32")) {
            throw new Error(`Invalid ${entityType} format: bech32 decoding failed - ${error.message}`);
        }
        // If it's about malformed data, provide better context
        if (error.message.includes("Invalid")) {
            throw new Error(`Invalid ${entityType} format: ${error.message}`);
        }
    }
    // Wrap general errors with context
    const errorMessage = error instanceof Error ? error.message : String(error) || "unknown error";
    throw new Error(`Error decoding ${entityType}: ${errorMessage}`);
}
/**
 * Helper function to get the expected prefix for a given entity type
 */
function getExpectedPrefixForEntityType(entityType) {
    switch (entityType) {
        case "npub":
            return types_1.Prefix.PublicKey;
        case "nsec":
            return types_1.Prefix.PrivateKey;
        case "note":
            return types_1.Prefix.Note;
        case "nprofile":
            return types_1.Prefix.Profile;
        case "nevent":
            return types_1.Prefix.Event;
        case "naddr":
            return types_1.Prefix.Address;
        default:
            return null;
    }
}
/**
 * Decodes an npub to a public key
 */
function decodePublicKey(npub) {
    try {
        const { prefix, data } = decodeBech32(npub);
        if (prefix !== types_1.Prefix.PublicKey) {
            throw new Error(`Invalid prefix: expected '${types_1.Prefix.PublicKey}', got '${prefix}'`);
        }
        return data;
    }
    catch (error) {
        handleDecodingError(error, "npub");
    }
}
/**
 * Encodes a private key to nsec format
 */
function encodePrivateKey(privateKey) {
    if (typeof privateKey !== "string") {
        throw new Error("Invalid private key: input must be a string.");
    }
    const bytes = hexToBytes(privateKey);
    if (bytes.length !== 32) {
        throw new Error(`Invalid private key hex: expected 32 bytes (64 hex chars), got ${bytes.length} bytes (${privateKey.length} hex chars). Ensure it is not empty and has correct length.`);
    }
    const words = base_1.bech32.toWords(bytes);
    return encodeBech32WithLimit(types_1.Prefix.PrivateKey, words);
}
/**
 * Decodes an nsec to a private key
 */
function decodePrivateKey(nsec) {
    try {
        const { prefix, data } = decodeBech32(nsec);
        if (prefix !== types_1.Prefix.PrivateKey) {
            throw new Error(`Invalid prefix: expected '${types_1.Prefix.PrivateKey}', got '${prefix}'`);
        }
        return data;
    }
    catch (error) {
        handleDecodingError(error, "nsec");
    }
}
/**
 * Encodes a note ID to note format
 */
function encodeNoteId(noteId) {
    if (typeof noteId !== "string") {
        throw new Error("Invalid note ID: input must be a string.");
    }
    const bytes = hexToBytes(noteId);
    if (bytes.length !== 32) {
        throw new Error(`Invalid note ID hex: expected 32 bytes (64 hex chars), got ${bytes.length} bytes (${noteId.length} hex chars). Ensure it is not empty and has correct length.`);
    }
    const words = base_1.bech32.toWords(bytes);
    return encodeBech32WithLimit(types_1.Prefix.Note, words);
}
/**
 * Decodes a note to a note ID
 */
function decodeNoteId(note) {
    try {
        const { prefix, data } = decodeBech32(note);
        if (prefix !== types_1.Prefix.Note) {
            throw new Error(`Invalid prefix: expected '${types_1.Prefix.Note}', got '${prefix}'`);
        }
        return data;
    }
    catch (error) {
        handleDecodingError(error, "note");
    }
}
// TLV (Type-Length-Value) encoding/decoding
/**
 * Encodes a list of TLV entries into a single byte array
 */
function encodeTLV(entries) {
    // Calculate total length
    let totalLength = 0;
    for (const entry of entries) {
        totalLength += 2 + entry.value.length; // 1 byte for type, 1 byte for length, n bytes for value
    }
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const entry of entries) {
        // Write type
        result[offset++] = entry.type;
        // Write length
        result[offset++] = entry.value.length;
        // Write value
        result.set(entry.value, offset);
        offset += entry.value.length;
    }
    return result;
}
/**
 * Decodes a TLV encoded byte array into a list of TLV entries
 */
function decodeTLV(data) {
    const entries = [];
    let offset = 0;
    // We need at least 2 bytes per entry (type and length)
    while (offset < data.length - 1) {
        const type = data[offset++];
        const length = data[offset++];
        // Check if we have enough data for the value
        if (offset + length > data.length) {
            throw new Error("Invalid TLV structure: data too short");
        }
        // Read the value
        const value = data.slice(offset, offset + length);
        offset += length;
        // Limit the number of entries to prevent DoS
        if (entries.length >= MAX_TLV_ENTRIES) {
            throw new Error(`TLV entry count exceeds maximum of ${MAX_TLV_ENTRIES}`);
        }
        entries.push({ type, value });
    }
    return entries;
}
/**
 * Encodes a profile to nprofile format
 */
function encodeProfile(data) {
    // First, validate the pubkey
    if (!data.pubkey || data.pubkey.length !== 64) {
        throw new Error("Invalid pubkey: must be a 32-byte hex string");
    }
    // Start building TLV entries with the pubkey
    const entries = [
        {
            type: types_1.TLVType.Special,
            value: hexToBytes(data.pubkey),
        },
    ];
    // Add relays if provided
    if (data.relays && data.relays.length > 0) {
        // Check for too many relay entries
        if (data.relays.length > MAX_TLV_ENTRIES - 1) {
            // -1 for the pubkey entry
            throw new Error(`Too many relay entries (max ${MAX_TLV_ENTRIES - 1})`);
        }
        for (const relay of data.relays) {
            // Check relay URL length
            if (relay.length > MAX_RELAY_URL_LENGTH) {
                throw new Error(`Relay URL too long (max ${MAX_RELAY_URL_LENGTH} characters)`);
            }
            // Validate relay URL format
            if (!(0, secure_1.isValidRelayUrl)(relay)) {
                throw new Error(`Invalid relay URL: ${relay}`);
            }
            entries.push({
                type: types_1.TLVType.Relay,
                value: new TextEncoder().encode(relay),
            });
        }
    }
    // Encode the TLV entries
    const tlvData = encodeTLV(entries);
    // Convert to bech32 words (5-bit) for encoding
    const words = base_1.bech32.toWords(tlvData);
    // Encode as bech32
    return encodeBech32WithLimit(types_1.Prefix.Profile, words);
}
/**
 * Decodes an nprofile to profile data
 */
function decodeProfile(nprofile) {
    try {
        // Decode the bech32 string
        const { prefix, words } = decodeBech32WithLimit(nprofile);
        // Check prefix
        if (prefix !== types_1.Prefix.Profile) {
            throw new Error(`Invalid prefix: expected '${types_1.Prefix.Profile}', got '${prefix}'`);
        }
        // Convert from bech32 words to bytes
        const data = base_1.bech32.fromWords(words);
        // Decode the TLV entries
        const entries = decodeTLV(data);
        // Extract the profile data
        let pubkey;
        const relays = [];
        for (const entry of entries) {
            if (entry.type === types_1.TLVType.Special) {
                // This is the pubkey
                if (entry.value.length !== 32) {
                    throw new Error("Invalid pubkey length: should be 32 bytes");
                }
                pubkey = bytesToHex(entry.value);
            }
            else if (entry.type === types_1.TLVType.Relay) {
                // This is a relay URL
                const relay = new TextDecoder().decode(entry.value);
                relays.push(relay);
                // Warn about invalid relay URLs but still include them
                if (!(0, secure_1.isValidRelayUrl)(relay)) {
                    console.warn(`Warning: Invalid relay URL format found while decoding: ${relay}`);
                }
            }
            // Ignore unknown types for forward compatibility
        }
        // Ensure we found a pubkey
        if (!pubkey) {
            throw new Error("Missing pubkey in nprofile");
        }
        return {
            pubkey,
            relays: relays.length > 0 ? relays : undefined,
        };
    }
    catch (error) {
        handleDecodingError(error, "nprofile");
    }
}
/**
 * Encodes an event to nevent format
 */
function encodeEvent(data) {
    // First, validate the event ID
    if (!data.id || data.id.length !== 64) {
        throw new Error("Invalid event ID: must be a 32-byte hex string");
    }
    // Start building TLV entries with the event ID
    const entries = [
        {
            type: types_1.TLVType.Special,
            value: hexToBytes(data.id),
        },
    ];
    // Add relays if provided
    if (data.relays && data.relays.length > 0) {
        // Check for too many relay entries
        if (data.relays.length > MAX_TLV_ENTRIES - 3) {
            // -3 for id, author, kind
            throw new Error(`Too many relay entries (max ${MAX_TLV_ENTRIES - 3})`);
        }
        for (const relay of data.relays) {
            // Check relay URL length
            if (relay.length > MAX_RELAY_URL_LENGTH) {
                throw new Error(`Relay URL too long (max ${MAX_RELAY_URL_LENGTH} characters)`);
            }
            // Validate relay URL format
            if (!(0, secure_1.isValidRelayUrl)(relay)) {
                throw new Error(`Invalid relay URL: ${relay}`);
            }
            entries.push({
                type: types_1.TLVType.Relay,
                value: new TextEncoder().encode(relay),
            });
        }
    }
    // Add author if provided
    if (data.author) {
        if (data.author.length !== 64) {
            throw new Error("Invalid author pubkey: must be a 32-byte hex string");
        }
        entries.push({
            type: types_1.TLVType.Author,
            value: hexToBytes(data.author),
        });
    }
    // Encode the TLV entries
    const tlvData = encodeTLV(entries);
    // Convert to bech32 words (5-bit) for encoding
    const words = base_1.bech32.toWords(tlvData);
    // Encode as bech32
    return encodeBech32WithLimit(types_1.Prefix.Event, words);
}
/**
 * Decodes an nevent to event data
 */
function decodeEvent(nevent) {
    try {
        // Decode the bech32 string
        const { prefix, words } = decodeBech32WithLimit(nevent);
        // Check prefix
        if (prefix !== types_1.Prefix.Event) {
            throw new Error(`Invalid prefix: expected '${types_1.Prefix.Event}', got '${prefix}'`);
        }
        // Convert from bech32 words to bytes
        const data = base_1.bech32.fromWords(words);
        // Decode the TLV entries
        const entries = decodeTLV(data);
        // Extract the event data
        let id;
        const relays = [];
        let author;
        for (const entry of entries) {
            if (entry.type === types_1.TLVType.Special) {
                // This is the event ID
                if (entry.value.length !== 32) {
                    throw new Error("Invalid event ID length: should be 32 bytes");
                }
                id = bytesToHex(entry.value);
            }
            else if (entry.type === types_1.TLVType.Relay) {
                // This is a relay URL
                const relay = new TextDecoder().decode(entry.value);
                relays.push(relay);
                // Warn about invalid relay URLs but still include them
                if (!(0, secure_1.isValidRelayUrl)(relay)) {
                    console.warn(`Warning: Invalid relay URL format found while decoding: ${relay}`);
                }
            }
            else if (entry.type === types_1.TLVType.Author) {
                // This is the author pubkey
                if (entry.value.length !== 32) {
                    throw new Error("Invalid author pubkey length: should be 32 bytes");
                }
                author = bytesToHex(entry.value);
            }
            // Ignore unknown types for forward compatibility
        }
        // Ensure we found an event ID
        if (!id) {
            throw new Error("Missing event ID in nevent");
        }
        return {
            id,
            relays: relays.length > 0 ? relays : undefined,
            author,
        };
    }
    catch (error) {
        handleDecodingError(error, "nevent");
    }
}
/**
 * Encodes an address to naddr format
 */
function encodeAddress(data) {
    // Validate the required fields
    if (!data.identifier) {
        throw new Error("Missing identifier in address data");
    }
    if (!data.pubkey || data.pubkey.length !== 64) {
        throw new Error("Invalid pubkey: must be a 32-byte hex string");
    }
    if (data.kind === undefined || data.kind < 0 || data.kind > 0xffffffff) {
        // Allow full 32-bit unsigned range
        throw new Error("Invalid kind: must be a 32-bit unsigned integer (0 to 4294967295)");
    }
    // Check identifier length
    if (data.identifier.length > MAX_IDENTIFIER_LENGTH) {
        throw new Error(`Identifier too long (max ${MAX_IDENTIFIER_LENGTH} characters)`);
    }
    // Start building TLV entries with the identifier
    const entries = [
        {
            type: types_1.TLVType.Special,
            value: new TextEncoder().encode(data.identifier),
        },
    ];
    // Add relays if provided
    if (data.relays && data.relays.length > 0) {
        // Check for too many relay entries
        if (data.relays.length > MAX_TLV_ENTRIES - 3) {
            // -3 for identifier, pubkey, kind
            throw new Error(`Too many relay entries (max ${MAX_TLV_ENTRIES - 3})`);
        }
        for (const relay of data.relays) {
            // Check relay URL length
            if (relay.length > MAX_RELAY_URL_LENGTH) {
                throw new Error(`Relay URL too long (max ${MAX_RELAY_URL_LENGTH} characters)`);
            }
            // Validate relay URL format
            if (!(0, secure_1.isValidRelayUrl)(relay)) {
                throw new Error(`Invalid relay URL: ${relay}`);
            }
            entries.push({
                type: types_1.TLVType.Relay,
                value: new TextEncoder().encode(relay),
            });
        }
    }
    // Add author (pubkey)
    entries.push({
        type: types_1.TLVType.Author,
        value: hexToBytes(data.pubkey),
    });
    // Add kind
    const kindBytes = new Uint8Array(4); // Changed to 4 bytes
    kindBytes[0] = (data.kind >> 24) & 0xff;
    kindBytes[1] = (data.kind >> 16) & 0xff;
    kindBytes[2] = (data.kind >> 8) & 0xff;
    kindBytes[3] = data.kind & 0xff;
    entries.push({
        type: types_1.TLVType.Kind,
        value: kindBytes,
    });
    // Encode the TLV entries
    const tlvData = encodeTLV(entries);
    // Convert to bech32 words (5-bit) for encoding
    const words = base_1.bech32.toWords(tlvData);
    // Encode as bech32
    return encodeBech32WithLimit(types_1.Prefix.Address, words);
}
/**
 * Decodes an naddr to address data
 */
function decodeAddress(naddr) {
    try {
        // Decode the bech32 string
        const { prefix, words } = decodeBech32WithLimit(naddr);
        // Check prefix
        if (prefix !== types_1.Prefix.Address) {
            throw new Error(`Invalid prefix: expected '${types_1.Prefix.Address}', got '${prefix}'`);
        }
        // Convert from bech32 words to bytes
        const data = base_1.bech32.fromWords(words);
        // Decode the TLV entries
        const entries = decodeTLV(data);
        // Extract the address data
        let identifier;
        const relays = [];
        let pubkey;
        let kind;
        for (const entry of entries) {
            if (entry.type === types_1.TLVType.Special) {
                // This is the identifier (d tag)
                identifier = new TextDecoder().decode(entry.value);
            }
            else if (entry.type === types_1.TLVType.Relay) {
                // This is a relay URL
                const relay = new TextDecoder().decode(entry.value);
                relays.push(relay);
                // Warn about invalid relay URLs but still include them
                if (!(0, secure_1.isValidRelayUrl)(relay)) {
                    console.warn(`Warning: Invalid relay URL format found while decoding: ${relay}`);
                }
            }
            else if (entry.type === types_1.TLVType.Author) {
                // This is the pubkey
                if (entry.value.length !== 32) {
                    throw new Error("Invalid pubkey length: should be 32 bytes");
                }
                pubkey = bytesToHex(entry.value);
            }
            else if (entry.type === types_1.TLVType.Kind) {
                // This is the event kind
                if (entry.value.length !== 4) {
                    throw new Error("Invalid kind length: should be 4 bytes");
                }
                kind =
                    (entry.value[0] << 24) +
                        (entry.value[1] << 16) +
                        (entry.value[2] << 8) +
                        entry.value[3];
            }
            // Ignore unknown types for forward compatibility
        }
        // Ensure we have all required fields
        if (!identifier) {
            throw new Error("Missing identifier in naddr");
        }
        if (!pubkey) {
            throw new Error("Missing pubkey in naddr");
        }
        if (kind === undefined) {
            throw new Error("Missing kind in naddr");
        }
        return {
            identifier,
            pubkey,
            kind,
            relays: relays.length > 0 ? relays : undefined,
        };
    }
    catch (error) {
        handleDecodingError(error, "naddr");
    }
}
/**
 * Converts a hex string to a byte array
 */
function hexToBytes(hex) {
    if (typeof hex !== "string") {
        throw new Error("Invalid hex string: input must be a string.");
    }
    if (hex.length === 0) {
        // Explicitly disallow empty string for this context.
        throw new Error("Invalid hex string: cannot be empty.");
    }
    if (hex.length % 2 !== 0) {
        throw new Error("Invalid hex string: length must be even.");
    }
    if (!/^[0-9a-fA-F]*$/.test(hex)) {
        // Add regex check for all characters
        throw new Error("Invalid hex string: contains non-hex characters.");
    }
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        const start = i * 2;
        const hexByte = hex.slice(start, start + 2);
        const byte = parseInt(hexByte, 16);
        if (isNaN(byte)) {
            throw new Error(`Invalid hex string: "${hexByte}" is not a valid hex byte`);
        }
        bytes[i] = byte;
    }
    return bytes;
}
/**
 * Converts a byte array to a hex string
 */
function bytesToHex(bytes) {
    let hex = "";
    for (let i = 0; i < bytes.length; i++) {
        hex += bytes[i].toString(16).padStart(2, "0");
    }
    return hex;
}
/**
 * Universal decoder for any NIP-19 entity
 */
function decode(bech32Str) {
    // Basic validation for bech32 format
    if (!bech32Str.includes("1")) {
        throw new Error("Invalid bech32 string format: missing separator character '1'");
    }
    // Extract the prefix from the bech32 string
    const prefix = bech32Str.slice(0, bech32Str.indexOf("1"));
    switch (prefix) {
        case types_1.Prefix.PublicKey:
            return {
                type: types_1.Prefix.PublicKey,
                data: decodePublicKey(bech32Str),
            };
        case types_1.Prefix.PrivateKey:
            return {
                type: types_1.Prefix.PrivateKey,
                data: decodePrivateKey(bech32Str),
            };
        case types_1.Prefix.Note:
            return {
                type: types_1.Prefix.Note,
                data: decodeNoteId(bech32Str),
            };
        case types_1.Prefix.Profile:
            return {
                type: types_1.Prefix.Profile,
                data: decodeProfile(bech32Str),
            };
        case types_1.Prefix.Event:
            return {
                type: types_1.Prefix.Event,
                data: decodeEvent(bech32Str),
            };
        case types_1.Prefix.Address:
            return {
                type: types_1.Prefix.Address,
                data: decodeAddress(bech32Str),
            };
        default:
            throw new Error(`Unknown prefix: ${prefix}`);
    }
}
// Export security utilities
const secure_1 = require("./secure");
__exportStar(require("./secure"), exports);
