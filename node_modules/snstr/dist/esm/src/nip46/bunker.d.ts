import { NostrEvent } from "../types/nostr";
import { NIP46BunkerOptions, NIP46Metadata } from "./types";
export declare class NostrRemoteSignerBunker {
    private nostr;
    private userKeypair;
    private signerKeypair;
    private options;
    private connectedClients;
    private pendingAuthChallenges;
    private subId;
    private logger;
    private rateLimiter;
    private permissionHandler;
    private usedRequestIds;
    private cleanupInterval;
    constructor(options: NIP46BunkerOptions);
    /**
     * Get the public key of the signer
     */
    getSignerPubkey(): string;
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Set the user's private key
     */
    setUserPrivateKey(privateKey: string): void;
    /**
     * Set the signer's private key
     */
    setSignerPrivateKey(privateKey: string): void;
    /**
     * Initialize both user and signer private keys
     */
    setPrivateKeys(userPrivateKey: string, signerPrivateKey?: string): void;
    /**
     * Set a custom permission handler for advanced permission logic
     * @param handler - Function that takes (clientPubkey, method, params) and returns:
     *                  - true: Allow the operation
     *                  - false: Deny the operation
     *                  - null: Use default permission checking
     */
    setPermissionHandler(handler: (clientPubkey: string, method: string, params: string[]) => boolean | null): void;
    /**
     * Remove the custom permission handler
     */
    clearPermissionHandler(): void;
    /**
     * Check if a request ID has been used before (replay attack prevention)
     * @private
     */
    private isReplayAttack;
    /**
     * Clean up old request IDs to prevent memory leaks
     * @private
     */
    private cleanupOldRequestIds;
    /**
     * Resolve an auth challenge by marking it as resolved
     * @param pubkey The client pubkey that completed authentication
     * @returns true if the challenge was found and resolved, false otherwise
     */
    resolveAuthChallenge(pubkey: string): boolean;
    /**
     * Create an auth challenge for a client
     * @param clientPubkey The client's public key
     * @param permissions The permissions being requested
     * @returns The auth challenge object
     */
    private createAuthChallenge;
    /**
     * Periodic cleanup of expired data
     */
    private cleanup;
    /**
     * Handle incoming request events
     * @private
     */
    private handleRequest;
    /**
     * Handle connect requests
     * @private
     */
    private handleConnect;
    /**
     * Handle event signing requests
     * @private
     */
    private handleSignEvent;
    /**
     * Handle get public key requests
     * @private
     */
    private handleGetPublicKey;
    /**
     * Handle disconnect requests
     * @private
     */
    private handleDisconnect;
    /**
     * Handle encryption/decryption requests
     * @private
     */
    private handleEncryption;
    /**
     * Send a response back to the client
     * @private
     */
    private sendResponse;
    /**
     * Check if a client is authorized (has completed auth challenge)
     * @private
     */
    private isClientAuthorized;
    getConnectionString(): string;
    /**
     * Publish bunker metadata to relays
     */
    publishMetadata(metadata: NIP46Metadata): Promise<NostrEvent | undefined>;
    /**
     * Decrypt content from a client
     * @private
     */
    private decryptContent;
    private hasPermission;
}
