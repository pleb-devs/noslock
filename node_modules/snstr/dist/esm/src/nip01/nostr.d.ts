import { Relay } from "./relay";
import { NostrEvent, Filter, RelayEvent, ParsedOkReason, SubscriptionOptions } from "../types/nostr";
/**
 * Rate limit configuration for different operation types
 */
export interface RateLimitConfig {
    /** Maximum number of operations allowed */
    limit: number;
    /** Time window in milliseconds */
    windowMs: number;
}
/**
 * Configuration options for rate limiting different Nostr operations
 */
export interface NostrRateLimits {
    /** Rate limits for subscription operations */
    subscribe?: RateLimitConfig;
    /** Rate limits for publish operations */
    publish?: RateLimitConfig;
    /** Rate limits for fetch operations */
    fetch?: RateLimitConfig;
}
/**
 * Options for Nostr client configuration
 */
export interface NostrOptions {
    /** Options to pass to each Relay instance */
    relayOptions?: {
        connectionTimeout?: number;
        bufferFlushDelay?: number;
    };
    /** Rate limiting configuration for different operations */
    rateLimits?: NostrRateLimits;
}
export type NostrConnectCallback = (relay: string) => void;
export type NostrErrorCallback = (relay: string, error: unknown) => void;
export type NostrNoticeCallback = (relay: string, notice: string) => void;
export type NostrOkCallback = (relay: string, eventId: string, success: boolean, details: ParsedOkReason) => void;
export type NostrClosedCallback = (relay: string, subscriptionId: string, message: string) => void;
export type NostrAuthCallback = (relay: string, challengeEvent: NostrEvent) => void;
export type NostrEventCallback = NostrConnectCallback | NostrErrorCallback | NostrNoticeCallback | NostrOkCallback | NostrClosedCallback | NostrAuthCallback;
export declare class Nostr {
    private relays;
    private privateKey?;
    private publicKey?;
    private relayOptions?;
    private eventCallbacks;
    private logger;
    private subscribeRateLimit;
    private publishRateLimit;
    private fetchRateLimit;
    private RATE_LIMITS;
    /**
     * Create a new Nostr client
     * @param relayUrls List of relay URLs to connect to
     * @param options Client options
     * @param options.relayOptions Options to pass to each Relay instance
     * @param options.rateLimits Rate limiting configuration for different operations
     */
    constructor(relayUrls?: string[], options?: NostrOptions);
    /**
     * Normalize a relay URL by lowercasing only the scheme and host,
     * while preserving the case of path, query, and fragment parts.
     * This is the correct behavior per URL standards.
     */
    private normalizeRelayUrl;
    /**
     * Preprocesses a relay URL before normalization and validation.
     * Adds wss:// prefix only to URLs without any scheme.
     * Throws an error for URLs with incompatible schemes.
     *
     * @param url - The input URL string to preprocess
     * @returns The preprocessed URL with appropriate scheme
     * @throws Error if URL has an incompatible scheme
     */
    private preprocessRelayUrl;
    private _createRelayEventHandler;
    addRelay(url: string): Relay;
    getRelay(url: string): Relay | undefined;
    removeRelay(url: string): void;
    connectToRelays(): Promise<void>;
    disconnectFromRelays(): void;
    setPrivateKey(privateKey: string): void;
    generateKeys(): Promise<{
        privateKey: string;
        publicKey: string;
    }>;
    getPublicKey(): string | undefined;
    /**
     * Get current rate limit configuration
     * @returns Current rate limit settings
     */
    getRateLimits(): NostrRateLimits;
    /**
     * Update rate limit configuration
     * @param rateLimits New rate limit settings (partial updates allowed)
     */
    updateRateLimits(rateLimits: NostrRateLimits): void;
    /**
     * Reset rate limit counters for all operations
     */
    resetRateLimits(): void;
    publishEvent(event: NostrEvent, options?: {
        timeout?: number;
    }): Promise<{
        success: boolean;
        event: NostrEvent | null;
        relayResults: Map<string, {
            success: boolean;
            reason?: string;
        }>;
    }>;
    publishTextNote(content: string, tags?: string[][], options?: {
        timeout?: number;
    }): Promise<NostrEvent | null>;
    publishDirectMessage(content: string, recipientPubkey: string, tags?: string[][], options?: {
        timeout?: number;
    }): Promise<NostrEvent | null>;
    /**
     * Decrypt a direct message received from another user
     *
     * Uses NIP-04 encryption which is the standard for kind:4 direct messages
     */
    decryptDirectMessage(event: NostrEvent): string;
    publishMetadata(metadata: Record<string, string | number | boolean | null | undefined>, options?: {
        timeout?: number;
    }): Promise<NostrEvent | null>;
    subscribe(filters: Filter[], onEvent: (event: NostrEvent, relay: string) => void, onEOSE?: () => void, options?: SubscriptionOptions): string[];
    unsubscribe(subscriptionIds: string[]): void;
    unsubscribeAll(): void;
    /**
     * Collect events matching the given filters from all connected relays.
     *
     * @param filters Array of filters to apply
     * @param options Optional max wait time in milliseconds (defaults to 5000ms if not provided)
     * @returns Promise resolving to all received events
     */
    fetchMany(filters: Filter[], options?: {
        maxWait?: number;
        signal?: AbortSignal;
    }): Promise<NostrEvent[]>;
    /**
     * Retrieve the newest single event matching the filters from all relays.
     *
     * @param filters Filters to apply (limit will be forced to 1)
     * @param options Optional max wait time in milliseconds and abort signal
     * @returns The newest matching event or null
     */
    fetchOne(filters: Filter[], options?: {
        maxWait?: number;
        signal?: AbortSignal;
    }): Promise<NostrEvent | null>;
    on(event: RelayEvent.Connect | RelayEvent.Disconnect, callback: (relay: string) => void): void;
    on(event: RelayEvent.Error, callback: (relay: string, error: unknown) => void): void;
    on(event: RelayEvent.Notice, callback: (relay: string, notice: string) => void): void;
    on(event: RelayEvent.OK, callback: (relay: string, eventId: string, success: boolean, details: ParsedOkReason) => void): void;
    on(event: RelayEvent.Closed, callback: (relay: string, subscriptionId: string, message: string) => void): void;
    on(event: RelayEvent.Auth, callback: (relay: string, challengeEvent: NostrEvent) => void): void;
    /**
     * Publish an event and get detailed results from all relays
     *
     * @param event The NostrEvent to publish
     * @param options Options including timeout
     * @returns Detailed publish results including success status and relay-specific information
     */
    publishWithDetails(event: NostrEvent, options?: {
        timeout?: number;
    }): Promise<{
        success: boolean;
        event: NostrEvent;
        relayResults: Map<string, {
            success: boolean;
            reason?: string;
        }>;
        successCount: number;
        failureCount: number;
    }>;
    /**
     * Get the latest replaceable event of a specific kind for a pubkey from all connected relays
     *
     * @param pubkey The public key of the user
     * @param kind The kind of event to retrieve (0, 3, or 10000-19999)
     * @returns The latest event or null if none exists
     */
    getLatestReplaceableEvent(pubkey: string, kind: number): NostrEvent | null;
    /**
     * Get the latest addressable event for a specific kind, pubkey, and d-tag value
     * from all connected relays
     *
     * @param kind The kind of event to retrieve (30000-39999)
     * @param pubkey The public key of the user
     * @param dTagValue The value of the d tag
     * @returns The latest event or null if none exists
     */
    getLatestAddressableEvent(kind: number, pubkey: string, dTagValue?: string): NostrEvent | null;
    /**
     * Get all addressable events for a specific pubkey from all connected relays
     *
     * @param pubkey The public key of the user
     * @returns Array of unique addressable events
     */
    getAddressableEventsByPubkey(pubkey: string): NostrEvent[];
    /**
     * Get all addressable events for a specific kind from all connected relays
     *
     * @param kind The kind of event to retrieve (30000-39999)
     * @returns Array of unique addressable events
     */
    getAddressableEventsByKind(kind: number): NostrEvent[];
}
