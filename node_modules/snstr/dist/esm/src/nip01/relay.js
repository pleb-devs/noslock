import { getWebSocketImplementation } from "../utils/websocket.js";
import { createInMemoryWebSocket } from "../utils/inMemoryWebSocket.js";
import { RelayEvent, NIP20Prefix, } from "../types/nostr.js";
import { NostrValidationError, getEventHash } from "./event.js";
import { getUnixTime } from "../utils/time.js";
import { verifySignature } from "../utils/crypto.js";
import { Logger, LogLevel } from "../nip46/utils/logger.js";
import { SECURITY_LIMITS, getSecureRandom, secureRandomHex, } from "../utils/security-validator.js";
const WS_READY_STATE = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3,
};
export class Relay {
    constructor(url, options = {}) {
        this.ws = null;
        this.connected = false;
        this.subscriptions = new Map();
        this.eventHandlers = {};
        this.connectionPromise = null;
        this.connectionTimeout = 10000; // Default timeout of 10 seconds
        // Event buffers with memory limits
        this.eventBuffers = new Map();
        this.eventBufferAccessTimes = new Map(); // For LRU eviction
        this.maxEventBuffers = SECURITY_LIMITS.MAX_RELAY_EVENT_BUFFERS;
        this.maxEventsPerBuffer = SECURITY_LIMITS.MAX_EVENTS_PER_BUFFER;
        this.bufferFlushInterval = null;
        this.bufferFlushDelay = 50; // ms to wait before flushing event buffer
        // Reconnection parameters
        this.reconnectAttempts = 0;
        this.reconnectTimer = null;
        this.autoReconnect = true; // Whether to automatically reconnect
        this.maxReconnectAttempts = 10; // Maximum number of reconnection attempts
        this.maxReconnectDelay = 30000; // Maximum delay between reconnect attempts (ms)
        // Track replaceable and addressable events according to NIP-01 with memory limits
        this.replaceableEvents = new Map();
        this.replaceableEventAccessTimes = new Map(); // For LRU eviction
        this.maxReplaceableEventPubkeys = SECURITY_LIMITS.MAX_REPLACEABLE_EVENT_PUBKEYS;
        this.maxReplaceableEventsPerPubkey = SECURITY_LIMITS.MAX_REPLACEABLE_EVENTS_PER_PUBKEY;
        this.addressableEvents = new Map();
        this.addressableEventAccessTimes = new Map(); // For LRU eviction
        this.maxAddressableEvents = SECURITY_LIMITS.MAX_ADDRESSABLE_EVENTS;
        this.pendingValidationCounts = new Map();
        this.pendingEoseSubscriptions = new Set();
        this.url = url;
        this.logger = new Logger({
            prefix: `Relay(${url})`,
            level: LogLevel.WARN, // Default to WARN level for production use
            includeTimestamp: false,
        });
        if (options.connectionTimeout !== undefined) {
            this.connectionTimeout = options.connectionTimeout;
        }
        if (options.bufferFlushDelay !== undefined) {
            this.bufferFlushDelay = options.bufferFlushDelay;
        }
        if (options.autoReconnect !== undefined) {
            this.autoReconnect = options.autoReconnect;
        }
        if (options.maxReconnectAttempts !== undefined) {
            this.maxReconnectAttempts = options.maxReconnectAttempts;
        }
        if (options.maxReconnectDelay !== undefined) {
            this.maxReconnectDelay = options.maxReconnectDelay;
        }
    }
    async connect() {
        if (this.connected)
            return true;
        if (this.connectionPromise)
            return this.connectionPromise;
        // Reset WebSocket if it exists already
        if (this.ws) {
            try {
                this.ws.close();
            }
            catch (e) {
                // Ignore close errors, the socket might already be in a closing state
            }
            this.ws = null;
        }
        // Create the connection promise
        const connectionPromise = new Promise((resolve, reject) => {
            try {
                const inMemorySocket = createInMemoryWebSocket(this.url);
                if (inMemorySocket) {
                    this.ws = inMemorySocket;
                }
                else {
                    const WS = getWebSocketImplementation();
                    this.ws = new WS(this.url);
                }
                const socket = this.ws;
                if (!socket) {
                    throw new Error("WebSocket implementation unavailable");
                }
                // Set up connection timeout
                const timeoutId = setTimeout(() => {
                    // Only run this if we haven't connected yet
                    if (this.ws && !this.connected) {
                        this.triggerEvent(RelayEvent.Error, this.url, new Error("connection timeout"));
                        try {
                            this.ws.close();
                        }
                        catch (e) {
                            // Ignore errors during force close
                        }
                        this.ws = null;
                        this.connectionPromise = null;
                        reject(new Error("connection timeout"));
                    }
                }, this.connectionTimeout);
                socket.onopen = () => {
                    clearTimeout(timeoutId);
                    this.connected = true;
                    this.resetReconnectAttempts(); // Reset reconnect counter on successful connection
                    this.setupBufferFlush(); // Set up the event buffer flush interval
                    this.triggerEvent(RelayEvent.Connect, this.url);
                    resolve(true);
                };
                socket.onclose = () => {
                    clearTimeout(timeoutId);
                    const wasConnected = this.connected;
                    this.connected = false;
                    this.clearBufferFlush(); // Clear the event buffer flush interval
                    this.triggerEvent(RelayEvent.Disconnect, this.url);
                    // Only reject the promise if we're still waiting to connect
                    if (!wasConnected && this.connectionPromise) {
                        this.connectionPromise = null;
                        reject(new Error("connection closed"));
                    }
                    // Schedule reconnection if auto-reconnect is enabled
                    if (this.autoReconnect && wasConnected) {
                        this.scheduleReconnect();
                    }
                };
                socket.onerror = (error) => {
                    clearTimeout(timeoutId);
                    this.triggerEvent(RelayEvent.Error, this.url, error);
                    // Only reject the promise if we haven't connected yet
                    if (!this.connected && this.connectionPromise) {
                        this.connectionPromise = null;
                        reject(error instanceof Error ? error : new Error("websocket error"));
                    }
                };
                socket.onmessage = (message) => {
                    try {
                        const data = JSON.parse(message.data);
                        this.handleMessage(data);
                    }
                    catch (error) {
                        this.triggerEvent(RelayEvent.Error, this.url, error);
                    }
                };
            }
            catch (error) {
                // Handle errors during WebSocket creation
                this.connectionPromise = null;
                reject(error);
            }
        }).catch((_error) => {
            // Ensure we return false if connection fails but don't re-throw
            this.logger.error(`Connection failed:`, _error);
            // Schedule reconnection if auto-reconnect is enabled
            if (this.autoReconnect) {
                this.scheduleReconnect();
            }
            return false; // Explicit type assertion
        });
        // Store the promise for future connect() calls to return
        this.connectionPromise = connectionPromise;
        // Create a separate promise chain to handle cleanup
        // This ensures the original promise is not modified
        connectionPromise.then(() => {
            // Only clean up if this is still the active connection promise
            if (this.connectionPromise === connectionPromise) {
                this.connectionPromise = null;
            }
        }, () => {
            // Also clean up on rejection
            if (this.connectionPromise === connectionPromise) {
                this.connectionPromise = null;
            }
        });
        return this.connectionPromise;
    }
    disconnect() {
        // Cancel any scheduled reconnection
        this.cancelReconnect();
        if (!this.ws)
            return;
        try {
            // Clear all subscriptions to prevent further processing
            this.subscriptions.clear();
            // Clear event buffers and access times
            this.eventBuffers.clear();
            this.eventBufferAccessTimes.clear();
            // Clear replaceable event storage and access times
            this.replaceableEvents.clear();
            this.replaceableEventAccessTimes.clear();
            // Clear addressable event storage and access times
            this.addressableEvents.clear();
            this.addressableEventAccessTimes.clear();
            this.clearBufferFlush(); // Clear the buffer flush interval
            // Close the WebSocket if it's open or connecting
            if (this.ws &&
                (this.ws.readyState === WS_READY_STATE.OPEN ||
                    this.ws.readyState === WS_READY_STATE.CONNECTING)) {
                // First try to send CLOSE messages for any active subscriptions
                try {
                    this.ws.close();
                }
                catch (e) {
                    // Ignore close errors, the connection might already be closed or invalid
                }
                // Reset the connection promise if it exists
                this.connectionPromise = null;
            }
        }
        catch (error) {
            console.error(`Error closing WebSocket for ${this.url}:`, error);
        }
        finally {
            // Reset all state variables
            this.ws = null;
            this.connected = false;
            this.triggerEvent(RelayEvent.Disconnect, this.url);
        }
    }
    /**
     * Schedule a reconnection attempt with exponential backoff
     */
    scheduleReconnect() {
        // Cancel any existing reconnect timer
        this.cancelReconnect();
        // Check if we've reached the maximum number of reconnect attempts
        if (this.maxReconnectAttempts > 0 &&
            this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.warn(`Maximum reconnection attempts (${this.maxReconnectAttempts}) reached for ${this.url}`);
            return;
        }
        // Calculate delay with exponential backoff and jitter
        const baseDelay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), this.maxReconnectDelay);
        // Use secure random for reconnection timing (prevent timing attacks)
        let secureJitter;
        try {
            secureJitter = getSecureRandom();
        }
        catch (error) {
            // Fallback to Math.random() for non-critical reconnection timing if secure random is unavailable
            secureJitter = Math.random();
        }
        const jitter = secureJitter * 0.3 * baseDelay; // Add 0-30% jitter
        const reconnectDelay = baseDelay + jitter;
        this.reconnectTimer = setTimeout(() => {
            this.reconnectAttempts++;
            this.connect().catch((error) => {
                console.error(`Reconnection attempt ${this.reconnectAttempts} failed for ${this.url}:`, error);
                // The next reconnection will be scheduled in the connect() method's catch handler
            });
        }, reconnectDelay);
    }
    /**
     * Cancel any scheduled reconnection attempt
     */
    cancelReconnect() {
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }
    }
    /**
     * Reset the reconnection attempt counter
     */
    resetReconnectAttempts() {
        this.reconnectAttempts = 0;
        this.cancelReconnect();
    }
    /**
     * Enable or disable automatic reconnection
     */
    setAutoReconnect(enable) {
        this.autoReconnect = enable;
        // If disabling, cancel any pending reconnect
        if (!enable) {
            this.cancelReconnect();
        }
    }
    /**
     * Set the maximum number of reconnection attempts
     * @param max Maximum number of attempts (0 for unlimited)
     */
    setMaxReconnectAttempts(max) {
        if (max < 0) {
            throw new Error("Maximum reconnect attempts must be a non-negative number");
        }
        this.maxReconnectAttempts = max;
    }
    /**
     * Set the maximum delay between reconnection attempts
     * @param maxDelayMs Maximum delay in milliseconds
     */
    setMaxReconnectDelay(maxDelayMs) {
        if (maxDelayMs < 1000) {
            throw new Error("Maximum reconnect delay must be at least 1000ms");
        }
        this.maxReconnectDelay = maxDelayMs;
    }
    on(event, callback) {
        if (typeof callback !== "function")
            return;
        const existingCallbacks = this.eventHandlers[event];
        if (!existingCallbacks) {
            // If no array exists for this event type, create one with the new callback
            this.eventHandlers[event] = [callback];
        }
        else {
            // existingCallbacks is already correctly typed as RelayEventCallbacks[E][] | undefined by the corrected RelayEventHandler
            if (!existingCallbacks.includes(callback)) {
                existingCallbacks.push(callback);
            }
        }
    }
    off(event, callback) {
        if (typeof callback !== "function")
            return;
        const handlerOrArray = this.eventHandlers[event];
        if (!handlerOrArray) {
            // If undefined, no handlers registered for this event.
            return;
        }
        // First, check if the stored entry is a single function (user's identified scenario for robustness)
        // Note: Types suggest handlerOrArray should be an array if defined (RelayEventCallbacks[E][]).
        // This check handles potential state where it might erroneously be a single function.
        if (typeof handlerOrArray === "function") {
            if (handlerOrArray === callback) {
                delete this.eventHandlers[event];
            }
        }
        // Else, if it's an array (the expected scenario based on types and `on` method)
        else if (Array.isArray(handlerOrArray)) {
            const callbacksArray = handlerOrArray; // Can also rename to handlerOrArray if preferred
            const index = callbacksArray.indexOf(callback);
            if (index > -1) {
                callbacksArray.splice(index, 1);
            }
            if (callbacksArray.length === 0) {
                delete this.eventHandlers[event];
            }
        }
        // If handlerOrArray is defined but is neither a function nor an array (e.g., other object types),
        // this would be a highly unexpected state. Current behavior is to do nothing, which is safe.
    }
    async publish(event, options = {}) {
        if (!this.connected) {
            try {
                const connected = await this.connect();
                if (!connected) {
                    return {
                        success: false,
                        reason: "connection_failed",
                        relay: this.url,
                    };
                }
            }
            catch (error) {
                const errorMsg = error instanceof Error ? error.message : "unknown error";
                return {
                    success: false,
                    reason: `connection_error: ${errorMsg}`,
                    relay: this.url,
                };
            }
        }
        if (!this.connected ||
            !this.ws ||
            this.ws.readyState !== WS_READY_STATE.OPEN) {
            return { success: false, reason: "not_connected", relay: this.url };
        }
        try {
            // First send the event
            const message = JSON.stringify(["EVENT", event]);
            this.ws.send(message);
            // If we don't need to wait for acknowledgment, return immediately
            if (options.waitForAck === false) {
                return { success: true, relay: this.url };
            }
            // Return a Promise that will resolve when we get the OK response for this event
            return new Promise((resolve) => {
                const timeout = options.timeout ?? 10000;
                let timeoutId = setTimeout(() => {
                    cleanup();
                    resolve({ success: false, reason: "timeout", relay: this.url });
                }, timeout);
                // Create unique handler function for this specific publish operation
                const handleOk = (eventId, success, details) => {
                    if (eventId === event.id) {
                        cleanup();
                        resolve({
                            success,
                            reason: details.rawMessage,
                            parsedReason: details,
                            relay: this.url,
                        });
                    }
                };
                // Setup error handler in case of WebSocket errors during publishing
                const handleError = (_, error) => {
                    cleanup();
                    const errorMsg = error instanceof Error ? error.message : "unknown error";
                    resolve({
                        success: false,
                        reason: `error: ${errorMsg}`,
                        relay: this.url,
                    });
                };
                // Setup disconnect handler in case connection drops during wait
                const handleDisconnect = () => {
                    cleanup();
                    resolve({ success: false, reason: "disconnected", relay: this.url });
                };
                // Helper to clean up all handlers and timeout
                const cleanup = () => {
                    this.off(RelayEvent.OK, handleOk);
                    this.off(RelayEvent.Error, handleError);
                    this.off(RelayEvent.Disconnect, handleDisconnect);
                    clearTimeout(timeoutId);
                };
                // Register the event handlers
                this.on(RelayEvent.OK, handleOk);
                this.on(RelayEvent.Error, handleError);
                this.on(RelayEvent.Disconnect, handleDisconnect);
                // Set timeout to avoid hanging indefinitely
                timeoutId = setTimeout(() => {
                    cleanup();
                    resolve({ success: false, reason: "timeout", relay: this.url });
                }, timeout);
            });
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : "unknown error";
            console.error(`Error publishing event to ${this.url}:`, errorMessage);
            return {
                success: false,
                reason: `error: ${errorMessage}`,
                relay: this.url,
            };
        }
    }
    subscribe(filters, onEvent, onEOSE, options = {}) {
        // Generate cryptographically secure subscription ID
        const id = secureRandomHex(16);
        // Validate filters before proceeding
        const fieldsToValidate = ["ids", "authors", "#e", "#p"];
        for (const filter of filters) {
            for (const field of fieldsToValidate) {
                const values = filter[field]; // Type assertion needed as Filter has [key: string]: unknown
                if (Array.isArray(values)) {
                    for (const item of values) {
                        if (!this._isValidNip01FilterIdentifier(item)) {
                            const fieldName = field;
                            throw new NostrValidationError(`Invalid NIP-01 filter value for '${fieldName}': item '${item}' is not a 64-character lowercase hex string.`, fieldName, filter);
                        }
                    }
                }
            }
        }
        const subscription = {
            id,
            filters,
            onEvent,
            onEOSE,
            options,
        };
        if (options.autoClose && options.eoseTimeout && options.eoseTimeout > 0) {
            subscription.eoseTimer = setTimeout(() => {
                this.unsubscribe(id);
            }, options.eoseTimeout);
        }
        this.subscriptions.set(id, subscription);
        this.eventBuffers.set(id, []); // Initialize an empty event buffer for this subscription
        if (this.connected && this.ws) {
            const message = JSON.stringify(["REQ", id, ...filters]);
            this.ws.send(message);
        }
        return id;
    }
    unsubscribe(id) {
        const subscription = this.subscriptions.get(id);
        if (!subscription)
            return;
        if (subscription.eoseTimer) {
            clearTimeout(subscription.eoseTimer);
        }
        this.subscriptions.delete(id);
        this.eventBuffers.delete(id); // Clean up the event buffer for this subscription
        this.eventBufferAccessTimes.delete(id); // Clean up the access time tracking
        this.pendingEoseSubscriptions.delete(id);
        this.pendingValidationCounts.delete(id);
        if (this.connected && this.ws) {
            const message = JSON.stringify(["CLOSE", id]);
            this.ws.send(message);
        }
    }
    handleMessage(data) {
        if (!Array.isArray(data))
            return;
        const [type, ...rest] = data;
        switch (type) {
            case "EVENT": {
                const [subscriptionId, event] = rest;
                if (typeof subscriptionId !== "string") {
                    this.triggerEvent(RelayEvent.Error, this.url, new Error("Invalid subscription identifier in EVENT message"));
                    break;
                }
                this.incrementPendingValidation(subscriptionId);
                // Type guard to ensure event is a NostrEvent
                if (!this.isNostrEvent(event)) {
                    this.decrementPendingValidation(subscriptionId);
                    this.triggerEvent(RelayEvent.Error, this.url, new Error(`Invalid event structure: ${JSON.stringify(event)}`));
                    break;
                }
                // Perform initial synchronous validation
                if (!this.performBasicValidation(event)) {
                    this.triggerEvent(RelayEvent.Error, this.url, new Error(`Invalid event: ${event.id}`));
                    this.decrementPendingValidation(subscriptionId);
                    break;
                }
                // Launch async validation and handle the event only if validation passes
                this.validateEventAsync(event)
                    .then((isValid) => {
                    if (isValid) {
                        this.processValidatedEvent(event, subscriptionId);
                    }
                    else {
                        this.triggerEvent(RelayEvent.Error, this.url, new Error(`Async validation failed for event: ${event.id}`));
                    }
                })
                    .catch((error) => {
                    this.triggerEvent(RelayEvent.Error, this.url, new Error(`Validation error: ${error instanceof Error ? error.message : "unknown error"}`));
                })
                    .finally(() => {
                    this.decrementPendingValidation(subscriptionId);
                });
                break;
            }
            case "EOSE": {
                const [subscriptionId] = rest;
                // Flush the buffer for this subscription immediately on EOSE
                if (typeof subscriptionId === "string") {
                    this.markEosePending(subscriptionId);
                }
                break;
            }
            case "NOTICE": {
                const [notice] = rest;
                // Ensure notice is a string
                const noticeStr = typeof notice === "string" ? notice : String(notice || "");
                this.triggerEvent(RelayEvent.Notice, this.url, noticeStr);
                break;
            }
            case "OK": {
                const [eventId, success, rawMessageUntyped] = rest;
                // Ensure all params are of the correct type
                const eventIdStr = typeof eventId === "string" ? eventId : String(eventId || "");
                const successBool = Boolean(success);
                // Parse the raw message for NIP-20 prefixes
                const rawMessageStr = typeof rawMessageUntyped === "string" ? rawMessageUntyped : undefined;
                const parsedDetails = this.parseOkMessage(rawMessageStr);
                this.triggerEvent(RelayEvent.OK, eventIdStr, successBool, parsedDetails);
                break;
            }
            case "CLOSED": {
                const [subscriptionId, message] = rest;
                // Ensure both params are strings
                const subIdStr = typeof subscriptionId === "string"
                    ? subscriptionId
                    : String(subscriptionId || "");
                const messageStr = typeof message === "string" ? message : String(message || "");
                this.triggerEvent(RelayEvent.Closed, subIdStr, messageStr);
                // Remove the subscription from our map since the relay closed it
                if (typeof subscriptionId === "string") {
                    this.subscriptions.delete(subscriptionId);
                }
                break;
            }
            case "AUTH": {
                const [challengeEvent] = rest;
                // Check if the challenge is a proper NostrEvent
                if (this.isNostrEvent(challengeEvent)) {
                    this.triggerEvent(RelayEvent.Auth, challengeEvent);
                }
                else {
                    // If it's not a proper event, log an error
                    this.triggerEvent(RelayEvent.Error, this.url, new Error(`Invalid AUTH challenge: ${JSON.stringify(challengeEvent)}`));
                }
                break;
            }
            default:
                // Unknown message type, ignore or log
                console.warn(`Relay(${this.url}): Unknown message type:`, type, rest);
                break;
        }
    }
    /**
     * Process a validated event - called only after both basic and async validation
     */
    processValidatedEvent(event, subscriptionId) {
        // Process replaceable events (kinds 0, 3, 10000-19999)
        if (event.kind === 0 ||
            event.kind === 3 ||
            (event.kind >= 10000 && event.kind < 20000)) {
            this.processReplaceableEvent(event);
        }
        // Process addressable events (kinds 30000-39999) - using else to make them mutually exclusive
        else if (event.kind >= 30000 && event.kind < 40000) {
            this.processAddressableEvent(event);
        }
        const subscription = this.subscriptions.get(subscriptionId);
        if (subscription) {
            // Use the proper buffer management method that enforces memory limits and LRU eviction
            this.addToEventBuffer(subscriptionId, event);
            this.maybeFinalizeEOSE(subscriptionId);
        }
    }
    // Helper function to check if a string is a valid hex string of a specific length
    isHexString(value, length) {
        if (typeof value !== "string") {
            return false;
        }
        if (!/^[0-9a-fA-F]+$/.test(value)) {
            return false;
        }
        if (length !== undefined && value.length !== length) {
            return false;
        }
        return true;
    }
    /**
     * Perform basic synchronous validation of an event
     *
     * This checks:
     * 1. Required fields are present with correct types
     * 2. Fields have valid formats (lengths, structure)
     * 3. Timestamps are reasonable
     */
    performBasicValidation(event) {
        // Skip validation if event is not a NostrEvent
        if (!this.isNostrEvent(event)) {
            return false;
        }
        try {
            // Now we can safely access event properties
            // Check that all required fields are present and have the correct types
            if (!this.isHexString(event.id, 64)) {
                return false;
            }
            if (!this.isHexString(event.pubkey, 64)) {
                return false;
            }
            if (event.kind < 0 || event.kind > 65535) {
                return false;
            }
            // Validate tag structure
            for (const tag of event.tags) {
                if (!Array.isArray(tag) || tag.length === 0) {
                    // Ensure tag is a non-empty array
                    return false;
                }
                // All tag items must be strings according to NIP-01
                for (const item of tag) {
                    if (typeof item !== "string") {
                        return false;
                    }
                }
                // Specific NIP-01 tag parameter validation
                const tagName = tag[0];
                if (tagName === "e" || tagName === "p") {
                    // For 'e' (event ID) and 'p' (pubkey) tags, the second element must be a 64-char hex string
                    // NIP-01: ["e", <event-id-hex>, <optional-relay-url-string>]
                    // NIP-01: ["p", <pubkey-hex>, <optional-relay-url-string>]
                    if (tag.length < 2 || !this.isHexString(tag[1], 64)) {
                        return false;
                    }
                }
                else if (tagName === "a") {
                    // For 'a' tags, validate the <kind>:<pubkey>:<d-identifier> structure
                    // NIP-01: ["a", "<kind>:<pubkey>:<d-identifier>", <optional-relay-url>]
                    if (tag.length < 2 || typeof tag[1] !== "string") {
                        return false; // Must have at least name and value, value must be a string
                    }
                    const valueParts = tag[1].split(":");
                    if (valueParts.length !== 3) {
                        // This structure must contain exactly three parts: kind, pubkey, and d-tag value (which can be empty).
                        // e.g., "30023:pubkeyhex:identifier" or "10002:pubkeyhex:"
                        return false;
                    }
                    const kindStr = valueParts[0];
                    const pubkeyStr = valueParts[1];
                    // const dValueStr = valueParts[2]; // dValueStr is implicitly validated as a string by split
                    // Validate kind (must be a non-negative integer string)
                    const kindNum = parseInt(kindStr, 10);
                    if (isNaN(kindNum) ||
                        !Number.isInteger(kindNum) ||
                        kindNum < 0 || // Kinds must be non-negative
                        String(kindNum) !== kindStr // Ensures no trailing characters, e.g., "123xyz"
                    ) {
                        return false;
                    }
                    // Validate pubkey (must be 64-char hex)
                    if (!this.isHexString(pubkeyStr, 64)) {
                        return false;
                    }
                    // dValueStr (valueParts[2]) is a string by virtue of the split.
                    // NIP-01 doesn't impose further generic constraints on its content for the 'a' tag structure itself.
                }
                // Other tag types might have different validation rules, not covered by this specific claim.
            }
            if (!this.isHexString(event.sig, 128)) {
                return false;
            }
            // Check reasonable timestamp (not more than 1 hour in the future and not too far in the past)
            const now = getUnixTime();
            if (event.created_at > now + 3600) {
                return false; // Reject events with future timestamps
            }
            // Special handling for NIP-46 events (kind 24133)
            if (event.kind === 24133) {
                // NIP-46 events require at least one 'p' tag.
                // The format of such a 'p' tag (tag[0]==='p', tag.length >= 2, and tag[1] is 64-char hex)
                // would have already been validated by the general tag loop above.
                // Here, we just ensure at least one such 'p' tag exists.
                const hasValidPTagForNIP46 = event.tags.some((tag) => tag.length >= 2 && tag[0] === "p");
                if (!hasValidPTagForNIP46) {
                    // Optionally log here if needed
                    return false;
                }
            }
            // Optionally log a warning for very old events (e.g., older than a year)
            if (event.created_at < now - 31536000) {
                // Optionally log here if needed
            }
            return true;
        }
        catch (error) {
            // If any validation throws an exception, reject the event
            return false;
        }
    }
    /**
     * Validate an event (deprecated - use async validation directly)
     * Maintained for backward compatibility with existing code
     */
    validateEvent(event) {
        if (!this.isNostrEvent(event)) {
            return false;
        }
        if (!this.performBasicValidation(event)) {
            return false;
        }
        // For NIP-46 encrypted events, we can skip async validation since
        // their content can only be verified after decryption
        if (event.kind === 24133) {
            return true;
        }
        // For all other events, indicate that basic validation passed, but defer
        // to async validation before actually accepting the event
        return true;
    }
    /**
     * Perform async validations on an event
     *
     * This includes:
     * 1. Verifying the event ID matches the hash of serialized data
     * 2. Verifying the signature is valid
     *
     * These operations are computationally expensive, so they're performed
     * asynchronously to avoid blocking the main thread.
     */
    async validateEventAsync(event) {
        try {
            // Extract the data needed for ID verification (excluding id and sig)
            const eventData = {
                pubkey: event.pubkey,
                created_at: event.created_at,
                kind: event.kind,
                tags: event.tags,
                content: event.content,
            };
            // Step 1: Validate event ID by comparing with calculated hash
            const calculatedId = await getEventHash(eventData);
            if (calculatedId !== event.id) {
                return false;
            }
            // Step 2: Validate signature
            return await verifySignature(event.id, event.sig, event.pubkey);
        }
        catch (error) {
            // Log error details if in debug mode
            const debug = process.env.DEBUG?.includes("nostr:*") || false;
            if (debug) {
                console.error(`Relay(${this.url}): Event validation error:`, error);
            }
            return false;
        }
    }
    triggerEvent(event, ...args) {
        const callbacks = this.eventHandlers[event];
        if (callbacks && Array.isArray(callbacks)) {
            callbacks.forEach((callback) => {
                if (typeof callback === "function") {
                    try {
                        // Directly call the callback with the spread arguments.
                        // The type assertion in Relay.on ensures the callback matches the event.
                        callback(...args);
                    }
                    catch (e) {
                        console.error(`Relay(${this.url}): Error in ${event} callback:`, e);
                    }
                }
            });
        }
    }
    /**
     * Set connection timeout in milliseconds
     * @param timeout Timeout in milliseconds
     */
    setConnectionTimeout(timeout) {
        if (timeout < 0) {
            throw new Error("Connection timeout must be a positive number");
        }
        this.connectionTimeout = timeout;
    }
    /**
     * Get the current connection timeout in milliseconds
     */
    getConnectionTimeout() {
        return this.connectionTimeout;
    }
    /**
     * Get all subscription IDs for this relay
     * @returns A Set containing all active subscription IDs
     */
    getSubscriptionIds() {
        return new Set(this.subscriptions.keys());
    }
    /**
     * Get the current buffer flush delay in milliseconds
     */
    getBufferFlushDelay() {
        return this.bufferFlushDelay;
    }
    /**
     * Set up the interval to flush event buffers
     */
    setupBufferFlush() {
        // Clear any existing interval just in case
        this.clearBufferFlush();
        // Set up a new interval to flush event buffers periodically
        this.bufferFlushInterval = setInterval(() => {
            this.flushAllBuffers();
        }, this.bufferFlushDelay);
    }
    /**
     * Clear the buffer flush interval
     */
    clearBufferFlush() {
        if (this.bufferFlushInterval) {
            clearInterval(this.bufferFlushInterval);
            this.bufferFlushInterval = null;
        }
    }
    /**
     * Flush all event buffers for all subscriptions
     */
    flushAllBuffers() {
        for (const subscriptionId of this.eventBuffers.keys()) {
            this.flushSubscriptionBuffer(subscriptionId);
        }
    }
    incrementPendingValidation(subscriptionId) {
        const current = this.pendingValidationCounts.get(subscriptionId) ?? 0;
        this.pendingValidationCounts.set(subscriptionId, current + 1);
    }
    decrementPendingValidation(subscriptionId) {
        const current = this.pendingValidationCounts.get(subscriptionId) ?? 0;
        const next = Math.max(current - 1, 0);
        if (next === 0) {
            this.pendingValidationCounts.delete(subscriptionId);
            if (!this.pendingEoseSubscriptions.has(subscriptionId)) {
                this.flushSubscriptionBuffer(subscriptionId);
            }
        }
        else {
            this.pendingValidationCounts.set(subscriptionId, next);
        }
        this.maybeFinalizeEOSE(subscriptionId);
    }
    markEosePending(subscriptionId) {
        this.pendingEoseSubscriptions.add(subscriptionId);
        this.maybeFinalizeEOSE(subscriptionId);
    }
    maybeFinalizeEOSE(subscriptionId) {
        if (!this.pendingEoseSubscriptions.has(subscriptionId)) {
            return;
        }
        const pending = this.pendingValidationCounts.get(subscriptionId) ?? 0;
        if (pending > 0) {
            return;
        }
        this.flushSubscriptionBuffer(subscriptionId);
        const subscription = this.subscriptions.get(subscriptionId);
        if (subscription) {
            if (subscription.onEOSE) {
                subscription.onEOSE();
            }
            if (subscription.options?.autoClose) {
                this.unsubscribe(subscriptionId);
            }
        }
        this.pendingEoseSubscriptions.delete(subscriptionId);
    }
    /**
     * Flush the event buffer for a specific subscription
     */
    flushSubscriptionBuffer(subscriptionId) {
        const buffer = this.eventBuffers.get(subscriptionId);
        if (!buffer || buffer.length === 0)
            return;
        const subscription = this.subscriptions.get(subscriptionId);
        if (!subscription) {
            // If the subscription has been removed, clear the buffer
            this.eventBuffers.delete(subscriptionId);
            return;
        }
        // Sort the events according to NIP-01: newest first, then by lexical order of ID if same timestamp
        const sortedEvents = this.sortEvents(buffer);
        // Remove the buffer from the map instead of keeping an empty array
        this.eventBuffers.delete(subscriptionId);
        this.eventBufferAccessTimes.delete(subscriptionId);
        // Process all events
        for (const event of sortedEvents) {
            try {
                subscription.onEvent(event);
            }
            catch (error) {
                console.error(`Error in subscription handler for ${subscriptionId}:`, error);
            }
        }
    }
    /**
     * Sort events according to NIP-01 specification:
     * 1. created_at timestamp (descending - newer events first)
     * 2. event id (lexical ascending) if timestamps are the same
     */
    sortEvents(events) {
        return [...events].sort((a, b) => {
            // Sort by created_at (descending - newer events first)
            if (a.created_at !== b.created_at) {
                return b.created_at - a.created_at;
            }
            // If created_at is the same, sort by id (ascending lexical order)
            // This ensures lower IDs win when timestamps match, consistent with NIP-01 replaceable/addressable events.
            return a.id.localeCompare(b.id);
        });
    }
    // Add event to buffer with memory limits
    addToEventBuffer(subscriptionId, event) {
        // Update access time for LRU
        this.eventBufferAccessTimes.set(subscriptionId, Date.now());
        // Ensure we don't exceed max number of buffers
        if (!this.eventBuffers.has(subscriptionId) &&
            this.eventBuffers.size >= this.maxEventBuffers) {
            this.evictOldestEventBuffer();
        }
        // Get or create buffer
        if (!this.eventBuffers.has(subscriptionId)) {
            this.eventBuffers.set(subscriptionId, []);
        }
        const buffer = this.eventBuffers.get(subscriptionId);
        // Ensure we don't exceed max events per buffer
        if (buffer.length >= this.maxEventsPerBuffer) {
            buffer.shift(); // Remove oldest event
        }
        buffer.push(event);
    }
    // Evict oldest accessed event buffer
    evictOldestEventBuffer() {
        let oldestTime = Infinity;
        let oldestId = "";
        for (const [id, time] of this.eventBufferAccessTimes) {
            if (time < oldestTime) {
                oldestTime = time;
                oldestId = id;
            }
        }
        if (oldestId) {
            this.eventBuffers.delete(oldestId);
            this.eventBufferAccessTimes.delete(oldestId);
            this.logger.debug(`Evicted event buffer for subscription: ${oldestId}`);
        }
    }
    // Process replaceable event with memory limits
    processReplaceableEvent(event) {
        const pubkey = event.pubkey;
        // Update access time for LRU
        this.replaceableEventAccessTimes.set(pubkey, Date.now());
        // Ensure we don't exceed max pubkeys
        if (!this.replaceableEvents.has(pubkey) &&
            this.replaceableEvents.size >= this.maxReplaceableEventPubkeys) {
            this.evictOldestReplaceablePubkey();
        }
        // Get or create pubkey map
        if (!this.replaceableEvents.has(pubkey)) {
            this.replaceableEvents.set(pubkey, new Map());
        }
        const kindMap = this.replaceableEvents.get(pubkey);
        const existingEvent = kindMap.get(event.kind);
        // Only store if newer or first of this kind
        if (!existingEvent || event.created_at > existingEvent.created_at) {
            // Ensure we don't exceed max events per pubkey
            if (kindMap.size >= this.maxReplaceableEventsPerPubkey &&
                !kindMap.has(event.kind)) {
                // Remove oldest event by created_at
                let oldestKind = -1;
                let oldestTime = Infinity;
                for (const [kind, evt] of kindMap) {
                    if (evt.created_at < oldestTime) {
                        oldestTime = evt.created_at;
                        oldestKind = kind;
                    }
                }
                if (oldestKind !== -1) {
                    kindMap.delete(oldestKind);
                    this.logger.debug(`Evicted replaceable event kind ${oldestKind} for pubkey: ${pubkey}`);
                }
            }
            kindMap.set(event.kind, event);
        }
    }
    // Evict oldest accessed replaceable event pubkey
    evictOldestReplaceablePubkey() {
        let oldestTime = Infinity;
        let oldestPubkey = "";
        for (const [pubkey, time] of this.replaceableEventAccessTimes) {
            if (time < oldestTime) {
                oldestTime = time;
                oldestPubkey = pubkey;
            }
        }
        if (oldestPubkey) {
            this.replaceableEvents.delete(oldestPubkey);
            this.replaceableEventAccessTimes.delete(oldestPubkey);
            this.logger.debug(`Evicted replaceable events for pubkey: ${oldestPubkey}`);
        }
    }
    // Process addressable event with memory limits
    processAddressableEvent(event) {
        const dTag = event.tags.find((tag) => tag[0] === "d");
        const dValue = dTag ? dTag[1] : "";
        const addressId = `${event.kind}:${event.pubkey}:${dValue}`;
        // Update access time for LRU
        this.addressableEventAccessTimes.set(addressId, Date.now());
        // Ensure we don't exceed max addressable events
        if (!this.addressableEvents.has(addressId) &&
            this.addressableEvents.size >= this.maxAddressableEvents) {
            this.evictOldestAddressableEvent();
        }
        const existingEvent = this.addressableEvents.get(addressId);
        // Only store if newer, first, or tie-breaker with smaller ID
        if (!existingEvent ||
            event.created_at > existingEvent.created_at ||
            (event.created_at === existingEvent.created_at &&
                event.id < existingEvent.id)) {
            this.addressableEvents.set(addressId, event);
        }
    }
    // Evict oldest accessed addressable event
    evictOldestAddressableEvent() {
        let oldestTime = Infinity;
        let oldestId = "";
        for (const [id, time] of this.addressableEventAccessTimes) {
            if (time < oldestTime) {
                oldestTime = time;
                oldestId = id;
            }
        }
        if (oldestId) {
            this.addressableEvents.delete(oldestId);
            this.addressableEventAccessTimes.delete(oldestId);
            this.logger.debug(`Evicted addressable event: ${oldestId}`);
        }
    }
    // Update getLatestReplaceableEvent to use access tracking
    getLatestReplaceableEvent(pubkey, kind) {
        // Update access time
        this.replaceableEventAccessTimes.set(pubkey, Date.now());
        const kindMap = this.replaceableEvents.get(pubkey);
        return kindMap?.get(kind);
    }
    // Update getLatestAddressableEvent to use access tracking
    getLatestAddressableEvent(kind, pubkey, dTagValue = "") {
        const addressId = `${kind}:${pubkey}:${dTagValue}`;
        // Update access time
        this.addressableEventAccessTimes.set(addressId, Date.now());
        return this.addressableEvents.get(addressId);
    }
    /**
     * Get all addressable events for a specific pubkey
     *
     * @param pubkey The public key of the user
     * @returns Array of addressable events
     */
    getAddressableEventsByPubkey(pubkey) {
        return Array.from(this.addressableEvents.values()).filter((event) => event.pubkey === pubkey);
    }
    /**
     * Get all addressable events for a specific kind
     *
     * @param kind The kind of event to retrieve (30000-39999)
     * @returns Array of addressable events
     */
    getAddressableEventsByKind(kind) {
        return Array.from(this.addressableEvents.values()).filter((event) => event.kind === kind);
    }
    // Helper function to parse NIP-20 prefixes from OK messages
    parseOkMessage(rawMessage) {
        const result = {
            rawMessage: rawMessage || "",
            message: rawMessage || "", // Default to full message if no prefix
        };
        if (rawMessage) {
            for (const nipPrefix of Object.values(NIP20Prefix)) {
                if (rawMessage.startsWith(nipPrefix)) {
                    result.prefix = nipPrefix;
                    result.message = rawMessage.substring(nipPrefix.length).trimStart();
                    break;
                }
            }
        }
        return result;
    }
    // Add this helper method to type guard for NostrEvent
    isNostrEvent(event) {
        if (!event || typeof event !== "object")
            return false;
        const e = event;
        return (typeof e.id === "string" &&
            typeof e.pubkey === "string" &&
            typeof e.created_at === "number" &&
            typeof e.kind === "number" &&
            Array.isArray(e.tags) &&
            typeof e.content === "string" &&
            typeof e.sig === "string");
    }
    // New private helper method for validating NIP-01 filter identifiers
    _isValidNip01FilterIdentifier(value) {
        if (typeof value !== "string") {
            return false;
        }
        // Must be 64 characters, lowercase hex
        return /^[0-9a-f]{64}$/.test(value);
    }
}
