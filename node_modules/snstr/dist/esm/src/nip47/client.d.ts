import { Nostr } from "../nip01/nostr";
import { NIP47ConnectionOptions, NIP47Notification, TransactionType, NIP47ErrorCode, GetInfoResponse, PayInvoiceResponse, MakeInvoiceResponse, NIP47Error, NIP47ErrorCategory, NIP47Transaction, ListTransactionsResponseResult, SignMessageResponseResult } from "./types";
/**
 * Parse a NWC URL into connection options
 */
export declare function parseNWCURL(url: string): NIP47ConnectionOptions;
/**
 * Generate a NWC URL from connection options
 */
export declare function generateNWCURL(options: NIP47ConnectionOptions): string;
/**
 * Retry configuration
 */
export interface RetryOptions {
    maxRetries: number;
    initialDelay: number;
    maxDelay: number;
    factor: number;
}
export declare class NIP47ClientError extends Error {
    code: NIP47ErrorCode;
    category: NIP47ErrorCategory;
    recoveryHint?: string;
    data?: Record<string, unknown>;
    constructor(message: string, code: NIP47ErrorCode, data?: Record<string, unknown>);
    /**
     * Creates an error instance from a NIP47Error response
     */
    static fromResponseError(error: NIP47Error): NIP47ClientError;
    /**
     * Check if the error is a network-related error
     */
    isNetworkError(): boolean;
    /**
     * Check if the error is a timeout
     */
    isTimeoutError(): boolean;
    /**
     * Check if the error is authorization-related
     */
    isAuthorizationError(): boolean;
    /**
     * Check if retry is recommended for this error
     */
    isRetriable(): boolean;
    /**
     * Get user-friendly error message including recovery hint
     */
    getUserMessage(): string;
}
/**
 * Nostr Wallet Connect client implementation
 *
 * This class provides an API for applications to connect to a NIP-47 compatible
 * wallet service over Nostr.
 */
export declare class NostrWalletConnectClient {
    private pubkey;
    private clientPrivkey;
    private clientPubkey;
    private relays;
    private client;
    private supportedMethods;
    private supportedNotifications;
    private supportedEncryption;
    private preferredEncryption;
    private notificationHandlers;
    private pendingRequests;
    private initialized;
    private subIds;
    constructor(options: NIP47ConnectionOptions);
    /**
     * Initialize the client, connect to relays and fetch capabilities
     */
    init(): Promise<void>;
    /**
     * Check if the wallet supports a specific method
     */
    supportsMethod(method: string): boolean;
    /**
     * Check if the wallet supports a specific notification type
     */
    supportsNotification(type: string): boolean;
    /**
     * Register a notification handler
     */
    onNotification(type: string, handler: (notification: NIP47Notification<unknown>) => void): void;
    /**
     * Get the client's public key
     */
    getPublicKey(): string;
    /**
     * Get access to the underlying Nostr client for logging configuration
     */
    getNostrClient(): Nostr;
    /**
     * Disconnect from the wallet service
     */
    disconnect(): Promise<void>;
    /**
     * Set up subscription to receive responses from the wallet service
     */
    private setupSubscription;
    /**
     * Handle incoming events from the wallet service
     */
    private handleEvent;
    /**
     * Validate that a response follows the NIP-47 specification structure
     */
    private validateResponse;
    /**
     * Handle response events
     */
    private handleResponse;
    /**
     * Handle notification events
     */
    private handleNotification;
    /**
     * Handle info events to discover capabilities
     */
    private handleInfoEvent;
    /**
     * Choose the best encryption scheme based on what's supported by both client and service
     */
    private chooseEncryptionScheme;
    /**
     * Send a request to the wallet service
     */
    private sendRequest;
    /**
     * Get wallet info
     */
    getInfo(options?: {
        expiration?: number;
    }): Promise<GetInfoResponse["result"]>;
    /**
     * Execute an operation with automatic retry for retriable errors
     * @param operation Function to execute
     * @param retryOptions Retry configuration
     * @returns Result of the operation
     */
    withRetry<T>(operation: () => Promise<T>, retryOptions?: Partial<RetryOptions>): Promise<T>;
    /**
     * Get wallet balance with retry
     */
    getBalanceWithRetry(options?: {
        expiration?: number;
        retry?: Partial<RetryOptions>;
    }): Promise<number>;
    /**
     * Get wallet balance
     */
    getBalance(options?: {
        expiration?: number;
    }): Promise<number>;
    /**
     * Pay a lightning invoice
     */
    payInvoice(invoice: string, amount?: number, maxfee?: number, options?: {
        expiration?: number;
    }): Promise<PayInvoiceResponse["result"]>;
    /**
     * Make an invoice
     */
    makeInvoice(amount: number, description: string, descriptionHash?: string, expiry?: number, options?: {
        expiration?: number;
    }): Promise<MakeInvoiceResponse["result"]>;
    /**
     * Look up invoice information by payment hash or invoice string
     *
     * @param params - Object containing either payment_hash, invoice, or both
     * @param params.payment_hash - The payment hash to look up
     * @param params.invoice - The invoice to look up
     * @param options - Optional request parameters
     * @param options.expiration - Request expiration time in seconds
     * @returns The invoice information
     *
     * @throws {NIP47ClientError} with code INVALID_REQUEST if neither payment_hash nor invoice is provided
     * @throws {NIP47ClientError} with code NOT_FOUND if the invoice or payment hash is not found in the wallet's database
     * @throws {NIP47ClientError} with code LOOKUP_INVOICE_FAILED for other errors
     */
    lookupInvoice(params: {
        payment_hash?: string;
        invoice?: string;
    }, options?: {
        expiration?: number;
    }): Promise<NIP47Transaction>;
    /**
     * List transactions
     */
    listTransactions(params?: {
        from?: number;
        until?: number;
        limit?: number;
        offset?: number;
        unpaid?: boolean;
        type?: TransactionType | string;
    }, options?: {
        expiration?: number;
    }): Promise<ListTransactionsResponseResult>;
    /**
     * Sign a message with the wallet's private key
     */
    signMessage(message: string, options?: {
        expiration?: number;
    }): Promise<SignMessageResponseResult>;
}
