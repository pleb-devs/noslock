import { Nostr } from "../nip01/nostr.js";
import { getPublicKey } from "../utils/crypto.js";
import { createEvent, createSignedEvent, getEventHash } from "../nip01/event.js";
import { encrypt as encryptNIP04, decrypt as decryptNIP04 } from "../nip04/index.js";
import { encrypt as encryptNIP44, decrypt as decryptNIP44 } from "../nip44/index.js";
import { NIP47Method, NIP47EventKind, NIP47ErrorCode, ERROR_CATEGORIES, ERROR_RECOVERY_HINTS, NIP47ErrorCategory, NIP47EncryptionScheme, } from "./types.js";
import { SecurityValidationError } from "../utils/security-validator.js";
/**
 * Parse a NWC URL into connection options
 */
export function parseNWCURL(url) {
    if (!url.startsWith("nostr+walletconnect://")) {
        throw new Error("Invalid NWC URL format");
    }
    // Extract pubkey
    const [_, pubkeyAndParams] = url.split("://");
    const [pubkey, queryString] = pubkeyAndParams.split("?");
    if (!pubkey) {
        throw new Error("Missing pubkey in NWC URL");
    }
    // Parse query parameters
    const params = new URLSearchParams(queryString);
    const relays = [];
    params.getAll("relay").forEach((relay) => relays.push(relay));
    const secret = params.get("secret");
    if (!secret) {
        throw new Error("Missing secret in NWC URL");
    }
    return {
        pubkey,
        secret,
        relays,
    };
}
/**
 * Generate a NWC URL from connection options
 */
export function generateNWCURL(options) {
    if (!options.pubkey) {
        throw new Error("Missing pubkey in connection options");
    }
    if (!options.secret) {
        throw new Error("Missing secret in connection options");
    }
    if (!options.relays || options.relays.length === 0) {
        throw new Error("At least one relay must be specified");
    }
    const params = new URLSearchParams();
    options.relays.forEach((relay) => params.append("relay", relay));
    params.append("secret", options.secret);
    return `nostr+walletconnect://${options.pubkey}?${params.toString()}`;
}
/**
 * Default retry options
 */
const DEFAULT_RETRY_OPTIONS = {
    maxRetries: 3,
    initialDelay: 1000, // 1 second
    maxDelay: 10000, // 10 seconds
    factor: 2, // Exponential backoff factor
};
// Custom error class for NIP-47 errors
export class NIP47ClientError extends Error {
    constructor(message, code, data) {
        super(message);
        this.name = "NIP47ClientError";
        this.code = code;
        // Determine error category
        this.category = ERROR_CATEGORIES[code] || NIP47ErrorCategory.INTERNAL;
        // Add recovery hint if available
        this.recoveryHint = ERROR_RECOVERY_HINTS[code];
        // Add additional error data if provided
        this.data = data;
    }
    /**
     * Creates an error instance from a NIP47Error response
     */
    static fromResponseError(error) {
        return new NIP47ClientError(error.message || "Unknown error", error.code || NIP47ErrorCode.INTERNAL_ERROR, error.data);
    }
    /**
     * Check if the error is a network-related error
     */
    isNetworkError() {
        return this.category === NIP47ErrorCategory.NETWORK;
    }
    /**
     * Check if the error is a timeout
     */
    isTimeoutError() {
        return this.category === NIP47ErrorCategory.TIMEOUT;
    }
    /**
     * Check if the error is authorization-related
     */
    isAuthorizationError() {
        return this.category === NIP47ErrorCategory.AUTHORIZATION;
    }
    /**
     * Check if retry is recommended for this error
     */
    isRetriable() {
        return (this.isNetworkError() ||
            this.isTimeoutError() ||
            this.code === NIP47ErrorCode.WALLET_UNAVAILABLE);
    }
    /**
     * Get user-friendly error message including recovery hint
     */
    getUserMessage() {
        return this.recoveryHint
            ? `${this.message}. ${this.recoveryHint}`
            : this.message;
    }
}
/**
 * Nostr Wallet Connect client implementation
 *
 * This class provides an API for applications to connect to a NIP-47 compatible
 * wallet service over Nostr.
 */
export class NostrWalletConnectClient {
    constructor(options) {
        this.supportedMethods = [];
        this.supportedNotifications = [];
        this.supportedEncryption = [];
        this.notificationHandlers = new Map();
        this.pendingRequests = new Map();
        this.initialized = false;
        this.subIds = [];
        if (!options.pubkey) {
            throw new Error("Missing pubkey in connection options");
        }
        if (!options.secret) {
            throw new Error("Missing secret in connection options");
        }
        if (!options.relays || options.relays.length === 0) {
            throw new Error("At least one relay must be specified");
        }
        this.pubkey = options.pubkey;
        this.clientPrivkey = options.secret;
        this.clientPubkey = getPublicKey(this.clientPrivkey);
        this.relays = options.relays;
        this.client = new Nostr(this.relays);
        // Set preferred encryption (default to NIP-44 if not specified)
        this.preferredEncryption =
            options.preferredEncryption || NIP47EncryptionScheme.NIP44_V2;
    }
    /**
     * Initialize the client, connect to relays and fetch capabilities
     */
    async init() {
        // Connect to relays
        await this.client.connectToRelays();
        console.log(`Client connected to relays: ${this.relays.join(", ")}`);
        // Set up subscription to receive responses
        this.setupSubscription();
        console.log("Client subscribed to service events");
        // Wait for capabilities to be discovered via events
        console.log("Waiting for service capabilities...");
        await new Promise((resolve) => setTimeout(resolve, 3000));
        if (this.supportedMethods.length === 0) {
            console.warn("No methods discovered from service after timeout, will try explicit getInfo call");
            try {
                // Fallback to explicit getInfo call
                const info = await this.getInfo();
                if (info && info.methods) {
                    this.supportedMethods = info.methods;
                    console.log(`Discovered methods via getInfo: ${this.supportedMethods.join(", ")}`);
                }
                if (info && info.notifications) {
                    this.supportedNotifications = info.notifications;
                    console.log(`Discovered notifications via getInfo: ${this.supportedNotifications.join(", ")}`);
                }
            }
            catch (error) {
                throw new Error(`Failed to initialize wallet connection: ${error}`);
            }
        }
        this.initialized = true;
    }
    /**
     * Check if the wallet supports a specific method
     */
    supportsMethod(method) {
        return this.supportedMethods.includes(method);
    }
    /**
     * Check if the wallet supports a specific notification type
     */
    supportsNotification(type) {
        return this.supportedNotifications.includes(type);
    }
    /**
     * Register a notification handler
     */
    onNotification(type, handler) {
        if (!this.notificationHandlers.has(type)) {
            this.notificationHandlers.set(type, []);
        }
        this.notificationHandlers.get(type).push(handler);
    }
    /**
     * Get the client's public key
     */
    getPublicKey() {
        return this.clientPubkey;
    }
    /**
     * Get access to the underlying Nostr client for logging configuration
     */
    getNostrClient() {
        return this.client;
    }
    /**
     * Disconnect from the wallet service
     */
    disconnect() {
        return new Promise((resolve) => {
            try {
                // Clean up any pending subscriptions
                if (this.subIds.length > 0) {
                    this.client.unsubscribe(this.subIds);
                    this.subIds = [];
                }
                // Reject any pending requests
                if (this.pendingRequests.size > 0) {
                    this.pendingRequests.forEach((pendingRequest) => {
                        pendingRequest.resolve({
                            result_type: NIP47Method.GET_INFO, // Use a placeholder method
                            result: null,
                            error: {
                                code: NIP47ErrorCode.CONNECTION_ERROR,
                                message: "Client disconnected before receiving response",
                                category: NIP47ErrorCategory.NETWORK,
                            },
                        });
                    });
                    this.pendingRequests.clear();
                }
                // Clear notification handlers
                this.notificationHandlers.clear();
                // Disconnect from relay (don't wait for it)
                try {
                    this.client.disconnectFromRelays();
                }
                catch (error) {
                    console.error("Error disconnecting from relays:", error);
                }
                this.initialized = false;
                // Short delay to allow relay disconnection to complete
                setTimeout(() => {
                    resolve();
                }, 100).unref();
            }
            catch (error) {
                console.error("Error during client disconnect:", error);
                resolve();
            }
        });
    }
    /**
     * Set up subscription to receive responses from the wallet service
     */
    setupSubscription() {
        // Subscribe to events from the wallet service directed to us
        const responseFilter = {
            kinds: [
                NIP47EventKind.RESPONSE,
                NIP47EventKind.NOTIFICATION,
                NIP47EventKind.NOTIFICATION_NIP44,
            ],
            authors: [this.pubkey],
            "#p": [this.clientPubkey],
        };
        // Filter for INFO events from the service
        const infoFilter = {
            kinds: [NIP47EventKind.INFO],
            authors: [this.pubkey],
        };
        console.log("Setting up client subscriptions:");
        console.log("Filter 1:", JSON.stringify(responseFilter));
        console.log("Filter 2:", JSON.stringify(infoFilter));
        // Enhanced debug logging for the client filter
        console.log("Client pubkey for filter:", this.clientPubkey);
        console.log("Service pubkey for filter:", this.pubkey);
        this.subIds = this.client.subscribe([responseFilter, infoFilter], (event, relay) => {
            console.log(`Received event: ${event.id} of kind ${event.kind} from ${relay}`);
            console.log(`Event pubkey: ${event.pubkey}, tags: ${JSON.stringify(event.tags)}`);
            // Log all event data for debugging
            console.log(`Full event:`, JSON.stringify(event));
            this.handleEvent(event);
        });
        console.log("Subscription IDs:", this.subIds);
    }
    /**
     * Handle incoming events from the wallet service
     */
    async handleEvent(event) {
        console.log(`Handling event of kind ${event.kind} from ${event.pubkey}`);
        console.log(`Event id: ${event.id}`);
        console.log(`Event tags: ${JSON.stringify(event.tags)}`);
        // Extract p-tag and e-tag values for easier debugging
        const pTags = event.tags
            .filter((tag) => tag[0] === "p")
            .map((tag) => tag[1]);
        const eTags = event.tags.filter((tag) => Array.isArray(tag) && tag.length > 0 && tag[0] === "e");
        console.log(`Event p-tags: ${pTags.join(", ")}`);
        console.log(`Event e-tags: ${eTags.join(", ")}`);
        console.log(`Expected p-tag for this client: ${this.clientPubkey}`);
        if (event.kind === NIP47EventKind.RESPONSE) {
            console.log(`Processing as RESPONSE event (kind ${NIP47EventKind.RESPONSE})`);
            await this.handleResponse(event);
        }
        else if (event.kind === NIP47EventKind.NOTIFICATION ||
            event.kind === NIP47EventKind.NOTIFICATION_NIP44) {
            console.log(`Processing as NOTIFICATION event (kind ${event.kind})`);
            await this.handleNotification(event);
        }
        else if (event.kind === NIP47EventKind.INFO) {
            console.log(`Processing as INFO event (kind ${NIP47EventKind.INFO})`);
            this.handleInfoEvent(event);
        }
        else {
            console.log(`Unknown event kind: ${event.kind}, expected one of: ${NIP47EventKind.RESPONSE}, ${NIP47EventKind.NOTIFICATION}, ${NIP47EventKind.NOTIFICATION_NIP44}, ${NIP47EventKind.INFO}`);
        }
    }
    /**
     * Validate that a response follows the NIP-47 specification structure
     */
    validateResponse(response) {
        // First check if response is an object
        if (!response || typeof response !== "object") {
            throw new NIP47ClientError("Invalid response: not an object", NIP47ErrorCode.INVALID_REQUEST);
        }
        // Cast to a more specific type for property access
        const resp = response;
        // Check if result_type exists and is a string
        if (!resp.result_type || typeof resp.result_type !== "string") {
            throw new NIP47ClientError("Invalid response: missing or invalid result_type", NIP47ErrorCode.INVALID_REQUEST);
        }
        // Verify result_type is a known NIP47Method
        if (!Object.values(NIP47Method).includes(resp.result_type)) {
            throw new NIP47ClientError(`Invalid response: unknown result_type '${resp.result_type}'`, NIP47ErrorCode.INVALID_REQUEST);
        }
        // Check that error field exists (can be null)
        if (!("error" in resp)) {
            throw new NIP47ClientError("Invalid response: missing error field", NIP47ErrorCode.INVALID_REQUEST);
        }
        // If error is not null, validate its structure
        if (resp.error !== null) {
            if (typeof resp.error !== "object") {
                throw new NIP47ClientError("Invalid response: error field must be an object or null", NIP47ErrorCode.INVALID_REQUEST);
            }
            const error = resp.error;
            // Check error has code and message
            if (!error.code || typeof error.code !== "string") {
                throw new NIP47ClientError("Invalid response: error must have a code field", NIP47ErrorCode.INVALID_REQUEST);
            }
            if (!error.message || typeof error.message !== "string") {
                throw new NIP47ClientError("Invalid response: error must have a message field", NIP47ErrorCode.INVALID_REQUEST);
            }
            // When there's an error, result should be null
            if (resp.result !== null) {
                throw new NIP47ClientError("Invalid response: when error is present, result must be null", NIP47ErrorCode.INVALID_REQUEST);
            }
        }
        // If no error, result should be defined and not null
        if (resp.error === null &&
            (resp.result === null || resp.result === undefined)) {
            throw new NIP47ClientError("Invalid response: when error is null, result must be defined and not null", NIP47ErrorCode.INVALID_REQUEST);
        }
        return response;
    }
    /**
     * Handle response events
     */
    async handleResponse(event) {
        try {
            // Find the e-tag which references the request event ID first
            const eTags = event.tags.filter((tag) => Array.isArray(tag) && tag.length > 0 && tag[0] === "e");
            if (eTags.length === 0) {
                console.warn("Response event has no e-tag, cannot correlate with a request");
                return;
            }
            // Get the request ID from the e-tag
            let requestId;
            try {
                const firstETag = eTags[0];
                requestId = firstETag[1]; // e-tags have structure ["e", requestId, ...]
            }
            catch (error) {
                if (error instanceof SecurityValidationError) {
                    console.warn(`NIP-47: Bounds checking error in e-tag processing: ${error.message}`);
                }
                return;
            }
            // Find the pending request to get the encryption scheme
            const pendingRequest = this.pendingRequests.get(requestId);
            if (!pendingRequest) {
                console.warn(`No pending request found with ID: ${requestId}`);
                return;
            }
            // Use the tracked encryption scheme from the request
            let decrypted;
            const { encryptionScheme } = pendingRequest;
            try {
                if (encryptionScheme === NIP47EncryptionScheme.NIP44_V2) {
                    decrypted = await decryptNIP44(event.content, this.clientPrivkey, this.pubkey);
                }
                else {
                    decrypted = decryptNIP04(this.clientPrivkey, this.pubkey, event.content);
                }
            }
            catch (decryptError) {
                console.error(`Failed to decrypt response with ${encryptionScheme}:`, decryptError);
                throw decryptError;
            }
            const response = JSON.parse(decrypted);
            // Validate response structure
            this.validateResponse(response);
            console.log(`Validated response of type: ${response.result_type}`);
            console.log(`Found request ID from e-tag: ${requestId}`);
            // Resolve the pending request
            pendingRequest.resolve(response);
            this.pendingRequests.delete(requestId);
            console.log(`Request ${requestId} resolved successfully`);
        }
        catch (error) {
            if (error instanceof SecurityValidationError) {
                console.warn(`NIP-47: Security validation error in response handling: ${error.message}`);
            }
            else {
                console.error("Error handling response event:", error);
            }
        }
    }
    /**
     * Handle notification events
     */
    async handleNotification(event) {
        try {
            // Decrypt the content with client's private key and service's public key
            let decrypted;
            // Determine encryption based on event kind
            if (event.kind === NIP47EventKind.NOTIFICATION_NIP44) {
                decrypted = await decryptNIP44(event.content, this.clientPrivkey, this.pubkey);
            }
            else {
                // NIP47EventKind.NOTIFICATION uses NIP-04
                decrypted = decryptNIP04(this.clientPrivkey, this.pubkey, event.content);
            }
            const notification = JSON.parse(decrypted);
            // Find and call the notification handlers
            const handlers = this.notificationHandlers.get(notification.notification_type);
            if (handlers) {
                handlers.forEach((handler) => handler(notification));
            }
        }
        catch (error) {
            console.error("Failed to handle notification:", error);
        }
    }
    /**
     * Handle info events to discover capabilities
     */
    handleInfoEvent(event) {
        try {
            console.log("Received INFO event from:", event.pubkey);
            console.log("Expected service pubkey:", this.pubkey);
            console.log("Event kind:", event.kind, "Expected:", NIP47EventKind.INFO);
            console.log("Event content:", event.content);
            console.log("Event tags:", JSON.stringify(event.tags));
            // Extract supported methods from content
            if (event.content.trim()) {
                this.supportedMethods = event.content.trim().split(" ");
            }
            // Extract supported notifications from tags
            const notificationsTag = event.tags.find((tag) => Array.isArray(tag) && tag.length > 1 && tag[0] === "notifications");
            if (notificationsTag && typeof notificationsTag[1] === "string") {
                this.supportedNotifications = notificationsTag[1].split(" ");
            }
            // Extract supported encryption schemes from tags
            const encryptionTag = event.tags.find((tag) => Array.isArray(tag) && tag.length > 1 && tag[0] === "encryption");
            if (encryptionTag && typeof encryptionTag[1] === "string") {
                const schemes = encryptionTag[1].split(" ");
                this.supportedEncryption = schemes
                    .map((s) => s)
                    .filter((s) => Object.values(NIP47EncryptionScheme).includes(s));
            }
            else {
                // If no encryption tag, assume only NIP-04 is supported (backwards compatibility)
                this.supportedEncryption = [NIP47EncryptionScheme.NIP04];
            }
            console.log("Discovered capabilities:");
            console.log(`Methods: ${this.supportedMethods.join(", ")}`);
            console.log(`Notifications: ${this.supportedNotifications.join(", ")}`);
            console.log(`Encryption: ${this.supportedEncryption.join(", ")}`);
        }
        catch (error) {
            if (error instanceof SecurityValidationError) {
                console.warn(`NIP-47: Security validation error in info event handling: ${error.message}`);
            }
            else {
                console.error("Failed to handle info event:", error);
            }
        }
    }
    /**
     * Choose the best encryption scheme based on what's supported by both client and service
     */
    chooseEncryptionScheme() {
        // If service supports our preferred encryption, use it
        if (this.supportedEncryption.includes(this.preferredEncryption)) {
            return this.preferredEncryption;
        }
        // Otherwise, prefer NIP-44 if available
        if (this.supportedEncryption.includes(NIP47EncryptionScheme.NIP44_V2)) {
            return NIP47EncryptionScheme.NIP44_V2;
        }
        // Fall back to NIP-04
        return NIP47EncryptionScheme.NIP04;
    }
    /**
     * Send a request to the wallet service
     */
    async sendRequest(request, expiration) {
        if (!this.initialized) {
            throw new NIP47ClientError("Client not initialized", NIP47ErrorCode.NOT_INITIALIZED);
        }
        // Create tags for the request
        const tags = [["p", this.pubkey]];
        // Add expiration tag if provided
        if (expiration) {
            // Ensure expiration is a timestamp in seconds
            const expirationTimestamp = Math.floor(expiration);
            tags.push(["expiration", expirationTimestamp.toString()]);
        }
        // Create event template
        const eventTemplate = {
            kind: NIP47EventKind.REQUEST,
            content: "",
            tags,
        };
        // Create the event
        const event = createEvent(eventTemplate, this.clientPubkey);
        // Choose the best encryption scheme
        const encryptionScheme = this.chooseEncryptionScheme();
        // Add encryption tag if using NIP-44
        if (encryptionScheme === NIP47EncryptionScheme.NIP44_V2) {
            event.tags.push(["encryption", encryptionScheme]);
        }
        // Encrypt the request
        let encryptedContent;
        try {
            if (encryptionScheme === NIP47EncryptionScheme.NIP44_V2) {
                encryptedContent = await encryptNIP44(JSON.stringify(request), this.clientPrivkey, this.pubkey);
            }
            else {
                encryptedContent = encryptNIP04(this.clientPrivkey, this.pubkey, JSON.stringify(request));
            }
        }
        catch (error) {
            const err = error instanceof Error ? error : new Error(String(error));
            throw new NIP47ClientError(`Failed to encrypt request: ${err.message || "Unknown error"}`, NIP47ErrorCode.ENCRYPTION_ERROR, { originalError: error, encryptionScheme });
        }
        event.content = encryptedContent;
        // Generate event ID
        let eventId;
        try {
            eventId = await getEventHash(event);
        }
        catch (error) {
            const err = error instanceof Error ? error : new Error(String(error));
            throw new NIP47ClientError(`Failed to generate event hash: ${err.message || "Unknown error"}`, NIP47ErrorCode.INTERNAL_ERROR, { originalError: error });
        }
        // Create a promise to wait for the response
        const responsePromise = new Promise((resolve, reject) => {
            // Set timeout for request
            const timeoutMs = 30000; // 30 seconds
            const timeout = setTimeout(() => {
                this.pendingRequests.delete(eventId);
                reject(new NIP47ClientError("Request timed out", NIP47ErrorCode.TIMEOUT));
            }, timeoutMs);
            // Store the resolve function and encryption scheme for later
            this.pendingRequests.set(eventId, {
                resolve: (response) => {
                    clearTimeout(timeout);
                    // Check for errors in the response
                    if (response.error) {
                        const error = NIP47ClientError.fromResponseError(response.error);
                        reject(error);
                    }
                    else {
                        resolve(response);
                    }
                },
                encryptionScheme,
            });
        });
        try {
            // Sign and publish the event
            const signedEvent = await createSignedEvent(event, this.clientPrivkey);
            await this.client.publishEvent(signedEvent);
        }
        catch (error) {
            this.pendingRequests.delete(eventId);
            if (error instanceof NIP47ClientError) {
                throw error;
            }
            const err = error instanceof Error ? error : new Error(String(error));
            throw new NIP47ClientError(`Failed to publish request: ${err.message || "Unknown error"}`, NIP47ErrorCode.PUBLISH_FAILED, { originalError: error });
        }
        // Wait for response
        return responsePromise;
    }
    /**
     * Get wallet info
     */
    async getInfo(options) {
        try {
            const request = {
                method: NIP47Method.GET_INFO,
                params: {},
            };
            const response = await this.sendRequest(request, options?.expiration);
            // If we got a successful response, update our capabilities
            if (response.result) {
                const info = response.result;
                if (info?.methods) {
                    this.supportedMethods = info.methods;
                }
                if (info?.notifications) {
                    this.supportedNotifications = info.notifications;
                }
                if (info?.encryption) {
                    this.supportedEncryption = info.encryption
                        .map((s) => s)
                        .filter((s) => Object.values(NIP47EncryptionScheme).includes(s));
                }
                else {
                    // If no encryption field, assume only NIP-04 is supported
                    this.supportedEncryption = [NIP47EncryptionScheme.NIP04];
                }
            }
            return response.result;
        }
        catch (error) {
            if (error instanceof NIP47ClientError) {
                throw error;
            }
            const err = error instanceof Error ? error : new Error(String(error));
            throw new NIP47ClientError(`Error getting wallet info: ${err.message || "Unknown error"}`, NIP47ErrorCode.INTERNAL_ERROR, { originalError: error });
        }
    }
    /**
     * Execute an operation with automatic retry for retriable errors
     * @param operation Function to execute
     * @param retryOptions Retry configuration
     * @returns Result of the operation
     */
    async withRetry(operation, retryOptions = {}) {
        const options = {
            ...DEFAULT_RETRY_OPTIONS,
            ...retryOptions,
        };
        let lastError = null;
        let currentDelay = options.initialDelay;
        for (let attempt = 0; attempt <= options.maxRetries; attempt++) {
            try {
                // Wait before retrying (except on first attempt)
                if (attempt > 0) {
                    await new Promise((resolve) => setTimeout(resolve, currentDelay));
                    // Increase delay for next retry (with exponential backoff)
                    currentDelay = Math.min(currentDelay * options.factor, options.maxDelay);
                }
                return await operation();
            }
            catch (error) {
                // Only retry if it's a retriable error
                if (error instanceof NIP47ClientError && error.isRetriable()) {
                    lastError = error;
                    // Continue to next iteration for retry
                }
                else {
                    // Non-retriable error, rethrow immediately
                    throw error;
                }
            }
        }
        // If we've exhausted all retries
        if (lastError) {
            throw lastError;
        }
        // This should never happen, but TypeScript requires it
        throw new NIP47ClientError("Retry operation failed for an unknown reason", NIP47ErrorCode.INTERNAL_ERROR);
    }
    // Example use of retry with existing method
    /**
     * Get wallet balance with retry
     */
    async getBalanceWithRetry(options) {
        return this.withRetry(() => this.getBalance(options), options?.retry);
    }
    /**
     * Get wallet balance
     */
    async getBalance(options) {
        const response = await this.sendRequest({
            method: NIP47Method.GET_BALANCE,
            params: {},
        }, options?.expiration);
        return response.result;
    }
    /**
     * Pay a lightning invoice
     */
    async payInvoice(invoice, amount, maxfee, options) {
        if (!invoice) {
            throw new NIP47ClientError("Invoice is required", NIP47ErrorCode.INVALID_REQUEST);
        }
        try {
            const request = {
                method: NIP47Method.PAY_INVOICE,
                params: {
                    invoice,
                    amount,
                    maxfee,
                },
            };
            const response = await this.sendRequest(request, options?.expiration);
            return response.result;
        }
        catch (error) {
            if (error instanceof NIP47ClientError) {
                throw error;
            }
            const err = error instanceof Error ? error : new Error(String(error));
            throw new NIP47ClientError(`Error paying invoice: ${err.message || "Unknown error"}`, NIP47ErrorCode.PAYMENT_FAILED, { originalError: error });
        }
    }
    /**
     * Make an invoice
     */
    async makeInvoice(amount, description, descriptionHash, expiry, options) {
        // Add parameter validation
        if (amount === null || amount === undefined) {
            throw new NIP47ClientError("Amount is required", NIP47ErrorCode.INVALID_REQUEST);
        }
        if (!description && !descriptionHash) {
            throw new NIP47ClientError("Description or description hash is required", NIP47ErrorCode.INVALID_REQUEST);
        }
        try {
            const request = {
                method: NIP47Method.MAKE_INVOICE,
                params: {
                    amount,
                    description,
                    description_hash: descriptionHash,
                    expiry,
                },
            };
            const response = await this.sendRequest(request, options?.expiration);
            return response.result;
        }
        catch (error) {
            if (error instanceof NIP47ClientError) {
                throw error;
            }
            const err = error instanceof Error ? error : new Error(String(error));
            throw new NIP47ClientError(`Error creating invoice: ${err.message || "Unknown error"}`, NIP47ErrorCode.INTERNAL_ERROR, { originalError: error });
        }
    }
    /**
     * Look up invoice information by payment hash or invoice string
     *
     * @param params - Object containing either payment_hash, invoice, or both
     * @param params.payment_hash - The payment hash to look up
     * @param params.invoice - The invoice to look up
     * @param options - Optional request parameters
     * @param options.expiration - Request expiration time in seconds
     * @returns The invoice information
     *
     * @throws {NIP47ClientError} with code INVALID_REQUEST if neither payment_hash nor invoice is provided
     * @throws {NIP47ClientError} with code NOT_FOUND if the invoice or payment hash is not found in the wallet's database
     * @throws {NIP47ClientError} with code LOOKUP_INVOICE_FAILED for other errors
     */
    async lookupInvoice(params, options) {
        // Check that at least one required parameter is provided
        if (!params.payment_hash && !params.invoice) {
            throw new NIP47ClientError("Payment hash or invoice is required", NIP47ErrorCode.INVALID_REQUEST);
        }
        try {
            const request = {
                method: NIP47Method.LOOKUP_INVOICE,
                params: {
                    payment_hash: params.payment_hash,
                    invoice: params.invoice,
                },
            };
            const response = await this.sendRequest(request, options?.expiration);
            // If we get here, the request was successful
            return response.result;
        }
        catch (error) {
            if (error instanceof NIP47ClientError) {
                // Check specifically for NOT_FOUND errors
                if (error.code === NIP47ErrorCode.NOT_FOUND) {
                    // Properly propagate NOT_FOUND errors with a clear message
                    const lookupType = params.payment_hash ? "payment_hash" : "invoice";
                    const lookupValue = params.payment_hash || params.invoice;
                    throw new NIP47ClientError(`Invoice not found: Could not find ${lookupType}: ${lookupValue} in the wallet's database`, NIP47ErrorCode.NOT_FOUND);
                }
                // Pass through other existing NIP47ClientError instances
                throw error;
            }
            // For other errors, we wrap with a generic LOOKUP_INVOICE_FAILED error
            const err = error instanceof Error ? error : new Error(String(error));
            throw new NIP47ClientError(`Error looking up invoice: ${err.message || "Unknown error"}`, NIP47ErrorCode.LOOKUP_INVOICE_FAILED, { originalError: error });
        }
    }
    /**
     * List transactions
     */
    async listTransactions(params = {}, options) {
        const response = await this.sendRequest({
            method: NIP47Method.LIST_TRANSACTIONS,
            params,
        }, options?.expiration);
        // Ensure we return a standardized format with a transactions array
        const result = response.result;
        if (Array.isArray(result)) {
            return { transactions: result };
        }
        return result;
    }
    /**
     * Sign a message with the wallet's private key
     */
    async signMessage(message, options) {
        const response = await this.sendRequest({
            method: NIP47Method.SIGN_MESSAGE,
            params: {
                message,
            },
        }, options?.expiration);
        return response.result;
    }
}
