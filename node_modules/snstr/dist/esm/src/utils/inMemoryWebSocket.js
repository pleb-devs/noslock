/**********************************************************************
 * In-memory WebSocket transport used for environments where creating
 * actual TCP listeners is not permitted (e.g., sandboxed CI). This
 * module provides a minimal subset of the `ws` server/client behaviour
 * that the SNSTR test suite relies on:
 *   - Server side emits `connection`, `message`, `close`, `error`
 *   - Client side exposes the DOM-style WebSocket callbacks
 * The implementation is intentionally lightweight and only supports
 * text frames (strings), which is sufficient for Nostr messages.
 *********************************************************************/
import { EventEmitter } from "events";
const CONNECTING = 0;
const OPEN = 1;
const CLOSING = 2;
const CLOSED = 3;
class ServerSideSocket extends EventEmitter {
    constructor(server) {
        super();
        this.server = server;
        this.readyState = OPEN;
        this.peer = null;
        this.terminate = () => {
            this.close(1006, "Server terminated");
        };
    }
    attachPeer(peer) {
        this.peer = peer;
    }
    receiveFromClient(data) {
        if (this.readyState !== OPEN) {
            return;
        }
        this.emit("message", data);
    }
    send(data) {
        if (this.readyState !== OPEN) {
            return;
        }
        const peer = this.peer;
        if (!peer)
            return;
        queueMicrotask(() => peer.receiveFromServer(data));
    }
    close(code = 1000, reason = "Server closing") {
        if (this.readyState === CLOSED) {
            return;
        }
        this.readyState = CLOSING;
        const peer = this.peer;
        queueMicrotask(() => {
            this.readyState = CLOSED;
            this.emit("close", code, reason);
            if (peer) {
                peer.handleServerClosure(code, reason);
            }
            this.server.deregister(this);
        });
    }
}
class ClientSideSocket {
    constructor(serverSocket) {
        this.serverSocket = serverSocket;
        this.readyState = CONNECTING;
        this.onopen = null;
        this.onclose = null;
        this.onerror = null;
        this.onmessage = null;
        this.serverSocket.attachPeer(this);
        queueMicrotask(() => {
            if (this.readyState !== CONNECTING) {
                return;
            }
            this.readyState = OPEN;
            this.onopen?.({ type: "open" });
        });
    }
    send(data) {
        if (this.readyState !== OPEN) {
            this.onerror?.({
                type: "error",
                error: new Error("Cannot send on closed WebSocket"),
            });
            return;
        }
        this.serverSocket.receiveFromClient(data);
    }
    close(code = 1000, reason = "Client closing") {
        if (this.readyState === CLOSED) {
            return;
        }
        if (this.readyState === CONNECTING) {
            this.readyState = CLOSING;
            this.serverSocket.close(code, reason);
            return;
        }
        this.readyState = CLOSING;
        this.serverSocket.close(code, reason);
    }
    receiveFromServer(data) {
        if (this.readyState !== OPEN) {
            return;
        }
        this.onmessage?.({ type: "message", data });
    }
    handleServerClosure(code = 1000, reason = "Server closed") {
        if (this.readyState === CLOSED) {
            return;
        }
        this.readyState = CLOSED;
        this.onclose?.({ type: "close", code, reason });
    }
    handleServerError(error) {
        this.onerror?.({ type: "error", error });
    }
}
export class InMemoryWebSocketServer extends EventEmitter {
    constructor(port) {
        super();
        this.clients = new Set();
        this.port = port;
    }
    connectClient() {
        const serverSocket = new ServerSideSocket(this);
        const clientSocket = new ClientSideSocket(serverSocket);
        this.clients.add(serverSocket);
        queueMicrotask(() => this.emit("connection", serverSocket));
        return clientSocket;
    }
    close() {
        for (const client of [...this.clients]) {
            client.close(1000, "Server shutting down");
        }
        this.emit("close");
    }
    deregister(socket) {
        this.clients.delete(socket);
    }
}
const serverRegistry = new Map();
let nextDynamicPort = 64000;
function getNextPort() {
    while (serverRegistry.has(nextDynamicPort)) {
        nextDynamicPort++;
    }
    return nextDynamicPort++;
}
export function registerInMemoryServer(requestedPort) {
    let port = typeof requestedPort === "number" && requestedPort > 0
        ? requestedPort
        : getNextPort();
    if (serverRegistry.has(port)) {
        port = getNextPort();
    }
    const server = new InMemoryWebSocketServer(port);
    serverRegistry.set(port, server);
    return { port, server };
}
export function getInMemoryServer(port) {
    return serverRegistry.get(port);
}
export function unregisterInMemoryServer(port) {
    const server = serverRegistry.get(port);
    if (server) {
        server.close();
        serverRegistry.delete(port);
    }
}
export function createInMemoryWebSocket(url) {
    try {
        const parsed = new URL(url);
        const hostname = parsed.hostname;
        const normalizedHostname = hostname.startsWith("[") && hostname.endsWith("]")
            ? hostname.slice(1, -1)
            : hostname;
        const protocol = parsed.protocol;
        if (normalizedHostname !== "127.0.0.1" &&
            normalizedHostname !== "localhost" &&
            normalizedHostname !== "::1") {
            return undefined;
        }
        let port;
        if (parsed.port) {
            port = Number(parsed.port);
        }
        else if (protocol === "ws:") {
            port = 80;
        }
        else if (protocol === "wss:") {
            port = 443;
        }
        else {
            return undefined;
        }
        if (!Number.isFinite(port) || port <= 0) {
            return undefined;
        }
        const server = getInMemoryServer(port);
        if (!server) {
            return undefined;
        }
        return server.connectClient();
    }
    catch (_error) {
        return undefined;
    }
}
