// NIP-02 implementation will go here
import { getUnixTime } from "../utils/time.js";
import { isValidPublicKeyPoint } from "../nip44/index.js";
import { isValidRelayUrl } from "../nip19/index.js";
import { normalizeRelayUrl as canonicalizeRelayUrl } from "../utils/relayUrl.js";
import { validateArrayAccess, safeArrayAccess, SecurityValidationError, } from "../utils/security-validator.js";
/**
 * Creates a NIP-02 contact list event (kind 3).
 *
 * @param contacts An array of `Contact` objects.
 * @param existingContent Optional content for the event.
 *                        NIP-02 allows for legacy petnames in a JSON string here,
 *                        but recommends petnames in tags.
 * @returns A NostrEvent object (unsigned) representing the contact list.
 */
export function createContactListEvent(contacts, existingContent = "") {
    // Assuming ContactsEvent is a more generic kind 3 type
    const tags = contacts.map((contact) => {
        const tag = ["p", contact.pubkey];
        if (contact.relayUrl || contact.petname) {
            // Need to add relayUrl even if empty if petname is present
            tag.push(contact.relayUrl || "");
        }
        if (contact.petname) {
            tag.push(contact.petname);
        }
        return tag;
    });
    return {
        kind: 3,
        tags,
        content: existingContent,
        created_at: getUnixTime(),
    };
}
export function parseContactsFromEvent(event, options = {}) {
    // Assuming ContactsEvent is suitable
    if (event.kind !== 3) {
        throw new Error("Invalid event: Expected kind 3 for contact list.");
    }
    const parsedContacts = [];
    const warnings = [];
    const seenPubkeys = new Set();
    const addWarning = (type, message, value, context) => {
        const warning = { type, message, value, context };
        warnings.push(warning);
        if (options.logger) {
            try {
                options.logger.warn(message, { value, context });
            }
            catch {
                // Ignore logger errors to prevent parsing from being aborted
            }
        }
    };
    // Use shared validators for pubkeys and relay URLs
    event.tags.forEach((tag, tagIndex) => {
        try {
            // Bounds check for basic tag structure
            if (!validateArrayAccess(tag, 0) || safeArrayAccess(tag, 0) !== "p") {
                return; // Skip non-p tags
            }
            // Safe access to tag[1] (pubkey)
            const pubkeyValue = safeArrayAccess(tag, 1);
            if (typeof pubkeyValue !== "string") {
                addWarning("invalid_pubkey", `Invalid p tag structure: pubkey at index 1 must be a string`, String(pubkeyValue), { tagIndex });
                return;
            }
            // Normalize to lowercase first to accept legacy uppercase pubkeys
            const normalizedPubkey = pubkeyValue.toLowerCase();
            // Validate that the public key is a valid curve point on secp256k1
            if (!isValidPublicKeyPoint(normalizedPubkey)) {
                addWarning("invalid_pubkey", `Invalid public key (not a valid curve point): ${pubkeyValue}`, pubkeyValue, { tagIndex });
                return; // Skip invalid keys
            }
            // Skip duplicate pubkeys (normalize to lowercase for consistent deduplication)
            if (seenPubkeys.has(normalizedPubkey)) {
                addWarning("duplicate_pubkey", `Duplicate public key: ${normalizedPubkey}`, normalizedPubkey, { tagIndex });
                return;
            }
            seenPubkeys.add(normalizedPubkey);
            const contact = {
                pubkey: normalizedPubkey,
            };
            // Safe access to tag[2] (relay URL) - optional
            const relayUrlValue = safeArrayAccess(tag, 2);
            if (typeof relayUrlValue === "string" && relayUrlValue.length > 0) {
                // Trim and canonicalize the relay URL (lowercase scheme + host) for consistency
                const trimmedRelayUrl = relayUrlValue.trim();
                if (trimmedRelayUrl.length > 0) {
                    // Require the tag value itself to include a valid ws:// or wss:// scheme.
                    // This prevents "naked" hostnames from being auto-upgraded and accepted.
                    const hasWebSocketScheme = /^wss?:\/\//i.test(trimmedRelayUrl);
                    if (!hasWebSocketScheme) {
                        // Treat as invalid and keep relayUrl undefined but retain petname.
                        addWarning("invalid_relay_url", `Invalid relay URL (missing ws/wss scheme): ${relayUrlValue}`, relayUrlValue, {
                            pubkey: normalizedPubkey,
                            tagIndex,
                        });
                    }
                    else {
                        let canonicalUrl;
                        try {
                            canonicalUrl = canonicalizeRelayUrl(trimmedRelayUrl);
                        }
                        catch {
                            canonicalUrl = undefined;
                        }
                        if (canonicalUrl && isValidRelayUrl(canonicalUrl)) {
                            contact.relayUrl = canonicalUrl;
                        }
                        else {
                            addWarning("invalid_relay_url", `Invalid relay URL (failed validation): ${relayUrlValue}`, relayUrlValue, {
                                pubkey: normalizedPubkey,
                                tagIndex,
                            });
                        }
                    }
                }
            }
            // Safe access to tag[3] (petname) - optional
            const petnameValue = safeArrayAccess(tag, 3);
            if (typeof petnameValue === "string" && petnameValue.length > 0) {
                contact.petname = petnameValue;
            }
            parsedContacts.push(contact);
        }
        catch (error) {
            if (error instanceof SecurityValidationError) {
                addWarning("invalid_pubkey", `Bounds checking error: ${error.message}`, "", { tagIndex });
            }
            // Continue processing other tags
        }
    });
    if (options.returnWarnings) {
        return { contacts: parsedContacts, warnings };
    }
    return parsedContacts;
}
/**
 * Parses a NIP-02 contact list event with detailed warnings.
 * This is a convenience function that always returns warnings.
 *
 * @param event The contact list event (must be kind 3).
 * @param logger Optional logger to handle warnings externally.
 * @returns A `ParseContactsResult` object containing contacts and warnings.
 * @throws Error if the event is not a valid kind 3 event.
 */
export function parseContactsFromEventWithWarnings(event, logger) {
    return parseContactsFromEvent(event, { logger, returnWarnings: true });
}
