import {
  require_crypto
} from "./chunk-ASV3HNLX.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-7D4SUZUM.js";

// node_modules/tstl/utility/node.js
var require_node = __commonJS({
  "node_modules/tstl/utility/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.is_node = void 0;
    function is_node() {
      if (is_node_ === null)
        is_node_ = typeof global === "object" && is_node_process(global);
      return is_node_;
    }
    exports.is_node = is_node;
    function is_node_process(m) {
      return m !== null && typeof m.process === "object" && m.process !== null && typeof m.process.versions === "object" && m.process.versions !== null && typeof m.process.versions.node !== "undefined";
    }
    var is_node_ = null;
  }
});

// node_modules/es5-ext/global.js
var require_global = __commonJS({
  "node_modules/es5-ext/global.js"(exports, module) {
    var naiveFallback = function() {
      if (typeof self === "object" && self) return self;
      if (typeof window === "object" && window) return window;
      throw new Error("Unable to resolve global `this`");
    };
    module.exports = (function() {
      if (this) return this;
      if (typeof globalThis === "object" && globalThis) return globalThis;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this;
          },
          configurable: true
        });
      } catch (error) {
        return naiveFallback();
      }
      try {
        if (!__global__) return naiveFallback();
        return __global__;
      } finally {
        delete Object.prototype.__global__;
      }
    })();
  }
});

// node_modules/websocket/package.json
var require_package = __commonJS({
  "node_modules/websocket/package.json"(exports, module) {
    module.exports = {
      name: "websocket",
      description: "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
      keywords: [
        "websocket",
        "websockets",
        "socket",
        "networking",
        "comet",
        "push",
        "RFC-6455",
        "realtime",
        "server",
        "client"
      ],
      author: "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
      contributors: [
        "IÃ±aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
      ],
      version: "1.0.35",
      repository: {
        type: "git",
        url: "https://github.com/theturtle32/WebSocket-Node.git"
      },
      homepage: "https://github.com/theturtle32/WebSocket-Node",
      engines: {
        node: ">=4.0.0"
      },
      dependencies: {
        bufferutil: "^4.0.1",
        debug: "^2.2.0",
        "es5-ext": "^0.10.63",
        "typedarray-to-buffer": "^3.1.5",
        "utf-8-validate": "^5.0.2",
        yaeti: "^0.0.6"
      },
      devDependencies: {
        "buffer-equal": "^1.0.0",
        gulp: "^4.0.2",
        "gulp-jshint": "^2.0.4",
        "jshint-stylish": "^2.2.1",
        jshint: "^2.0.0",
        tape: "^4.9.1"
      },
      config: {
        verbose: false
      },
      scripts: {
        test: "tape test/unit/*.js",
        gulp: "gulp"
      },
      main: "index",
      directories: {
        lib: "./lib"
      },
      browser: "lib/browser.js",
      license: "Apache-2.0"
    };
  }
});

// node_modules/websocket/lib/version.js
var require_version = __commonJS({
  "node_modules/websocket/lib/version.js"(exports, module) {
    module.exports = require_package().version;
  }
});

// node_modules/websocket/lib/browser.js
var require_browser = __commonJS({
  "node_modules/websocket/lib/browser.js"(exports, module) {
    var _globalThis;
    if (typeof globalThis === "object") {
      _globalThis = globalThis;
    } else {
      try {
        _globalThis = require_global();
      } catch (error) {
      } finally {
        if (!_globalThis && typeof window !== "undefined") {
          _globalThis = window;
        }
        if (!_globalThis) {
          throw new Error("Could not determine global this");
        }
      }
    }
    var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
    var websocket_version = require_version();
    function W3CWebSocket(uri, protocols) {
      var native_instance;
      if (protocols) {
        native_instance = new NativeWebSocket(uri, protocols);
      } else {
        native_instance = new NativeWebSocket(uri);
      }
      return native_instance;
    }
    if (NativeWebSocket) {
      ["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function(prop) {
        Object.defineProperty(W3CWebSocket, prop, {
          get: function() {
            return NativeWebSocket[prop];
          }
        });
      });
    }
    module.exports = {
      "w3cwebsocket": NativeWebSocket ? W3CWebSocket : null,
      "version": websocket_version
    };
  }
});

// node_modules/tstl/internal/iterator/disposable/ForOfAdaptor.js
var require_ForOfAdaptor = __commonJS({
  "node_modules/tstl/internal/iterator/disposable/ForOfAdaptor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ForOfAdaptor = void 0;
    var ForOfAdaptor = (
      /** @class */
      (function() {
        function ForOfAdaptor2(first, last) {
          this.it_ = first;
          this.last_ = last;
        }
        ForOfAdaptor2.prototype.next = function() {
          if (this.it_.equals(this.last_))
            return {
              done: true,
              value: void 0
            };
          else {
            var it = this.it_;
            this.it_ = this.it_.next();
            return {
              done: false,
              value: it.value
            };
          }
        };
        ForOfAdaptor2.prototype[Symbol.iterator] = function() {
          return this;
        };
        return ForOfAdaptor2;
      })()
    );
    exports.ForOfAdaptor = ForOfAdaptor;
  }
});

// node_modules/tstl/base/container/Container.js
var require_Container = __commonJS({
  "node_modules/tstl/base/container/Container.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Container = void 0;
    var ForOfAdaptor_1 = require_ForOfAdaptor();
    var Container = (
      /** @class */
      (function() {
        function Container2() {
        }
        Container2.prototype.empty = function() {
          return this.size() === 0;
        };
        Container2.prototype.rbegin = function() {
          return this.end().reverse();
        };
        Container2.prototype.rend = function() {
          return this.begin().reverse();
        };
        Container2.prototype[Symbol.iterator] = function() {
          return new ForOfAdaptor_1.ForOfAdaptor(this.begin(), this.end());
        };
        Container2.prototype.toJSON = function() {
          var e_1, _a;
          var ret = [];
          try {
            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
              var elem = _c.value;
              ret.push(elem);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return ret;
        };
        return Container2;
      })()
    );
    exports.Container = Container;
  }
});

// node_modules/tstl/internal/iterator/disposable/NativeArrayIterator.js
var require_NativeArrayIterator = __commonJS({
  "node_modules/tstl/internal/iterator/disposable/NativeArrayIterator.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NativeArrayIterator = void 0;
    var NativeArrayIterator = (
      /** @class */
      (function() {
        function NativeArrayIterator2(data, index) {
          this.data_ = data;
          this.index_ = index;
        }
        NativeArrayIterator2.prototype.index = function() {
          return this.index_;
        };
        Object.defineProperty(NativeArrayIterator2.prototype, "value", {
          get: function() {
            return this.data_[this.index_];
          },
          enumerable: false,
          configurable: true
        });
        NativeArrayIterator2.prototype.prev = function() {
          --this.index_;
          return this;
        };
        NativeArrayIterator2.prototype.next = function() {
          ++this.index_;
          return this;
        };
        NativeArrayIterator2.prototype.advance = function(n) {
          this.index_ += n;
          return this;
        };
        NativeArrayIterator2.prototype.equals = function(obj) {
          return this.data_ === obj.data_ && this.index_ === obj.index_;
        };
        NativeArrayIterator2.prototype.swap = function(obj) {
          var _a, _b;
          _a = __read([obj.data_, this.data_], 2), this.data_ = _a[0], obj.data_ = _a[1];
          _b = __read([obj.index_, this.index_], 2), this.index_ = _b[0], obj.index_ = _b[1];
        };
        return NativeArrayIterator2;
      })()
    );
    exports.NativeArrayIterator = NativeArrayIterator;
  }
});

// node_modules/tstl/base/container/SetContainer.js
var require_SetContainer = __commonJS({
  "node_modules/tstl/base/container/SetContainer.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetContainer = void 0;
    var Container_1 = require_Container();
    var NativeArrayIterator_1 = require_NativeArrayIterator();
    var SetContainer = (
      /** @class */
      (function(_super) {
        __extends(SetContainer2, _super);
        function SetContainer2(factory) {
          var _this = _super.call(this) || this;
          _this.data_ = factory(_this);
          return _this;
        }
        SetContainer2.prototype.assign = function(first, last) {
          this.clear();
          this.insert(first, last);
        };
        SetContainer2.prototype.clear = function() {
          this.data_.clear();
        };
        SetContainer2.prototype.begin = function() {
          return this.data_.begin();
        };
        SetContainer2.prototype.end = function() {
          return this.data_.end();
        };
        SetContainer2.prototype.has = function(key) {
          return !this.find(key).equals(this.end());
        };
        SetContainer2.prototype.size = function() {
          return this.data_.size();
        };
        SetContainer2.prototype.push = function() {
          var items = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
          }
          if (items.length === 0)
            return this.size();
          var first = new NativeArrayIterator_1.NativeArrayIterator(items, 0);
          var last = new NativeArrayIterator_1.NativeArrayIterator(items, items.length);
          this._Insert_by_range(first, last);
          return this.size();
        };
        SetContainer2.prototype.insert = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (args.length === 1)
            return this._Insert_by_key(args[0]);
          else if (args[0].next instanceof Function && args[1].next instanceof Function)
            return this._Insert_by_range(args[0], args[1]);
          else
            return this._Insert_by_hint(args[0], args[1]);
        };
        SetContainer2.prototype.erase = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (args.length === 1 && !(args[0] instanceof this.end().constructor && args[0].source() === this))
            return this._Erase_by_val(args[0]);
          else if (args.length === 1)
            return this._Erase_by_range(args[0]);
          else
            return this._Erase_by_range(args[0], args[1]);
        };
        SetContainer2.prototype._Erase_by_range = function(first, last) {
          if (last === void 0) {
            last = first.next();
          }
          var it = this.data_.erase(first, last);
          this._Handle_erase(first, last);
          return it;
        };
        return SetContainer2;
      })(Container_1.Container)
    );
    exports.SetContainer = SetContainer;
  }
});

// node_modules/tstl/exception/Exception.js
var require_Exception = __commonJS({
  "node_modules/tstl/exception/Exception.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Exception = void 0;
    var Exception = (
      /** @class */
      (function(_super) {
        __extends(Exception2, _super);
        function Exception2(message) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, message) || this;
          var proto = _newTarget.prototype;
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(_this, proto);
          else
            _this.__proto__ = proto;
          return _this;
        }
        Object.defineProperty(Exception2.prototype, "name", {
          /* ---------------------------------------------------------
              ACCESSORS
          --------------------------------------------------------- */
          /**
           * The error name.
           */
          get: function() {
            return this.constructor.name;
          },
          enumerable: false,
          configurable: true
        });
        Exception2.prototype.what = function() {
          return this.message;
        };
        Exception2.prototype.toJSON = function() {
          return {
            name: this.name,
            message: this.message,
            stack: this.stack
          };
        };
        return Exception2;
      })(Error)
    );
    exports.Exception = Exception;
  }
});

// node_modules/tstl/exception/LogicError.js
var require_LogicError = __commonJS({
  "node_modules/tstl/exception/LogicError.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LogicError = void 0;
    var Exception_1 = require_Exception();
    var LogicError = (
      /** @class */
      (function(_super) {
        __extends(LogicError2, _super);
        function LogicError2(message) {
          return _super.call(this, message) || this;
        }
        return LogicError2;
      })(Exception_1.Exception)
    );
    exports.LogicError = LogicError;
  }
});

// node_modules/tstl/exception/InvalidArgument.js
var require_InvalidArgument = __commonJS({
  "node_modules/tstl/exception/InvalidArgument.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidArgument = void 0;
    var LogicError_1 = require_LogicError();
    var InvalidArgument = (
      /** @class */
      (function(_super) {
        __extends(InvalidArgument2, _super);
        function InvalidArgument2(message) {
          return _super.call(this, message) || this;
        }
        return InvalidArgument2;
      })(LogicError_1.LogicError)
    );
    exports.InvalidArgument = InvalidArgument;
  }
});

// node_modules/tstl/exception/OutOfRange.js
var require_OutOfRange = __commonJS({
  "node_modules/tstl/exception/OutOfRange.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfRange = void 0;
    var LogicError_1 = require_LogicError();
    var OutOfRange = (
      /** @class */
      (function(_super) {
        __extends(OutOfRange2, _super);
        function OutOfRange2(message) {
          return _super.call(this, message) || this;
        }
        return OutOfRange2;
      })(LogicError_1.LogicError)
    );
    exports.OutOfRange = OutOfRange;
  }
});

// node_modules/tstl/internal/exception/ErrorGenerator.js
var require_ErrorGenerator = __commonJS({
  "node_modules/tstl/internal/exception/ErrorGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorGenerator = void 0;
    var InvalidArgument_1 = require_InvalidArgument();
    var OutOfRange_1 = require_OutOfRange();
    var ErrorGenerator;
    (function(ErrorGenerator2) {
      function get_class_name(instance) {
        if (typeof instance === "string")
          return instance;
        var ret = instance.constructor.name;
        if (instance.constructor.__MODULE)
          ret = "".concat(instance.constructor.__MODULE, ".").concat(ret);
        return "std.".concat(ret);
      }
      ErrorGenerator2.get_class_name = get_class_name;
      function empty(instance, method) {
        return new OutOfRange_1.OutOfRange("Error on ".concat(get_class_name(instance), ".").concat(method, "(): it's empty container."));
      }
      ErrorGenerator2.empty = empty;
      function negative_index(instance, method, index) {
        return new OutOfRange_1.OutOfRange("Error on ".concat(get_class_name(instance), ".").concat(method, "(): parametric index is negative -> (index = ").concat(index, ")."));
      }
      ErrorGenerator2.negative_index = negative_index;
      function excessive_index(instance, method, index, size) {
        return new OutOfRange_1.OutOfRange("Error on ".concat(get_class_name(instance), ".").concat(method, "(): parametric index is equal or greater than size -> (index = ").concat(index, ", size: ").concat(size, ")."));
      }
      ErrorGenerator2.excessive_index = excessive_index;
      function not_my_iterator(instance, method) {
        return new InvalidArgument_1.InvalidArgument("Error on ".concat(get_class_name(instance), ".").concat(method, "(): parametric iterator is not this container's own."));
      }
      ErrorGenerator2.not_my_iterator = not_my_iterator;
      function erased_iterator(instance, method) {
        return new InvalidArgument_1.InvalidArgument("Error on ".concat(get_class_name(instance), ".").concat(method, "(): parametric iterator, it already has been erased."));
      }
      ErrorGenerator2.erased_iterator = erased_iterator;
      function negative_iterator(instance, method, index) {
        return new OutOfRange_1.OutOfRange("Error on ".concat(get_class_name(instance), ".").concat(method, "(): parametric iterator is directing negative position -> (index = ").concat(index, ")."));
      }
      ErrorGenerator2.negative_iterator = negative_iterator;
      function iterator_end_value(instance, method) {
        if (method === void 0) {
          method = "end";
        }
        var className = get_class_name(instance);
        return new OutOfRange_1.OutOfRange("Error on ".concat(className, ".Iterator.value: cannot access to the ").concat(className, ".").concat(method, "().value."));
      }
      ErrorGenerator2.iterator_end_value = iterator_end_value;
      function key_nout_found(instance, method, key) {
        throw new OutOfRange_1.OutOfRange("Error on ".concat(get_class_name(instance), ".").concat(method, "(): unable to find the matched key -> ").concat(key));
      }
      ErrorGenerator2.key_nout_found = key_nout_found;
    })(ErrorGenerator = exports.ErrorGenerator || (exports.ErrorGenerator = {}));
  }
});

// node_modules/tstl/base/container/UniqueSet.js
var require_UniqueSet = __commonJS({
  "node_modules/tstl/base/container/UniqueSet.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UniqueSet = void 0;
    var SetContainer_1 = require_SetContainer();
    var ErrorGenerator_1 = require_ErrorGenerator();
    var UniqueSet = (
      /** @class */
      (function(_super) {
        __extends(UniqueSet2, _super);
        function UniqueSet2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        UniqueSet2.prototype.count = function(key) {
          return this.find(key).equals(this.end()) ? 0 : 1;
        };
        UniqueSet2.prototype.insert = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return _super.prototype.insert.apply(this, __spreadArray([], __read(args), false));
        };
        UniqueSet2.prototype._Insert_by_range = function(first, last) {
          for (; !first.equals(last); first = first.next())
            this._Insert_by_key(first.value);
        };
        UniqueSet2.prototype.extract = function(param) {
          if (param instanceof this.end().constructor)
            return this._Extract_by_iterator(param);
          else
            return this._Extract_by_val(param);
        };
        UniqueSet2.prototype._Extract_by_val = function(key) {
          var it = this.find(key);
          if (it.equals(this.end()) === true)
            throw ErrorGenerator_1.ErrorGenerator.key_nout_found(this, "extract", key);
          this._Erase_by_range(it);
          return key;
        };
        UniqueSet2.prototype._Extract_by_iterator = function(it) {
          if (it.equals(this.end()) === true || this.has(it.value) === false)
            return this.end();
          this._Erase_by_range(it);
          return it;
        };
        UniqueSet2.prototype._Erase_by_val = function(key) {
          var it = this.find(key);
          if (it.equals(this.end()) === true)
            return 0;
          this._Erase_by_range(it);
          return 1;
        };
        UniqueSet2.prototype.merge = function(source) {
          for (var it = source.begin(); !it.equals(source.end()); ) {
            if (this.has(it.value) === false) {
              this.insert(it.value);
              it = source.erase(it);
            } else
              it = it.next();
          }
        };
        return UniqueSet2;
      })(SetContainer_1.SetContainer)
    );
    exports.UniqueSet = UniqueSet;
  }
});

// node_modules/tstl/internal/container/associative/IAssociativeContainer.js
var require_IAssociativeContainer = __commonJS({
  "node_modules/tstl/internal/container/associative/IAssociativeContainer.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IAssociativeContainer = void 0;
    var IAssociativeContainer;
    (function(IAssociativeContainer2) {
      function construct(source) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var ramda;
        var tail;
        if (args.length >= 1 && args[0] instanceof Array) {
          ramda = function() {
            var items = args[0];
            source.push.apply(source, __spreadArray([], __read(items), false));
          };
          tail = args.slice(1);
        } else if (args.length >= 2 && args[0].next instanceof Function && args[1].next instanceof Function) {
          ramda = function() {
            var first = args[0];
            var last = args[1];
            source.assign(first, last);
          };
          tail = args.slice(2);
        } else {
          ramda = null;
          tail = args;
        }
        return { ramda, tail };
      }
      IAssociativeContainer2.construct = construct;
    })(IAssociativeContainer = exports.IAssociativeContainer || (exports.IAssociativeContainer = {}));
  }
});

// node_modules/tstl/internal/Global.js
var require_Global = __commonJS({
  "node_modules/tstl/internal/Global.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._Get_root = void 0;
    var node_1 = require_node();
    function _Get_root() {
      if (__s_pRoot === null) {
        __s_pRoot = (0, node_1.is_node)() ? global : self;
        if (__s_pRoot.__s_iUID === void 0)
          __s_pRoot.__s_iUID = 0;
      }
      return __s_pRoot;
    }
    exports._Get_root = _Get_root;
    var __s_pRoot = null;
  }
});

// node_modules/tstl/functional/uid.js
var require_uid = __commonJS({
  "node_modules/tstl/functional/uid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.get_uid = void 0;
    var Global_1 = require_Global();
    function get_uid(obj) {
      if (obj instanceof Object) {
        if (obj.hasOwnProperty("__get_m_iUID") === false) {
          var uid_1 = ++(0, Global_1._Get_root)().__s_iUID;
          Object.defineProperty(obj, "__get_m_iUID", {
            value: function() {
              return uid_1;
            }
          });
        }
        return obj.__get_m_iUID();
      } else if (obj === void 0)
        return -1;
      else
        return 0;
    }
    exports.get_uid = get_uid;
  }
});

// node_modules/tstl/functional/hash.js
var require_hash = __commonJS({
  "node_modules/tstl/functional/hash.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hash = void 0;
    var uid_1 = require_uid();
    function hash() {
      var e_1, _a;
      var itemList = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        itemList[_i] = arguments[_i];
      }
      var ret = INIT_VALUE;
      try {
        for (var itemList_1 = __values(itemList), itemList_1_1 = itemList_1.next(); !itemList_1_1.done; itemList_1_1 = itemList_1.next()) {
          var item = itemList_1_1.value;
          item = item ? item.valueOf() : item;
          var type = typeof item;
          if (type === "boolean")
            ret = _Hash_boolean(item, ret);
          else if (type === "number" || type === "bigint")
            ret = _Hash_number(item, ret);
          else if (type === "string")
            ret = _Hash_string(item, ret);
          else if (item instanceof Object && item.hashCode instanceof Function) {
            var hashed = item.hashCode();
            if (itemList.length === 1)
              return hashed;
            else {
              ret = ret ^ hashed;
              ret *= MULTIPLIER;
            }
          } else
            ret = _Hash_number((0, uid_1.get_uid)(item), ret);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (itemList_1_1 && !itemList_1_1.done && (_a = itemList_1.return)) _a.call(itemList_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return Math.abs(ret);
    }
    exports.hash = hash;
    function _Hash_boolean(val, ret) {
      ret ^= val ? 1 : 0;
      ret *= MULTIPLIER;
      return ret;
    }
    function _Hash_number(val, ret) {
      return _Hash_string(val.toString(), ret);
    }
    function _Hash_string(str, ret) {
      for (var i = 0; i < str.length; ++i) {
        ret ^= str.charCodeAt(i);
        ret *= MULTIPLIER;
      }
      return Math.abs(ret);
    }
    var INIT_VALUE = 2166136261;
    var MULTIPLIER = 16777619;
  }
});

// node_modules/tstl/functional/comparators.js
var require_comparators = __commonJS({
  "node_modules/tstl/functional/comparators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.greater_equal = exports.greater = exports.less_equal = exports.less = exports.not_equal_to = exports.equal_to = void 0;
    var uid_1 = require_uid();
    function equal_to(x, y) {
      x = x ? x.valueOf() : x;
      y = y ? y.valueOf() : y;
      if (x instanceof Object && x.equals instanceof Function)
        return x.equals(y);
      else
        return x === y;
    }
    exports.equal_to = equal_to;
    function not_equal_to(x, y) {
      return !equal_to(x, y);
    }
    exports.not_equal_to = not_equal_to;
    function less(x, y) {
      x = x.valueOf();
      y = y.valueOf();
      if (x instanceof Object)
        if (x.less instanceof Function)
          return x.less(y);
        else
          return (0, uid_1.get_uid)(x) < (0, uid_1.get_uid)(y);
      else
        return x < y;
    }
    exports.less = less;
    function less_equal(x, y) {
      return less(x, y) || equal_to(x, y);
    }
    exports.less_equal = less_equal;
    function greater(x, y) {
      return !less_equal(x, y);
    }
    exports.greater = greater;
    function greater_equal(x, y) {
      return !less(x, y);
    }
    exports.greater_equal = greater_equal;
  }
});

// node_modules/tstl/internal/container/associative/IHashContainer.js
var require_IHashContainer = __commonJS({
  "node_modules/tstl/internal/container/associative/IHashContainer.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHashContainer = void 0;
    var IAssociativeContainer_1 = require_IAssociativeContainer();
    var hash_1 = require_hash();
    var comparators_1 = require_comparators();
    var IHashContainer;
    (function(IHashContainer2) {
      function construct(source, Source, bucketFactory) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        var post_process = null;
        var hash_function = hash_1.hash;
        var key_eq = comparators_1.equal_to;
        if (args.length === 1 && args[0] instanceof Source) {
          var container_1 = args[0];
          hash_function = container_1.hash_function();
          key_eq = container_1.key_eq();
          post_process = function() {
            var first = container_1.begin();
            var last = container_1.end();
            source.assign(first, last);
          };
        } else {
          var tuple = IAssociativeContainer_1.IAssociativeContainer.construct.apply(IAssociativeContainer_1.IAssociativeContainer, __spreadArray([source], __read(args), false));
          post_process = tuple.ramda;
          if (tuple.tail.length >= 1)
            hash_function = tuple.tail[0];
          if (tuple.tail.length >= 2)
            key_eq = tuple.tail[1];
        }
        bucketFactory(hash_function, key_eq);
        if (post_process !== null)
          post_process();
      }
      IHashContainer2.construct = construct;
    })(IHashContainer = exports.IHashContainer || (exports.IHashContainer = {}));
  }
});

// node_modules/tstl/internal/iterator/ListIterator.js
var require_ListIterator = __commonJS({
  "node_modules/tstl/internal/iterator/ListIterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListIterator = void 0;
    var ErrorGenerator_1 = require_ErrorGenerator();
    var ListIterator = (
      /** @class */
      (function() {
        function ListIterator2(prev, next, value) {
          this.prev_ = prev;
          this.next_ = next;
          this.value_ = value;
        }
        ListIterator2._Set_prev = function(it, prev) {
          it.prev_ = prev;
        };
        ListIterator2._Set_next = function(it, next) {
          it.next_ = next;
        };
        ListIterator2.prototype.prev = function() {
          return this.prev_;
        };
        ListIterator2.prototype.next = function() {
          return this.next_;
        };
        Object.defineProperty(ListIterator2.prototype, "value", {
          /**
           * @inheritDoc
           */
          get: function() {
            this._Try_value();
            return this.value_;
          },
          enumerable: false,
          configurable: true
        });
        ListIterator2.prototype._Try_value = function() {
          if (this.value_ === void 0 && this.equals(this.source().end()) === true)
            throw ErrorGenerator_1.ErrorGenerator.iterator_end_value(this.source());
        };
        ListIterator2.prototype.equals = function(obj) {
          return this === obj;
        };
        return ListIterator2;
      })()
    );
    exports.ListIterator = ListIterator;
  }
});

// node_modules/tstl/internal/iterator/disposable/Repeater.js
var require_Repeater = __commonJS({
  "node_modules/tstl/internal/iterator/disposable/Repeater.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Repeater = void 0;
    var Repeater = (
      /** @class */
      (function() {
        function Repeater2(index, value) {
          this.index_ = index;
          this.value_ = value;
        }
        Repeater2.prototype.index = function() {
          return this.index_;
        };
        Object.defineProperty(Repeater2.prototype, "value", {
          get: function() {
            return this.value_;
          },
          enumerable: false,
          configurable: true
        });
        Repeater2.prototype.next = function() {
          ++this.index_;
          return this;
        };
        Repeater2.prototype.equals = function(obj) {
          return this.index_ === obj.index_;
        };
        return Repeater2;
      })()
    );
    exports.Repeater = Repeater;
  }
});

// node_modules/tstl/iterator/global.js
var require_global2 = __commonJS({
  "node_modules/tstl/iterator/global.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.next = exports.prev = exports.advance = exports.distance = exports.size = exports.empty = void 0;
    var InvalidArgument_1 = require_InvalidArgument();
    function empty(source) {
      if (source instanceof Array)
        return source.length !== 0;
      else
        return source.empty();
    }
    exports.empty = empty;
    function size(source) {
      if (source instanceof Array)
        return source.length;
      else
        return source.size();
    }
    exports.size = size;
    function distance(first, last) {
      if (first.index instanceof Function)
        return _Distance_via_index(first, last);
      var ret = 0;
      for (; !first.equals(last); first = first.next())
        ++ret;
      return ret;
    }
    exports.distance = distance;
    function _Distance_via_index(first, last) {
      var x = first.index();
      var y = last.index();
      if (first.base instanceof Function)
        return x - y;
      else
        return y - x;
    }
    function advance(it, n) {
      if (n === 0)
        return it;
      else if (it.advance instanceof Function)
        return it.advance(n);
      var stepper;
      if (n < 0) {
        if (!(it.prev instanceof Function))
          throw new InvalidArgument_1.InvalidArgument("Error on std.advance(): parametric iterator is not a bi-directional iterator, thus advancing to negative direction is not possible.");
        stepper = function(it2) {
          return it2.prev();
        };
        n = -n;
      } else
        stepper = function(it2) {
          return it2.next();
        };
      while (n-- > 0)
        it = stepper(it);
      return it;
    }
    exports.advance = advance;
    function prev(it, n) {
      if (n === void 0) {
        n = 1;
      }
      if (n === 1)
        return it.prev();
      else
        return advance(it, -n);
    }
    exports.prev = prev;
    function next(it, n) {
      if (n === void 0) {
        n = 1;
      }
      if (n === 1)
        return it.next();
      else
        return advance(it, n);
    }
    exports.next = next;
  }
});

// node_modules/tstl/internal/container/linear/ListContainer.js
var require_ListContainer = __commonJS({
  "node_modules/tstl/internal/container/linear/ListContainer.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListContainer = void 0;
    var Container_1 = require_Container();
    var ListIterator_1 = require_ListIterator();
    var Repeater_1 = require_Repeater();
    var NativeArrayIterator_1 = require_NativeArrayIterator();
    var global_1 = require_global2();
    var ErrorGenerator_1 = require_ErrorGenerator();
    var ListContainer = (
      /** @class */
      (function(_super) {
        __extends(ListContainer2, _super);
        function ListContainer2() {
          var _this = _super.call(this) || this;
          _this.end_ = _this._Create_iterator(null, null);
          _this.clear();
          return _this;
        }
        ListContainer2.prototype.assign = function(par1, par2) {
          this.clear();
          this.insert(this.end(), par1, par2);
        };
        ListContainer2.prototype.clear = function() {
          ListIterator_1.ListIterator._Set_prev(this.end_, this.end_);
          ListIterator_1.ListIterator._Set_next(this.end_, this.end_);
          this.begin_ = this.end_;
          this.size_ = 0;
        };
        ListContainer2.prototype.resize = function(n) {
          var expansion = n - this.size();
          if (expansion > 0)
            this.insert(this.end(), expansion, void 0);
          else if (expansion < 0)
            this.erase((0, global_1.advance)(this.end(), -expansion), this.end());
        };
        ListContainer2.prototype.begin = function() {
          return this.begin_;
        };
        ListContainer2.prototype.end = function() {
          return this.end_;
        };
        ListContainer2.prototype.size = function() {
          return this.size_;
        };
        ListContainer2.prototype.push_front = function(val) {
          this.insert(this.begin_, val);
        };
        ListContainer2.prototype.push_back = function(val) {
          this.insert(this.end_, val);
        };
        ListContainer2.prototype.pop_front = function() {
          if (this.empty() === true)
            throw ErrorGenerator_1.ErrorGenerator.empty(this.end_.source().constructor.name, "pop_front");
          this.erase(this.begin_);
        };
        ListContainer2.prototype.pop_back = function() {
          if (this.empty() === true)
            throw ErrorGenerator_1.ErrorGenerator.empty(this.end_.source().constructor.name, "pop_back");
          this.erase(this.end_.prev());
        };
        ListContainer2.prototype.push = function() {
          var items = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
          }
          if (items.length === 0)
            return this.size();
          var first = new NativeArrayIterator_1.NativeArrayIterator(items, 0);
          var last = new NativeArrayIterator_1.NativeArrayIterator(items, items.length);
          this._Insert_by_range(this.end(), first, last);
          return this.size();
        };
        ListContainer2.prototype.insert = function(pos) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          if (pos.source() !== this.end_.source())
            throw ErrorGenerator_1.ErrorGenerator.not_my_iterator(this.end_.source(), "insert");
          else if (pos.erased_ === true)
            throw ErrorGenerator_1.ErrorGenerator.erased_iterator(this.end_.source(), "insert");
          if (args.length === 1)
            return this._Insert_by_repeating_val(pos, 1, args[0]);
          else if (args.length === 2 && typeof args[0] === "number")
            return this._Insert_by_repeating_val(pos, args[0], args[1]);
          else
            return this._Insert_by_range(pos, args[0], args[1]);
        };
        ListContainer2.prototype._Insert_by_repeating_val = function(position, n, val) {
          var first = new Repeater_1.Repeater(0, val);
          var last = new Repeater_1.Repeater(n);
          return this._Insert_by_range(position, first, last);
        };
        ListContainer2.prototype._Insert_by_range = function(position, begin, end) {
          var prev = position.prev();
          var first = null;
          var size = 0;
          for (var it = begin; it.equals(end) === false; it = it.next()) {
            var item = this._Create_iterator(prev, null, it.value);
            if (size === 0)
              first = item;
            ListIterator_1.ListIterator._Set_next(prev, item);
            prev = item;
            ++size;
          }
          if (position.equals(this.begin()) === true)
            this.begin_ = first;
          ListIterator_1.ListIterator._Set_next(prev, position);
          ListIterator_1.ListIterator._Set_prev(position, prev);
          this.size_ += size;
          return first;
        };
        ListContainer2.prototype.erase = function(first, last) {
          if (last === void 0) {
            last = first.next();
          }
          return this._Erase_by_range(first, last);
        };
        ListContainer2.prototype._Erase_by_range = function(first, last) {
          if (first.source() !== this.end_.source())
            throw ErrorGenerator_1.ErrorGenerator.not_my_iterator(this.end_.source(), "insert");
          else if (first.erased_ === true)
            throw ErrorGenerator_1.ErrorGenerator.erased_iterator(this.end_.source(), "insert");
          else if (first.equals(this.end_))
            return this.end_;
          var prev = first.prev();
          ListIterator_1.ListIterator._Set_next(prev, last);
          ListIterator_1.ListIterator._Set_prev(last, prev);
          for (var it = first; !it.equals(last); it = it.next()) {
            it.erased_ = true;
            --this.size_;
          }
          if (first.equals(this.begin_))
            this.begin_ = last;
          return last;
        };
        ListContainer2.prototype.swap = function(obj) {
          var _a, _b, _c;
          _a = __read([obj.begin_, this.begin_], 2), this.begin_ = _a[0], obj.begin_ = _a[1];
          _b = __read([obj.end_, this.end_], 2), this.end_ = _b[0], obj.end_ = _b[1];
          _c = __read([obj.size_, this.size_], 2), this.size_ = _c[0], obj.size_ = _c[1];
        };
        return ListContainer2;
      })(Container_1.Container)
    );
    exports.ListContainer = ListContainer;
  }
});

// node_modules/tstl/internal/iterator/ReverseIterator.js
var require_ReverseIterator = __commonJS({
  "node_modules/tstl/internal/iterator/ReverseIterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReverseIterator = void 0;
    var ReverseIterator = (
      /** @class */
      (function() {
        function ReverseIterator2(base) {
          this.base_ = base.prev();
        }
        ReverseIterator2.prototype.source = function() {
          return this.base_.source();
        };
        ReverseIterator2.prototype.base = function() {
          return this.base_.next();
        };
        Object.defineProperty(ReverseIterator2.prototype, "value", {
          /**
           * @inheritDoc
           */
          get: function() {
            return this.base_.value;
          },
          enumerable: false,
          configurable: true
        });
        ReverseIterator2.prototype.prev = function() {
          return this._Create_neighbor(this.base().next());
        };
        ReverseIterator2.prototype.next = function() {
          return this._Create_neighbor(this.base_);
        };
        ReverseIterator2.prototype.equals = function(obj) {
          return this.base_.equals(obj.base_);
        };
        return ReverseIterator2;
      })()
    );
    exports.ReverseIterator = ReverseIterator;
  }
});

// node_modules/tstl/internal/container/associative/SetElementList.js
var require_SetElementList = __commonJS({
  "node_modules/tstl/internal/container/associative/SetElementList.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetElementList = void 0;
    var ListContainer_1 = require_ListContainer();
    var ListIterator_1 = require_ListIterator();
    var ReverseIterator_1 = require_ReverseIterator();
    var SetElementList = (
      /** @class */
      (function(_super) {
        __extends(SetElementList2, _super);
        function SetElementList2(associative) {
          var _this = _super.call(this) || this;
          _this.associative_ = associative;
          return _this;
        }
        SetElementList2.prototype._Create_iterator = function(prev, next, val) {
          return SetElementList2.Iterator.create(this, prev, next, val);
        };
        SetElementList2._Swap_associative = function(x, y) {
          var _a;
          _a = __read([y.associative_, x.associative_], 2), x.associative_ = _a[0], y.associative_ = _a[1];
        };
        SetElementList2.prototype.associative = function() {
          return this.associative_;
        };
        return SetElementList2;
      })(ListContainer_1.ListContainer)
    );
    exports.SetElementList = SetElementList;
    (function(SetElementList2) {
      var Iterator = (
        /** @class */
        (function(_super) {
          __extends(Iterator2, _super);
          function Iterator2(list, prev, next, val) {
            var _this = _super.call(this, prev, next, val) || this;
            _this.source_ = list;
            return _this;
          }
          Iterator2.create = function(list, prev, next, val) {
            return new Iterator2(list, prev, next, val);
          };
          Iterator2.prototype.reverse = function() {
            return new ReverseIterator(this);
          };
          Iterator2.prototype.source = function() {
            return this.source_.associative();
          };
          return Iterator2;
        })(ListIterator_1.ListIterator)
      );
      SetElementList2.Iterator = Iterator;
      var ReverseIterator = (
        /** @class */
        (function(_super) {
          __extends(ReverseIterator2, _super);
          function ReverseIterator2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          ReverseIterator2.prototype._Create_neighbor = function(base) {
            return new ReverseIterator2(base);
          };
          return ReverseIterator2;
        })(ReverseIterator_1.ReverseIterator)
      );
      SetElementList2.ReverseIterator = ReverseIterator;
    })(SetElementList = exports.SetElementList || (exports.SetElementList = {}));
    exports.SetElementList = SetElementList;
  }
});

// node_modules/tstl/internal/hash/HashBuckets.js
var require_HashBuckets = __commonJS({
  "node_modules/tstl/internal/hash/HashBuckets.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashBuckets = void 0;
    var HashBuckets = (
      /** @class */
      (function() {
        function HashBuckets2(fetcher, hasher) {
          this.fetcher_ = fetcher;
          this.hasher_ = hasher;
          this.max_load_factor_ = DEFAULT_MAX_FACTOR;
          this.data_ = [];
          this.size_ = 0;
          this.initialize();
        }
        HashBuckets2.prototype.clear = function() {
          this.data_ = [];
          this.size_ = 0;
          this.initialize();
        };
        HashBuckets2.prototype.rehash = function(length) {
          var e_1, _a, e_2, _b;
          length = Math.max(length, MIN_BUCKET_COUNT);
          var data = [];
          for (var i = 0; i < length; ++i)
            data.push([]);
          try {
            for (var _c = __values(this.data_), _d = _c.next(); !_d.done; _d = _c.next()) {
              var row = _d.value;
              try {
                for (var row_1 = (e_2 = void 0, __values(row)), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
                  var elem = row_1_1.value;
                  var index = this.hasher_(this.fetcher_(elem)) % data.length;
                  data[index].push(elem);
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (row_1_1 && !row_1_1.done && (_b = row_1.return)) _b.call(row_1);
                } finally {
                  if (e_2) throw e_2.error;
                }
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          this.data_ = data;
        };
        HashBuckets2.prototype.reserve = function(length) {
          if (length > this.capacity()) {
            length = Math.floor(length / this.max_load_factor_);
            this.rehash(length);
          }
        };
        HashBuckets2.prototype.initialize = function() {
          for (var i = 0; i < MIN_BUCKET_COUNT; ++i)
            this.data_.push([]);
        };
        HashBuckets2.prototype.length = function() {
          return this.data_.length;
        };
        HashBuckets2.prototype.capacity = function() {
          return this.data_.length * this.max_load_factor_;
        };
        HashBuckets2.prototype.at = function(index) {
          return this.data_[index];
        };
        HashBuckets2.prototype.load_factor = function() {
          return this.size_ / this.length();
        };
        HashBuckets2.prototype.max_load_factor = function(z) {
          if (z === void 0) {
            z = null;
          }
          if (z === null)
            return this.max_load_factor_;
          else
            this.max_load_factor_ = z;
        };
        HashBuckets2.prototype.hash_function = function() {
          return this.hasher_;
        };
        HashBuckets2.prototype.index = function(elem) {
          return this.hasher_(this.fetcher_(elem)) % this.length();
        };
        HashBuckets2.prototype.insert = function(val) {
          var capacity = this.capacity();
          if (++this.size_ > capacity)
            this.reserve(capacity * 2);
          var index = this.index(val);
          this.data_[index].push(val);
        };
        HashBuckets2.prototype.erase = function(val) {
          var index = this.index(val);
          var bucket = this.data_[index];
          for (var i = 0; i < bucket.length; ++i)
            if (bucket[i] === val) {
              bucket.splice(i, 1);
              --this.size_;
              break;
            }
        };
        return HashBuckets2;
      })()
    );
    exports.HashBuckets = HashBuckets;
    var MIN_BUCKET_COUNT = 10;
    var DEFAULT_MAX_FACTOR = 1;
  }
});

// node_modules/tstl/internal/hash/SetHashBuckets.js
var require_SetHashBuckets = __commonJS({
  "node_modules/tstl/internal/hash/SetHashBuckets.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetHashBuckets = void 0;
    var HashBuckets_1 = require_HashBuckets();
    var SetHashBuckets = (
      /** @class */
      (function(_super) {
        __extends(SetHashBuckets2, _super);
        function SetHashBuckets2(source, hasher, pred) {
          var _this = _super.call(this, fetcher, hasher) || this;
          _this.source_ = source;
          _this.key_eq_ = pred;
          return _this;
        }
        SetHashBuckets2._Swap_source = function(x, y) {
          var _a;
          _a = __read([y.source_, x.source_], 2), x.source_ = _a[0], y.source_ = _a[1];
        };
        SetHashBuckets2.prototype.key_eq = function() {
          return this.key_eq_;
        };
        SetHashBuckets2.prototype.find = function(val) {
          var e_1, _a;
          var index = this.hash_function()(val) % this.length();
          var bucket = this.at(index);
          try {
            for (var bucket_1 = __values(bucket), bucket_1_1 = bucket_1.next(); !bucket_1_1.done; bucket_1_1 = bucket_1.next()) {
              var it = bucket_1_1.value;
              if (this.key_eq_(it.value, val))
                return it;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (bucket_1_1 && !bucket_1_1.done && (_a = bucket_1.return)) _a.call(bucket_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return this.source_.end();
        };
        return SetHashBuckets2;
      })(HashBuckets_1.HashBuckets)
    );
    exports.SetHashBuckets = SetHashBuckets;
    function fetcher(elem) {
      return elem.value;
    }
  }
});

// node_modules/tstl/utility/Pair.js
var require_Pair = __commonJS({
  "node_modules/tstl/utility/Pair.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.make_pair = exports.Pair = void 0;
    var hash_1 = require_hash();
    var comparators_1 = require_comparators();
    var Pair = (
      /** @class */
      (function() {
        function Pair2(first, second) {
          this.first = first;
          this.second = second;
        }
        Pair2.prototype.equals = function(pair) {
          return (0, comparators_1.equal_to)(this.first, pair.first) && (0, comparators_1.equal_to)(this.second, pair.second);
        };
        Pair2.prototype.less = function(pair) {
          if ((0, comparators_1.equal_to)(this.first, pair.first) === false)
            return (0, comparators_1.less)(this.first, pair.first);
          else
            return (0, comparators_1.less)(this.second, pair.second);
        };
        Pair2.prototype.hashCode = function() {
          return (0, hash_1.hash)(this.first, this.second);
        };
        return Pair2;
      })()
    );
    exports.Pair = Pair;
    function make_pair(first, second) {
      return new Pair(first, second);
    }
    exports.make_pair = make_pair;
  }
});

// node_modules/tstl/container/HashSet.js
var require_HashSet = __commonJS({
  "node_modules/tstl/container/HashSet.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashSet = void 0;
    var UniqueSet_1 = require_UniqueSet();
    var IHashContainer_1 = require_IHashContainer();
    var SetElementList_1 = require_SetElementList();
    var SetHashBuckets_1 = require_SetHashBuckets();
    var Pair_1 = require_Pair();
    var HashSet = (
      /** @class */
      (function(_super) {
        __extends(HashSet2, _super);
        function HashSet2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = _super.call(this, function(thisArg) {
            return new SetElementList_1.SetElementList(thisArg);
          }) || this;
          IHashContainer_1.IHashContainer.construct.apply(IHashContainer_1.IHashContainer, __spreadArray([
            _this,
            HashSet2,
            function(hash, pred) {
              _this.buckets_ = new SetHashBuckets_1.SetHashBuckets(_this, hash, pred);
            }
          ], __read(args), false));
          return _this;
        }
        HashSet2.prototype.clear = function() {
          this.buckets_.clear();
          _super.prototype.clear.call(this);
        };
        HashSet2.prototype.swap = function(obj) {
          var _a, _b;
          _a = __read([obj.data_, this.data_], 2), this.data_ = _a[0], obj.data_ = _a[1];
          SetElementList_1.SetElementList._Swap_associative(this.data_, obj.data_);
          SetHashBuckets_1.SetHashBuckets._Swap_source(this.buckets_, obj.buckets_);
          _b = __read([obj.buckets_, this.buckets_], 2), this.buckets_ = _b[0], obj.buckets_ = _b[1];
        };
        HashSet2.prototype.find = function(key) {
          return this.buckets_.find(key);
        };
        HashSet2.prototype.begin = function(index) {
          if (index === void 0) {
            index = null;
          }
          if (index === null)
            return _super.prototype.begin.call(this);
          else
            return this.buckets_.at(index)[0];
        };
        HashSet2.prototype.end = function(index) {
          if (index === void 0) {
            index = null;
          }
          if (index === null)
            return _super.prototype.end.call(this);
          else {
            var bucket = this.buckets_.at(index);
            return bucket[bucket.length - 1].next();
          }
        };
        HashSet2.prototype.rbegin = function(index) {
          if (index === void 0) {
            index = null;
          }
          return this.end(index).reverse();
        };
        HashSet2.prototype.rend = function(index) {
          if (index === void 0) {
            index = null;
          }
          return this.begin(index).reverse();
        };
        HashSet2.prototype.bucket_count = function() {
          return this.buckets_.length();
        };
        HashSet2.prototype.bucket_size = function(n) {
          return this.buckets_.at(n).length;
        };
        HashSet2.prototype.load_factor = function() {
          return this.buckets_.load_factor();
        };
        HashSet2.prototype.hash_function = function() {
          return this.buckets_.hash_function();
        };
        HashSet2.prototype.key_eq = function() {
          return this.buckets_.key_eq();
        };
        HashSet2.prototype.bucket = function(key) {
          return this.hash_function()(key) % this.buckets_.length();
        };
        HashSet2.prototype.max_load_factor = function(z) {
          if (z === void 0) {
            z = null;
          }
          return this.buckets_.max_load_factor(z);
        };
        HashSet2.prototype.reserve = function(n) {
          this.buckets_.reserve(n);
        };
        HashSet2.prototype.rehash = function(n) {
          this.buckets_.rehash(n);
        };
        HashSet2.prototype._Insert_by_key = function(key) {
          var it = this.find(key);
          if (it.equals(this.end()) === false)
            return new Pair_1.Pair(it, false);
          this.data_.push(key);
          it = it.prev();
          this._Handle_insert(it, it.next());
          return new Pair_1.Pair(it, true);
        };
        HashSet2.prototype._Insert_by_hint = function(hint, key) {
          var it = this.find(key);
          if (it.equals(this.end()) === true) {
            it = this.data_.insert(hint, key);
            this._Handle_insert(it, it.next());
          }
          return it;
        };
        HashSet2.prototype._Handle_insert = function(first, last) {
          for (; !first.equals(last); first = first.next())
            this.buckets_.insert(first);
        };
        HashSet2.prototype._Handle_erase = function(first, last) {
          for (; !first.equals(last); first = first.next())
            this.buckets_.erase(first);
        };
        return HashSet2;
      })(UniqueSet_1.UniqueSet)
    );
    exports.HashSet = HashSet;
    (function(HashSet2) {
      HashSet2.Iterator = SetElementList_1.SetElementList.Iterator;
      HashSet2.ReverseIterator = SetElementList_1.SetElementList.ReverseIterator;
    })(HashSet = exports.HashSet || (exports.HashSet = {}));
    exports.HashSet = HashSet;
  }
});

// node_modules/tstl/base/container/MapContainer.js
var require_MapContainer = __commonJS({
  "node_modules/tstl/base/container/MapContainer.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapContainer = void 0;
    var Container_1 = require_Container();
    var NativeArrayIterator_1 = require_NativeArrayIterator();
    var MapContainer = (
      /** @class */
      (function(_super) {
        __extends(MapContainer2, _super);
        function MapContainer2(factory) {
          var _this = _super.call(this) || this;
          _this.data_ = factory(_this);
          return _this;
        }
        MapContainer2.prototype.assign = function(first, last) {
          this.clear();
          this.insert(first, last);
        };
        MapContainer2.prototype.clear = function() {
          this.data_.clear();
        };
        MapContainer2.prototype.begin = function() {
          return this.data_.begin();
        };
        MapContainer2.prototype.end = function() {
          return this.data_.end();
        };
        MapContainer2.prototype.has = function(key) {
          return !this.find(key).equals(this.end());
        };
        MapContainer2.prototype.size = function() {
          return this.data_.size();
        };
        MapContainer2.prototype.push = function() {
          var items = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
          }
          var first = new NativeArrayIterator_1.NativeArrayIterator(items, 0);
          var last = new NativeArrayIterator_1.NativeArrayIterator(items, items.length);
          this.insert(first, last);
          return this.size();
        };
        MapContainer2.prototype.insert = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (args.length === 1)
            return this.emplace(args[0].first, args[0].second);
          else if (args[0].next instanceof Function && args[1].next instanceof Function)
            return this._Insert_by_range(args[0], args[1]);
          else
            return this.emplace_hint(args[0], args[1].first, args[1].second);
        };
        MapContainer2.prototype.erase = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (args.length === 1 && (args[0] instanceof this.end().constructor === false || args[0].source() !== this))
            return this._Erase_by_key(args[0]);
          else if (args.length === 1)
            return this._Erase_by_range(args[0]);
          else
            return this._Erase_by_range(args[0], args[1]);
        };
        MapContainer2.prototype._Erase_by_range = function(first, last) {
          if (last === void 0) {
            last = first.next();
          }
          var it = this.data_.erase(first, last);
          this._Handle_erase(first, last);
          return it;
        };
        return MapContainer2;
      })(Container_1.Container)
    );
    exports.MapContainer = MapContainer;
  }
});

// node_modules/tstl/base/container/UniqueMap.js
var require_UniqueMap = __commonJS({
  "node_modules/tstl/base/container/UniqueMap.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UniqueMap = void 0;
    var MapContainer_1 = require_MapContainer();
    var ErrorGenerator_1 = require_ErrorGenerator();
    var UniqueMap = (
      /** @class */
      (function(_super) {
        __extends(UniqueMap2, _super);
        function UniqueMap2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        UniqueMap2.prototype.count = function(key) {
          return this.find(key).equals(this.end()) ? 0 : 1;
        };
        UniqueMap2.prototype.get = function(key) {
          var it = this.find(key);
          if (it.equals(this.end()) === true)
            throw ErrorGenerator_1.ErrorGenerator.key_nout_found(this, "get", key);
          return it.second;
        };
        UniqueMap2.prototype.take = function(key, generator) {
          var it = this.find(key);
          return it.equals(this.end()) ? this.emplace(key, generator()).first.second : it.second;
        };
        UniqueMap2.prototype.set = function(key, val) {
          this.insert_or_assign(key, val);
        };
        UniqueMap2.prototype.insert = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return _super.prototype.insert.apply(this, __spreadArray([], __read(args), false));
        };
        UniqueMap2.prototype._Insert_by_range = function(first, last) {
          for (var it = first; !it.equals(last); it = it.next())
            this.emplace(it.value.first, it.value.second);
        };
        UniqueMap2.prototype.insert_or_assign = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (args.length === 2) {
            return this._Insert_or_assign_with_key_value(args[0], args[1]);
          } else if (args.length === 3) {
            return this._Insert_or_assign_with_hint(args[0], args[1], args[2]);
          }
        };
        UniqueMap2.prototype._Insert_or_assign_with_key_value = function(key, value) {
          var ret = this.emplace(key, value);
          if (ret.second === false)
            ret.first.second = value;
          return ret;
        };
        UniqueMap2.prototype._Insert_or_assign_with_hint = function(hint, key, value) {
          var ret = this.emplace_hint(hint, key, value);
          if (ret.second !== value)
            ret.second = value;
          return ret;
        };
        UniqueMap2.prototype.extract = function(param) {
          if (param instanceof this.end().constructor)
            return this._Extract_by_iterator(param);
          else
            return this._Extract_by_key(param);
        };
        UniqueMap2.prototype._Extract_by_key = function(key) {
          var it = this.find(key);
          if (it.equals(this.end()) === true)
            throw ErrorGenerator_1.ErrorGenerator.key_nout_found(this, "extract", key);
          var ret = it.value;
          this._Erase_by_range(it);
          return ret;
        };
        UniqueMap2.prototype._Extract_by_iterator = function(it) {
          if (it.equals(this.end()) === true)
            return this.end();
          this._Erase_by_range(it);
          return it;
        };
        UniqueMap2.prototype._Erase_by_key = function(key) {
          var it = this.find(key);
          if (it.equals(this.end()) === true)
            return 0;
          this._Erase_by_range(it);
          return 1;
        };
        UniqueMap2.prototype.merge = function(source) {
          for (var it = source.begin(); !it.equals(source.end()); )
            if (this.has(it.first) === false) {
              this.insert(it.value);
              it = source.erase(it);
            } else
              it = it.next();
        };
        return UniqueMap2;
      })(MapContainer_1.MapContainer)
    );
    exports.UniqueMap = UniqueMap;
  }
});

// node_modules/tstl/internal/container/associative/MapElementList.js
var require_MapElementList = __commonJS({
  "node_modules/tstl/internal/container/associative/MapElementList.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapElementList = void 0;
    var ListContainer_1 = require_ListContainer();
    var ListIterator_1 = require_ListIterator();
    var ReverseIterator_1 = require_ReverseIterator();
    var MapElementList = (
      /** @class */
      (function(_super) {
        __extends(MapElementList2, _super);
        function MapElementList2(associative) {
          var _this = _super.call(this) || this;
          _this.associative_ = associative;
          return _this;
        }
        MapElementList2.prototype._Create_iterator = function(prev, next, val) {
          return MapElementList2.Iterator.create(this, prev, next, val);
        };
        MapElementList2._Swap_associative = function(x, y) {
          var _a;
          _a = __read([y.associative_, x.associative_], 2), x.associative_ = _a[0], y.associative_ = _a[1];
        };
        MapElementList2.prototype.associative = function() {
          return this.associative_;
        };
        return MapElementList2;
      })(ListContainer_1.ListContainer)
    );
    exports.MapElementList = MapElementList;
    (function(MapElementList2) {
      var Iterator = (
        /** @class */
        (function(_super) {
          __extends(Iterator2, _super);
          function Iterator2(list, prev, next, val) {
            var _this = _super.call(this, prev, next, val) || this;
            _this.list_ = list;
            return _this;
          }
          Iterator2.create = function(list, prev, next, val) {
            return new Iterator2(list, prev, next, val);
          };
          Iterator2.prototype.reverse = function() {
            return new ReverseIterator(this);
          };
          Iterator2.prototype.source = function() {
            return this.list_.associative();
          };
          Object.defineProperty(Iterator2.prototype, "first", {
            /**
             * @inheritDoc
             */
            get: function() {
              return this.value.first;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Iterator2.prototype, "second", {
            /**
             * @inheritDoc
             */
            get: function() {
              return this.value.second;
            },
            /**
             * @inheritDoc
             */
            set: function(val) {
              this.value.second = val;
            },
            enumerable: false,
            configurable: true
          });
          return Iterator2;
        })(ListIterator_1.ListIterator)
      );
      MapElementList2.Iterator = Iterator;
      var ReverseIterator = (
        /** @class */
        (function(_super) {
          __extends(ReverseIterator2, _super);
          function ReverseIterator2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          ReverseIterator2.prototype._Create_neighbor = function(base) {
            return new ReverseIterator2(base);
          };
          Object.defineProperty(ReverseIterator2.prototype, "first", {
            /* ---------------------------------------------------------
                ACCESSORS
            --------------------------------------------------------- */
            /**
             * Get the first, key element.
             *
             * @return The first element.
             */
            get: function() {
              return this.base_.first;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(ReverseIterator2.prototype, "second", {
            /**
             * Get the second, stored element.
             *
             * @return The second element.
             */
            get: function() {
              return this.base_.second;
            },
            /**
             * Set the second, stored element.
             *
             * @param val The value to set.
             */
            set: function(val) {
              this.base_.second = val;
            },
            enumerable: false,
            configurable: true
          });
          return ReverseIterator2;
        })(ReverseIterator_1.ReverseIterator)
      );
      MapElementList2.ReverseIterator = ReverseIterator;
    })(MapElementList = exports.MapElementList || (exports.MapElementList = {}));
    exports.MapElementList = MapElementList;
  }
});

// node_modules/tstl/internal/hash/MapHashBuckets.js
var require_MapHashBuckets = __commonJS({
  "node_modules/tstl/internal/hash/MapHashBuckets.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapHashBuckets = void 0;
    var HashBuckets_1 = require_HashBuckets();
    var MapHashBuckets = (
      /** @class */
      (function(_super) {
        __extends(MapHashBuckets2, _super);
        function MapHashBuckets2(source, hasher, pred) {
          var _this = _super.call(this, fetcher, hasher) || this;
          _this.source_ = source;
          _this.key_eq_ = pred;
          return _this;
        }
        MapHashBuckets2._Swap_source = function(x, y) {
          var _a;
          _a = __read([y.source_, x.source_], 2), x.source_ = _a[0], y.source_ = _a[1];
        };
        MapHashBuckets2.prototype.key_eq = function() {
          return this.key_eq_;
        };
        MapHashBuckets2.prototype.find = function(key) {
          var e_1, _a;
          var index = this.hash_function()(key) % this.length();
          var bucket = this.at(index);
          try {
            for (var bucket_1 = __values(bucket), bucket_1_1 = bucket_1.next(); !bucket_1_1.done; bucket_1_1 = bucket_1.next()) {
              var it = bucket_1_1.value;
              if (this.key_eq_(it.first, key))
                return it;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (bucket_1_1 && !bucket_1_1.done && (_a = bucket_1.return)) _a.call(bucket_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return this.source_.end();
        };
        return MapHashBuckets2;
      })(HashBuckets_1.HashBuckets)
    );
    exports.MapHashBuckets = MapHashBuckets;
    function fetcher(elem) {
      return elem.first;
    }
  }
});

// node_modules/tstl/utility/Entry.js
var require_Entry = __commonJS({
  "node_modules/tstl/utility/Entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Entry = void 0;
    var hash_1 = require_hash();
    var comparators_1 = require_comparators();
    var Entry = (
      /** @class */
      (function() {
        function Entry2(first, second) {
          this.first = first;
          this.second = second;
        }
        Entry2.prototype.equals = function(obj) {
          return (0, comparators_1.equal_to)(this.first, obj.first);
        };
        Entry2.prototype.less = function(obj) {
          return (0, comparators_1.less)(this.first, obj.first);
        };
        Entry2.prototype.hashCode = function() {
          return (0, hash_1.hash)(this.first);
        };
        return Entry2;
      })()
    );
    exports.Entry = Entry;
  }
});

// node_modules/tstl/container/HashMap.js
var require_HashMap = __commonJS({
  "node_modules/tstl/container/HashMap.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMap = void 0;
    var UniqueMap_1 = require_UniqueMap();
    var IHashContainer_1 = require_IHashContainer();
    var MapElementList_1 = require_MapElementList();
    var MapHashBuckets_1 = require_MapHashBuckets();
    var Entry_1 = require_Entry();
    var Pair_1 = require_Pair();
    var HashMap = (
      /** @class */
      (function(_super) {
        __extends(HashMap2, _super);
        function HashMap2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = _super.call(this, function(thisArg) {
            return new MapElementList_1.MapElementList(thisArg);
          }) || this;
          IHashContainer_1.IHashContainer.construct.apply(IHashContainer_1.IHashContainer, __spreadArray([
            _this,
            HashMap2,
            function(hash, pred) {
              _this.buckets_ = new MapHashBuckets_1.MapHashBuckets(_this, hash, pred);
            }
          ], __read(args), false));
          return _this;
        }
        HashMap2.prototype.clear = function() {
          this.buckets_.clear();
          _super.prototype.clear.call(this);
        };
        HashMap2.prototype.swap = function(obj) {
          var _a, _b;
          _a = __read([obj.data_, this.data_], 2), this.data_ = _a[0], obj.data_ = _a[1];
          MapElementList_1.MapElementList._Swap_associative(this.data_, obj.data_);
          MapHashBuckets_1.MapHashBuckets._Swap_source(this.buckets_, obj.buckets_);
          _b = __read([obj.buckets_, this.buckets_], 2), this.buckets_ = _b[0], obj.buckets_ = _b[1];
        };
        HashMap2.prototype.find = function(key) {
          return this.buckets_.find(key);
        };
        HashMap2.prototype.begin = function(index) {
          if (index === void 0) {
            index = null;
          }
          if (index === null)
            return _super.prototype.begin.call(this);
          else
            return this.buckets_.at(index)[0];
        };
        HashMap2.prototype.end = function(index) {
          if (index === void 0) {
            index = null;
          }
          if (index === null)
            return _super.prototype.end.call(this);
          else {
            var bucket = this.buckets_.at(index);
            return bucket[bucket.length - 1].next();
          }
        };
        HashMap2.prototype.rbegin = function(index) {
          if (index === void 0) {
            index = null;
          }
          return this.end(index).reverse();
        };
        HashMap2.prototype.rend = function(index) {
          if (index === void 0) {
            index = null;
          }
          return this.begin(index).reverse();
        };
        HashMap2.prototype.bucket_count = function() {
          return this.buckets_.length();
        };
        HashMap2.prototype.bucket_size = function(index) {
          return this.buckets_.at(index).length;
        };
        HashMap2.prototype.load_factor = function() {
          return this.buckets_.load_factor();
        };
        HashMap2.prototype.hash_function = function() {
          return this.buckets_.hash_function();
        };
        HashMap2.prototype.key_eq = function() {
          return this.buckets_.key_eq();
        };
        HashMap2.prototype.bucket = function(key) {
          return this.hash_function()(key) % this.buckets_.length();
        };
        HashMap2.prototype.max_load_factor = function(z) {
          if (z === void 0) {
            z = null;
          }
          return this.buckets_.max_load_factor(z);
        };
        HashMap2.prototype.reserve = function(n) {
          this.buckets_.reserve(n);
        };
        HashMap2.prototype.rehash = function(n) {
          this.buckets_.rehash(n);
        };
        HashMap2.prototype.emplace = function(key, val) {
          var it = this.find(key);
          if (it.equals(this.end()) === false)
            return new Pair_1.Pair(it, false);
          this.data_.push(new Entry_1.Entry(key, val));
          it = it.prev();
          this._Handle_insert(it, it.next());
          return new Pair_1.Pair(it, true);
        };
        HashMap2.prototype.emplace_hint = function(hint, key, val) {
          var it = this.find(key);
          if (it.equals(this.end()) === true) {
            it = this.data_.insert(hint, new Entry_1.Entry(key, val));
            this._Handle_insert(it, it.next());
          }
          return it;
        };
        HashMap2.prototype._Handle_insert = function(first, last) {
          for (; !first.equals(last); first = first.next())
            this.buckets_.insert(first);
        };
        HashMap2.prototype._Handle_erase = function(first, last) {
          for (; !first.equals(last); first = first.next())
            this.buckets_.erase(first);
        };
        return HashMap2;
      })(UniqueMap_1.UniqueMap)
    );
    exports.HashMap = HashMap;
    (function(HashMap2) {
      HashMap2.Iterator = MapElementList_1.MapElementList.Iterator;
      HashMap2.ReverseIterator = MapElementList_1.MapElementList.ReverseIterator;
    })(HashMap = exports.HashMap || (exports.HashMap = {}));
    exports.HashMap = HashMap;
  }
});

// node_modules/websocket-polyfill/lib/events/EventTarget.js
var require_EventTarget = __commonJS({
  "node_modules/websocket-polyfill/lib/events/EventTarget.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
      if (m) return m.call(o);
      return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var HashSet_1 = require_HashSet();
    var HashMap_1 = require_HashMap();
    var EventTarget = (
      /** @class */
      (function() {
        function EventTarget2() {
          this.listeners_ = new HashMap_1.HashMap();
          this.created_at_ = /* @__PURE__ */ new Date();
        }
        EventTarget2.prototype.dispatchEvent = function(event2) {
          var e_1, _a;
          var it = this.listeners_.find(event2.type);
          if (it.equals(this.listeners_.end()))
            return;
          event2.target = this;
          event2.timeStamp = (/* @__PURE__ */ new Date()).getTime() - this.created_at_.getTime();
          try {
            for (var _b = __values(it.second), _c = _b.next(); !_c.done; _c = _b.next()) {
              var listener = _c.value;
              listener(event2);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        };
        EventTarget2.prototype.addEventListener = function(type, listener) {
          var it = this.listeners_.find(type);
          if (it.equals(this.listeners_.end()))
            it = this.listeners_.emplace(type, new HashSet_1.HashSet()).first;
          it.second.insert(listener);
        };
        EventTarget2.prototype.removeEventListener = function(type, listener) {
          var it = this.listeners_.find(type);
          if (it.equals(this.listeners_.end()))
            return;
          it.second.erase(listener);
          if (it.second.empty())
            this.listeners_.erase(it);
        };
        return EventTarget2;
      })()
    );
    exports.EventTarget = EventTarget;
  }
});

// node_modules/websocket-polyfill/lib/events/Event.js
var require_Event = __commonJS({
  "node_modules/websocket-polyfill/lib/events/Event.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Event = (
      /** @class */
      /* @__PURE__ */ (function() {
        function Event2(type, init) {
          this.type = type;
          if (init)
            Object.assign(this, init);
        }
        return Event2;
      })()
    );
    exports.Event = Event;
  }
});

// node_modules/websocket-polyfill/lib/events/CloseEvent.js
var require_CloseEvent = __commonJS({
  "node_modules/websocket-polyfill/lib/events/CloseEvent.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var Event_1 = require_Event();
    var CloseEvent = (
      /** @class */
      (function(_super) {
        __extends(CloseEvent2, _super);
        function CloseEvent2(type, init) {
          return _super.call(this, type, init) || this;
        }
        return CloseEvent2;
      })(Event_1.Event)
    );
    exports.CloseEvent = CloseEvent;
  }
});

// node_modules/websocket-polyfill/lib/events/MessageEvent.js
var require_MessageEvent = __commonJS({
  "node_modules/websocket-polyfill/lib/events/MessageEvent.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var Event_1 = require_Event();
    var MessageEvent = (
      /** @class */
      (function(_super) {
        __extends(MessageEvent2, _super);
        function MessageEvent2(type, init) {
          return _super.call(this, type, init) || this;
        }
        return MessageEvent2;
      })(Event_1.Event)
    );
    exports.MessageEvent = MessageEvent;
  }
});

// node_modules/websocket-polyfill/lib/events/ErrorEvent.js
var require_ErrorEvent = __commonJS({
  "node_modules/websocket-polyfill/lib/events/ErrorEvent.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var Event_1 = require_Event();
    var ErrorEvent = (
      /** @class */
      (function(_super) {
        __extends(ErrorEvent2, _super);
        function ErrorEvent2(type, init) {
          return _super.call(this, type, init) || this;
        }
        return ErrorEvent2;
      })(Event_1.Event)
    );
    exports.ErrorEvent = ErrorEvent;
  }
});

// node_modules/websocket-polyfill/lib/WebSocket.js
var require_WebSocket = __commonJS({
  "node_modules/websocket-polyfill/lib/WebSocket.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var websocket_1 = require_browser();
    var EventTarget_1 = require_EventTarget();
    var Event_1 = require_Event();
    var CloseEvent_1 = require_CloseEvent();
    var MessageEvent_1 = require_MessageEvent();
    var ErrorEvent_1 = require_ErrorEvent();
    var WebSocket = (
      /** @class */
      (function(_super) {
        __extends(WebSocket2, _super);
        function WebSocket2(url, protocols) {
          var _this = _super.call(this) || this;
          _this.on_ = {};
          _this.state_ = WebSocket2.CONNECTING;
          _this.client_ = new websocket_1.client();
          _this.client_.on("connect", _this._Handle_connect.bind(_this));
          _this.client_.on("connectFailed", _this._Handle_error.bind(_this));
          if (typeof protocols === "string")
            protocols = [protocols];
          _this.client_.connect(url, protocols);
          return _this;
        }
        WebSocket2.prototype.close = function(code, reason) {
          this.state_ = WebSocket2.CLOSING;
          if (code === void 0)
            this.connection_.sendCloseFrame();
          else
            this.connection_.sendCloseFrame(code, reason, true);
        };
        WebSocket2.prototype.send = function(data) {
          if (typeof data.valueOf() === "string")
            this.connection_.sendUTF(data);
          else {
            var buffer = void 0;
            if (data instanceof Buffer)
              buffer = data;
            else if (data instanceof Blob)
              buffer = new Buffer(data, "blob");
            else if (data.buffer)
              buffer = new Buffer(data.buffer);
            else
              buffer = new Buffer(data);
            this.connection_.sendBytes(buffer);
          }
        };
        Object.defineProperty(WebSocket2.prototype, "url", {
          /* ----------------------------------------------------------------
              PROPERTIES
          ---------------------------------------------------------------- */
          get: function() {
            return this.client_.url.href;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(WebSocket2.prototype, "protocol", {
          get: function() {
            return this.client_.protocols ? this.client_.protocols[0] : "";
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(WebSocket2.prototype, "extensions", {
          get: function() {
            return this.connection_ && this.connection_.extensions ? this.connection_.extensions[0].name : "";
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(WebSocket2.prototype, "readyState", {
          get: function() {
            return this.state_;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(WebSocket2.prototype, "bufferedAmount", {
          get: function() {
            return this.connection_.bytesWaitingToFlush;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(WebSocket2.prototype, "binaryType", {
          get: function() {
            return "arraybuffer";
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(WebSocket2.prototype, "onopen", {
          /* ----------------------------------------------------------------
              LISTENERS
          ---------------------------------------------------------------- */
          get: function() {
            return this.on_.open;
          },
          set: function(listener) {
            this._Set_on("open", listener);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(WebSocket2.prototype, "onclose", {
          get: function() {
            return this.on_.close;
          },
          set: function(listener) {
            this._Set_on("close", listener);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(WebSocket2.prototype, "onmessage", {
          get: function() {
            return this.on_.message;
          },
          set: function(listener) {
            this._Set_on("message", listener);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(WebSocket2.prototype, "onerror", {
          get: function() {
            return this.on_.error;
          },
          set: function(listener) {
            this._Set_on("error", listener);
          },
          enumerable: true,
          configurable: true
        });
        WebSocket2.prototype._Set_on = function(type, listener) {
          if (this.on_[type])
            this.removeEventListener(type, this.on_[type]);
          this.addEventListener(type, listener);
          this.on_[type] = listener;
        };
        WebSocket2.prototype._Handle_connect = function(connection) {
          this.connection_ = connection;
          this.state_ = WebSocket2.OPEN;
          this.connection_.on("message", this._Handle_message.bind(this));
          this.connection_.on("error", this._Handle_error.bind(this));
          this.connection_.on("close", this._Handle_close.bind(this));
          var event2 = new Event_1.Event("open", EVENT_INIT);
          this.dispatchEvent(event2);
        };
        WebSocket2.prototype._Handle_close = function(code, reason) {
          var event2 = new CloseEvent_1.CloseEvent("close", __assign({}, EVENT_INIT, { code, reason }));
          this.state_ = WebSocket2.CLOSED;
          this.dispatchEvent(event2);
        };
        WebSocket2.prototype._Handle_message = function(message) {
          var event2 = new MessageEvent_1.MessageEvent("message", __assign({}, EVENT_INIT, { data: message.binaryData ? message.binaryData : message.utf8Data }));
          this.dispatchEvent(event2);
        };
        WebSocket2.prototype._Handle_error = function(error) {
          var event2 = new ErrorEvent_1.ErrorEvent("error", __assign({}, EVENT_INIT, { error, message: error.message }));
          if (this.state_ === WebSocket2.CONNECTING)
            this.state_ = WebSocket2.CLOSED;
          this.dispatchEvent(event2);
        };
        return WebSocket2;
      })(EventTarget_1.EventTarget)
    );
    exports.WebSocket = WebSocket;
    (function(WebSocket2) {
      WebSocket2.CONNECTING = 0;
      WebSocket2.OPEN = 1;
      WebSocket2.CLOSING = 2;
      WebSocket2.CLOSED = 3;
    })(WebSocket = exports.WebSocket || (exports.WebSocket = {}));
    exports.WebSocket = WebSocket;
    var EVENT_INIT = {
      bubbles: false,
      cancelable: false
    };
  }
});

// node_modules/websocket-polyfill/lib/index.js
var require_lib = __commonJS({
  "node_modules/websocket-polyfill/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var node_1 = require_node();
    if (node_1.is_node())
      global.WebSocket = require_WebSocket().WebSocket;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module.exports = EventEmitter2;
    module.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS2 = CryptoJS2 || (function(Math2, undefined2) {
        var crypto3;
        if (typeof window !== "undefined" && window.crypto) {
          crypto3 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto3 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto3 = globalThis.crypto;
        }
        if (!crypto3 && typeof window !== "undefined" && window.msCrypto) {
          crypto3 = window.msCrypto;
        }
        if (!crypto3 && typeof global !== "undefined" && global.crypto) {
          crypto3 = global.crypto;
        }
        if (!crypto3 && typeof __require === "function") {
          try {
            crypto3 = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto3) {
            if (typeof crypto3.getRandomValues === "function") {
              try {
                return crypto3.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto3.randomBytes === "function") {
              try {
                return crypto3.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ (function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        })();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = /* @__PURE__ */ (function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        })();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      })(Math);
      return CryptoJS2;
    });
  }
});

// node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/crypto-js/x64-core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
              words[i] = words[i].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS2;
    });
  }
});

// node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS2.lib.WordArray;
    });
  }
});

// node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/crypto-js/enc-utf16.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS2.enc.Utf16;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64;
    });
  }
});

// node_modules/crypto-js/enc-base64url.js
var require_enc_base64url = __commonJS({
  "node_modules/crypto-js/enc-base64url.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64url = C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64url;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS2.MD5;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              if (i < 20) {
                t += (b & c | ~b & d) + 1518500249;
              } else if (i < 40) {
                t += (b ^ c ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b & c | b & d | c & d) - 1894007588;
              } else {
                t += (b ^ c ^ d) - 899497514;
              }
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS2.SHA1;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA2562 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA2562);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA2562);
      })(Math);
      return CryptoJS2.SHA256;
    });
  }
});

// node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/crypto-js/sha224.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA2562 = C_algo.SHA256;
        var SHA2242 = C_algo.SHA224 = SHA2562.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA2562._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA2562._createHelper(SHA2242);
        C.HmacSHA224 = SHA2562._createHmacHelper(SHA2242);
      })();
      return CryptoJS2.SHA224;
    });
  }
});

// node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/crypto-js/sha512.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
          }
        })();
        var SHA5122 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wil;
              var Wih;
              var Wi = W[i];
              if (i < 16) {
                Wih = Wi.high = M[offset + i * 2] | 0;
                Wil = Wi.low = M[offset + i * 2 + 1] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA5122);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA5122);
      })();
      return CryptoJS2.SHA512;
    });
  }
});

// node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/crypto-js/sha384.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA5122 = C_algo.SHA512;
        var SHA3842 = C_algo.SHA384 = SHA5122.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA5122._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA5122._createHelper(SHA3842);
        C.HmacSHA384 = SHA5122._createHmacHelper(SHA3842);
      })();
      return CryptoJS2.SHA384;
    });
  }
});

// node_modules/crypto-js/sha3.js
var require_sha3 = __commonJS({
  "node_modules/crypto-js/sha3.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) {
              state[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state[i] = state[i].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS2.SHA3;
    });
  }
});

// node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/crypto-js/ripemd160.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al + M[offset + zl[i]] | 0;
              if (i < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t += f2(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t += f4(bl, cl, dl) + hl[3];
              } else {
                t += f5(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl2(t, sl[i]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl2(cl, 10);
              cl = bl;
              bl = t;
              t = ar + M[offset + zr[i]] | 0;
              if (i < 16) {
                t += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t += f2(br, cr, dr) + hr[3];
              } else {
                t += f1(br, cr, dr) + hr[4];
              }
              t = t | 0;
              t = rotl2(t, sr[i]);
              t = t + er | 0;
              ar = er;
              er = dr;
              dr = rotl2(cr, 10);
              cr = br;
              br = t;
            }
            t = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z) {
          return x ^ y ^ z;
        }
        function f2(x, y, z) {
          return x & y | ~x & z;
        }
        function f3(x, y, z) {
          return (x | ~y) ^ z;
        }
        function f4(x, y, z) {
          return x & z | y & ~z;
        }
        function f5(x, y, z) {
          return x ^ (y | ~z);
        }
        function rotl2(x, n) {
          return x << n | x >>> 32 - n;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS2.RIPEMD160;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC2 = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac2;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/crypto-js/pbkdf2.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA2562 = C_algo.SHA256;
        var HMAC2 = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA2562,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac2 = HMAC2.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac2.update(salt).finalize(blockIndex);
              hmac2.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac2.finalize(intermediate);
                hmac2.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.PBKDF2;
    });
  }
});

// node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/crypto-js/evpkdf.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.EvpKDF;
    });
  }
});

// node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/crypto-js/cipher-core.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.lib.Cipher || (function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ (function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          })()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = (function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= block[i];
            }
          }
          return CBC2;
        })();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }
            var padding2 = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding2);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding2 = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding2.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding2.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/crypto-js/mode-cfb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CFB = (function() {
        var CFB = CryptoJS2.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
          }
        }
        return CFB;
      })();
      return CryptoJS2.mode.CFB;
    });
  }
});

// node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/crypto-js/mode-ctr.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CTR = (function() {
        var CTR = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      })();
      return CryptoJS2.mode.CTR;
    });
  }
});

// node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CTRGladman = (function() {
        var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      })();
      return CryptoJS2.mode.CTRGladman;
    });
  }
});

// node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/crypto-js/mode-ofb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.OFB = (function() {
        var OFB = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      })();
      return CryptoJS2.mode.OFB;
    });
  }
});

// node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/crypto-js/mode-ecb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.ECB = (function() {
        var ECB = CryptoJS2.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      })();
      return CryptoJS2.mode.ECB;
    });
  }
});

// node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Ansix923;
    });
  }
});

// node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Iso10126;
    });
  }
});

// node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
          CryptoJS2.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS2.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS2.pad.Iso97971;
    });
  }
});

// node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          for (var i = data.sigBytes - 1; i >= 0; i--) {
            if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
              data.sigBytes = i + 1;
              break;
            }
          }
        }
      };
      return CryptoJS2.pad.ZeroPadding;
    });
  }
});

// node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS2.pad.NoPadding;
    });
  }
});

// node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/crypto-js/format-hex.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS2.format.Hex;
    });
  }
});

// node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/crypto-js/aes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x] = t << 24 | t >>> 8;
            SUB_MIX_1[x] = t << 16 | t >>> 16;
            SUB_MIX_2[x] = t << 8 | t >>> 24;
            SUB_MIX_3[x] = t;
            var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t = t << 8 | t >>> 24;
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS2.AES;
    });
  }
});

// node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/crypto-js/tripledes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) {
                subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
              invSubKeys[i] = subKeys[15 - i];
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f = 0;
              for (var i = 0; i < 8; i++) {
                f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS2.TripleDES;
    });
  }
});

// node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/crypto-js/rc4.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i = 0; i < 256; i++) {
              S[i] = i;
            }
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;
            var t = S[i];
            S[i] = S[j];
            S[j] = t;
            keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
          }
          this._i = i;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS2.RC4;
    });
  }
});

// node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/crypto-js/rabbit.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) {
              K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS2.Rabbit;
    });
  }
});

// node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS2.RabbitLegacy;
    });
  }
});

// node_modules/crypto-js/blowfish.js
var require_blowfish = __commonJS({
  "node_modules/crypto-js/blowfish.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        const N = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F(ctx, x) {
          let a = x >> 24 & 255;
          let b = x >> 16 & 255;
          let c = x >> 8 & 255;
          let d = x & 255;
          let y = ctx.sbox[0][a] + ctx.sbox[1][b];
          y = y ^ ctx.sbox[2][c];
          y = y + ctx.sbox[3][d];
          return y;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i = 0; i < N; ++i) {
            Xl = Xl ^ ctx.pbox[i];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[N];
          Xl = Xl ^ ctx.pbox[N + 1];
          return { left: Xl, right: Xr };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i = N + 1; i > 1; --i) {
            Xl = Xl ^ ctx.pbox[i];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr };
        }
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index = 0; index < N + 2; index++) {
            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i = 0; i < N + 2; i += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i] = Data1;
            ctx.pbox[i + 1] = Data2;
          }
          for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 256; j += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i][j] = Data1;
              ctx.sbox[i][j + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M, offset) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
            M[offset] = res.left;
            M[offset + 1] = res.right;
          },
          decryptBlock: function(M, offset) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
            M[offset] = res.left;
            M[offset + 1] = res.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS2.Blowfish;
    });
  }
});

// node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/crypto-js/index.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy(), require_blowfish());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      return CryptoJS2;
    });
  }
});

// node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
    function assertNumber(n) {
      if (!Number.isSafeInteger(n))
        throw new Error(`Wrong integer: ${n}`);
    }
    exports.assertNumber = assertNumber;
    function chain2(...args) {
      const wrap = (a, b) => (c) => a(b(c));
      const encode = Array.from(args).reverse().reduce((acc, i) => acc ? wrap(acc, i.encode) : i.encode, void 0);
      const decode3 = args.reduce((acc, i) => acc ? wrap(acc, i.decode) : i.decode, void 0);
      return { encode, decode: decode3 };
    }
    function alphabet2(alphabet3) {
      return {
        encode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("alphabet.encode input should be an array of numbers");
          return digits.map((i) => {
            assertNumber(i);
            if (i < 0 || i >= alphabet3.length)
              throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet3.length})`);
            return alphabet3[i];
          });
        },
        decode: (input) => {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("alphabet.decode input should be array of strings");
          return input.map((letter) => {
            if (typeof letter !== "string")
              throw new Error(`alphabet.decode: not string element=${letter}`);
            const index = alphabet3.indexOf(letter);
            if (index === -1)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet3}`);
            return index;
          });
        }
      };
    }
    function join2(separator = "") {
      if (typeof separator !== "string")
        throw new Error("join separator should be string");
      return {
        encode: (from) => {
          if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
            throw new Error("join.encode input should be array of strings");
          for (let i of from)
            if (typeof i !== "string")
              throw new Error(`join.encode: non-string input=${i}`);
          return from.join(separator);
        },
        decode: (to) => {
          if (typeof to !== "string")
            throw new Error("join.decode input should be string");
          return to.split(separator);
        }
      };
    }
    function padding2(bits, chr = "=") {
      assertNumber(bits);
      if (typeof chr !== "string")
        throw new Error("padding chr should be string");
      return {
        encode(data) {
          if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i of data)
            if (typeof i !== "string")
              throw new Error(`padding.encode: non-string input=${i}`);
          while (data.length * bits % 8)
            data.push(chr);
          return data;
        },
        decode(input) {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i of input)
            if (typeof i !== "string")
              throw new Error(`padding.decode: non-string input=${i}`);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("Invalid padding: string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            if (!((end - 1) * bits % 8))
              throw new Error("Invalid padding: string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    function normalize2(fn) {
      if (typeof fn !== "function")
        throw new Error("normalize fn should be function");
      return { encode: (from) => from, decode: (to) => fn(to) };
    }
    function convertRadix3(data, from, to) {
      if (from < 2)
        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
      if (!Array.isArray(data))
        throw new Error("convertRadix: data should be array");
      if (!data.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data);
      digits.forEach((d) => {
        assertNumber(d);
        if (d < 0 || d >= from)
          throw new Error(`Wrong integer: ${d}`);
      });
      while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < digits.length; i++) {
          const digit = digits[i];
          const digitBase = from * carry + digit;
          if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
            throw new Error("convertRadix: carry overflow");
          }
          carry = digitBase % to;
          digits[i] = Math.floor(digitBase / to);
          if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!digits[i])
            pos = i;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
      return res.reverse();
    }
    var gcd2 = (a, b) => !b ? a : gcd2(b, a % b);
    var radix2carry2 = (from, to) => from + (to - gcd2(from, to));
    function convertRadix22(data, from, to, padding3) {
      if (!Array.isArray(data))
        throw new Error("convertRadix2: data should be array");
      if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
      if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
      if (radix2carry2(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry2(from, to)}`);
      }
      let carry = 0;
      let pos = 0;
      const mask = 2 ** to - 1;
      const res = [];
      for (const n of data) {
        assertNumber(n);
        if (n >= 2 ** from)
          throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
          res.push((carry >> pos - to & mask) >>> 0);
        carry &= 2 ** pos - 1;
      }
      carry = carry << to - pos & mask;
      if (!padding3 && pos >= from)
        throw new Error("Excess padding");
      if (!padding3 && carry)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding3 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    function radix3(num2) {
      assertNumber(num2);
      return {
        encode: (bytes2) => {
          if (!(bytes2 instanceof Uint8Array))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix3(Array.from(bytes2), 2 ** 8, num2);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix.decode input should be array of strings");
          return Uint8Array.from(convertRadix3(digits, num2, 2 ** 8));
        }
      };
    }
    function radix22(bits, revPadding = false) {
      assertNumber(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (radix2carry2(8, bits) > 32 || radix2carry2(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes2) => {
          if (!(bytes2 instanceof Uint8Array))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix22(Array.from(bytes2), 8, bits, !revPadding);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix2.decode input should be array of strings");
          return Uint8Array.from(convertRadix22(digits, bits, 8, revPadding));
        }
      };
    }
    function unsafeWrapper2(fn) {
      if (typeof fn !== "function")
        throw new Error("unsafeWrapper fn should be function");
      return function(...args) {
        try {
          return fn.apply(null, args);
        } catch (e) {
        }
      };
    }
    function checksum(len, fn) {
      assertNumber(len);
      if (typeof fn !== "function")
        throw new Error("checksum fn should be function");
      return {
        encode(data) {
          if (!(data instanceof Uint8Array))
            throw new Error("checksum.encode: input should be Uint8Array");
          const checksum2 = fn(data).slice(0, len);
          const res = new Uint8Array(data.length + len);
          res.set(data);
          res.set(checksum2, data.length);
          return res;
        },
        decode(data) {
          if (!(data instanceof Uint8Array))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data.slice(0, -len);
          const newChecksum = fn(payload).slice(0, len);
          const oldChecksum = data.slice(-len);
          for (let i = 0; i < len; i++)
            if (newChecksum[i] !== oldChecksum[i])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    exports.utils = { alphabet: alphabet2, chain: chain2, checksum, radix: radix3, radix2: radix22, join: join2, padding: padding2 };
    exports.base16 = chain2(radix22(4), alphabet2("0123456789ABCDEF"), join2(""));
    exports.base32 = chain2(radix22(5), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding2(5), join2(""));
    exports.base32hex = chain2(radix22(5), alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding2(5), join2(""));
    exports.base32crockford = chain2(radix22(5), alphabet2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join2(""), normalize2((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    exports.base64 = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding2(6), join2(""));
    exports.base64url = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding2(6), join2(""));
    var genBase582 = (abc) => chain2(radix3(58), alphabet2(abc), join2(""));
    exports.base58 = genBase582("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.base58flickr = genBase582("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    exports.base58xrp = genBase582("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports.base58xmr = {
      encode(data) {
        let res = "";
        for (let i = 0; i < data.length; i += 8) {
          const block = data.subarray(i, i + 8);
          res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
        }
        return res;
      },
      decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
          const slice = str.slice(i, i + 11);
          const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
          const block = exports.base58.decode(slice);
          for (let j = 0; j < block.length - blockLen; j++) {
            if (block[j] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    var base58check = (sha2562) => chain2(checksum(4, (data) => sha2562(sha2562(data))), exports.base58);
    exports.base58check = base58check;
    var BECH_ALPHABET2 = chain2(alphabet2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join2(""));
    var POLYMOD_GENERATORS2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function bech32Polymod2(pre) {
      const b = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i = 0; i < POLYMOD_GENERATORS2.length; i++) {
        if ((b >> i & 1) === 1)
          chk ^= POLYMOD_GENERATORS2[i];
      }
      return chk;
    }
    function bechChecksum2(prefix, words, encodingConst = 1) {
      const len = prefix.length;
      let chk = 1;
      for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
          throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod2(chk) ^ c >> 5;
      }
      chk = bech32Polymod2(chk);
      for (let i = 0; i < len; i++)
        chk = bech32Polymod2(chk) ^ prefix.charCodeAt(i) & 31;
      for (let v of words)
        chk = bech32Polymod2(chk) ^ v;
      for (let i = 0; i < 6; i++)
        chk = bech32Polymod2(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET2.encode(convertRadix22([chk % 2 ** 30], 30, 5, false));
    }
    function genBech322(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = radix22(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper2(fromWords);
      function encode(prefix, words, limit = 90) {
        if (typeof prefix !== "string")
          throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
          throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        prefix = prefix.toLowerCase();
        return `${prefix}1${BECH_ALPHABET2.encode(words)}${bechChecksum2(prefix, words, ENCODING_CONST)}`;
      }
      function decode3(str, limit = 90) {
        if (typeof str !== "string")
          throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || limit !== false && str.length > limit)
          throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words2 = str.slice(sepIndex + 1);
        if (_words2.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET2.decode(_words2).slice(0, -6);
        const sum = bechChecksum2(prefix, words, ENCODING_CONST);
        if (!_words2.endsWith(sum))
          throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
      }
      const decodeUnsafe = unsafeWrapper2(decode3);
      function decodeToBytes(str) {
        const { prefix, words } = decode3(str, false);
        return { prefix, words, bytes: fromWords(words) };
      }
      return { encode, decode: decode3, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
    }
    exports.bech32 = genBech322("bech32");
    exports.bech32m = genBech322("bech32m");
    exports.utf8 = {
      encode: (data) => new TextDecoder().decode(data),
      decode: (str) => new TextEncoder().encode(str)
    };
    exports.hex = chain2(radix22(4), alphabet2("0123456789abcdef"), join2(""), normalize2((s) => {
      if (typeof s !== "string" || s.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
      return s.toLowerCase();
    }));
    var CODERS = {
      utf8: exports.utf8,
      hex: exports.hex,
      base16: exports.base16,
      base32: exports.base32,
      base64: exports.base64,
      base64url: exports.base64url,
      base58: exports.base58,
      base58xmr: exports.base58xmr
    };
    var coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;
    var bytesToString = (type, bytes2) => {
      if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (!(bytes2 instanceof Uint8Array))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS[type].encode(bytes2);
    };
    exports.bytesToString = bytesToString;
    exports.str = exports.bytesToString;
    var stringToBytes = (type, str) => {
      if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (typeof str !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS[type].decode(str);
    };
    exports.stringToBytes = stringToBytes;
    exports.bytes = exports.stringToBytes;
  }
});

// node_modules/light-bolt11-decoder/bolt11.js
var require_bolt11 = __commonJS({
  "node_modules/light-bolt11-decoder/bolt11.js"(exports, module) {
    var { bech32: bech322, hex: hex2, utf8 } = require_lib2();
    var DEFAULTNETWORK = {
      // default network is bitcoin
      bech32: "bc",
      pubKeyHash: 0,
      scriptHash: 5,
      validWitnessVersions: [0]
    };
    var TESTNETWORK = {
      bech32: "tb",
      pubKeyHash: 111,
      scriptHash: 196,
      validWitnessVersions: [0]
    };
    var SIGNETNETWORK = {
      bech32: "tbs",
      pubKeyHash: 111,
      scriptHash: 196,
      validWitnessVersions: [0]
    };
    var REGTESTNETWORK = {
      bech32: "bcrt",
      pubKeyHash: 111,
      scriptHash: 196,
      validWitnessVersions: [0]
    };
    var SIMNETWORK = {
      bech32: "sb",
      pubKeyHash: 63,
      scriptHash: 123,
      validWitnessVersions: [0]
    };
    var FEATUREBIT_ORDER = [
      "option_data_loss_protect",
      "initial_routing_sync",
      "option_upfront_shutdown_script",
      "gossip_queries",
      "var_onion_optin",
      "gossip_queries_ex",
      "option_static_remotekey",
      "payment_secret",
      "basic_mpp",
      "option_support_large_channel"
    ];
    var DIVISORS = {
      m: BigInt(1e3),
      u: BigInt(1e6),
      n: BigInt(1e9),
      p: BigInt(1e12)
    };
    var MAX_MILLISATS = BigInt("2100000000000000000");
    var MILLISATS_PER_BTC = BigInt(1e11);
    var TAGCODES = {
      payment_hash: 1,
      payment_secret: 16,
      description: 13,
      payee: 19,
      description_hash: 23,
      // commit to longer descriptions (used by lnurl-pay)
      expiry: 6,
      // default: 3600 (1 hour)
      min_final_cltv_expiry: 24,
      // default: 9
      fallback_address: 9,
      route_hint: 3,
      // for extra routing info (private etc.)
      feature_bits: 5,
      metadata: 27
    };
    var TAGNAMES = {};
    for (let i = 0, keys = Object.keys(TAGCODES); i < keys.length; i++) {
      const currentName = keys[i];
      const currentCode = TAGCODES[keys[i]].toString();
      TAGNAMES[currentCode] = currentName;
    }
    var TAGPARSERS = {
      1: (words) => hex2.encode(bech322.fromWordsUnsafe(words)),
      // 256 bits
      16: (words) => hex2.encode(bech322.fromWordsUnsafe(words)),
      // 256 bits
      13: (words) => utf8.encode(bech322.fromWordsUnsafe(words)),
      // string variable length
      19: (words) => hex2.encode(bech322.fromWordsUnsafe(words)),
      // 264 bits
      23: (words) => hex2.encode(bech322.fromWordsUnsafe(words)),
      // 256 bits
      27: (words) => hex2.encode(bech322.fromWordsUnsafe(words)),
      // variable
      6: wordsToIntBE,
      // default: 3600 (1 hour)
      24: wordsToIntBE,
      // default: 9
      3: routingInfoParser,
      // for extra routing info (private etc.)
      5: featureBitsParser
      // keep feature bits as array of 5 bit words
    };
    function getUnknownParser(tagCode) {
      return (words) => ({
        tagCode: parseInt(tagCode),
        words: bech322.encode("unknown", words, Number.MAX_SAFE_INTEGER)
      });
    }
    function wordsToIntBE(words) {
      return words.reverse().reduce((total, item, index) => {
        return total + item * Math.pow(32, index);
      }, 0);
    }
    function routingInfoParser(words) {
      const routes = [];
      let pubkey2, shortChannelId, feeBaseMSats, feeProportionalMillionths, cltvExpiryDelta;
      let routesBuffer = bech322.fromWordsUnsafe(words);
      while (routesBuffer.length > 0) {
        pubkey2 = hex2.encode(routesBuffer.slice(0, 33));
        shortChannelId = hex2.encode(routesBuffer.slice(33, 41));
        feeBaseMSats = parseInt(hex2.encode(routesBuffer.slice(41, 45)), 16);
        feeProportionalMillionths = parseInt(
          hex2.encode(routesBuffer.slice(45, 49)),
          16
        );
        cltvExpiryDelta = parseInt(hex2.encode(routesBuffer.slice(49, 51)), 16);
        routesBuffer = routesBuffer.slice(51);
        routes.push({
          pubkey: pubkey2,
          short_channel_id: shortChannelId,
          fee_base_msat: feeBaseMSats,
          fee_proportional_millionths: feeProportionalMillionths,
          cltv_expiry_delta: cltvExpiryDelta
        });
      }
      return routes;
    }
    function featureBitsParser(words) {
      const bools = words.slice().reverse().map((word) => [
        !!(word & 1),
        !!(word & 2),
        !!(word & 4),
        !!(word & 8),
        !!(word & 16)
      ]).reduce((finalArr, itemArr) => finalArr.concat(itemArr), []);
      while (bools.length < FEATUREBIT_ORDER.length * 2) {
        bools.push(false);
      }
      const featureBits = {};
      FEATUREBIT_ORDER.forEach((featureName, index) => {
        let status;
        if (bools[index * 2]) {
          status = "required";
        } else if (bools[index * 2 + 1]) {
          status = "supported";
        } else {
          status = "unsupported";
        }
        featureBits[featureName] = status;
      });
      const extraBits = bools.slice(FEATUREBIT_ORDER.length * 2);
      featureBits.extra_bits = {
        start_bit: FEATUREBIT_ORDER.length * 2,
        bits: extraBits,
        has_required: extraBits.reduce(
          (result, bit, index) => index % 2 !== 0 ? result || false : result || bit,
          false
        )
      };
      return featureBits;
    }
    function hrpToMillisat(hrpString, outputString) {
      let divisor, value;
      if (hrpString.slice(-1).match(/^[munp]$/)) {
        divisor = hrpString.slice(-1);
        value = hrpString.slice(0, -1);
      } else if (hrpString.slice(-1).match(/^[^munp0-9]$/)) {
        throw new Error("Not a valid multiplier for the amount");
      } else {
        value = hrpString;
      }
      if (!value.match(/^\d+$/))
        throw new Error("Not a valid human readable amount");
      const valueBN = BigInt(value);
      const millisatoshisBN = divisor ? valueBN * MILLISATS_PER_BTC / DIVISORS[divisor] : valueBN * MILLISATS_PER_BTC;
      if (divisor === "p" && !(valueBN % BigInt(10) === BigInt(0)) || millisatoshisBN > MAX_MILLISATS) {
        throw new Error("Amount is outside of valid range");
      }
      return outputString ? millisatoshisBN.toString() : millisatoshisBN;
    }
    function decode3(paymentRequest, network) {
      if (typeof paymentRequest !== "string")
        throw new Error("Lightning Payment Request must be string");
      if (paymentRequest.slice(0, 2).toLowerCase() !== "ln")
        throw new Error("Not a proper lightning payment request");
      const sections = [];
      const decoded = bech322.decode(paymentRequest, Number.MAX_SAFE_INTEGER);
      paymentRequest = paymentRequest.toLowerCase();
      const prefix = decoded.prefix;
      let words = decoded.words;
      let letters = paymentRequest.slice(prefix.length + 1);
      let sigWords = words.slice(-104);
      words = words.slice(0, -104);
      let prefixMatches = prefix.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);
      if (prefixMatches && !prefixMatches[2])
        prefixMatches = prefix.match(/^ln(\S+)$/);
      if (!prefixMatches) {
        throw new Error("Not a proper lightning payment request");
      }
      sections.push({
        name: "lightning_network",
        letters: "ln"
      });
      const bech32Prefix = prefixMatches[1];
      let coinNetwork;
      if (!network) {
        switch (bech32Prefix) {
          case DEFAULTNETWORK.bech32:
            coinNetwork = DEFAULTNETWORK;
            break;
          case TESTNETWORK.bech32:
            coinNetwork = TESTNETWORK;
            break;
          case SIGNETNETWORK.bech32:
            coinNetwork = SIGNETNETWORK;
            break;
          case REGTESTNETWORK.bech32:
            coinNetwork = REGTESTNETWORK;
            break;
          case SIMNETWORK.bech32:
            coinNetwork = SIMNETWORK;
            break;
        }
      } else {
        if (network.bech32 === void 0 || network.pubKeyHash === void 0 || network.scriptHash === void 0 || !Array.isArray(network.validWitnessVersions))
          throw new Error("Invalid network");
        coinNetwork = network;
      }
      if (!coinNetwork || coinNetwork.bech32 !== bech32Prefix) {
        throw new Error("Unknown coin bech32 prefix");
      }
      sections.push({
        name: "coin_network",
        letters: bech32Prefix,
        value: coinNetwork
      });
      const value = prefixMatches[2];
      let millisatoshis;
      if (value) {
        const divisor = prefixMatches[3];
        millisatoshis = hrpToMillisat(value + divisor, true);
        sections.push({
          name: "amount",
          letters: prefixMatches[2] + prefixMatches[3],
          value: millisatoshis
        });
      } else {
        millisatoshis = null;
      }
      sections.push({
        name: "separator",
        letters: "1"
      });
      const timestamp = wordsToIntBE(words.slice(0, 7));
      words = words.slice(7);
      sections.push({
        name: "timestamp",
        letters: letters.slice(0, 7),
        value: timestamp
      });
      letters = letters.slice(7);
      let tagName, parser, tagLength, tagWords;
      while (words.length > 0) {
        const tagCode = words[0].toString();
        tagName = TAGNAMES[tagCode] || "unknown_tag";
        parser = TAGPARSERS[tagCode] || getUnknownParser(tagCode);
        words = words.slice(1);
        tagLength = wordsToIntBE(words.slice(0, 2));
        words = words.slice(2);
        tagWords = words.slice(0, tagLength);
        words = words.slice(tagLength);
        sections.push({
          name: tagName,
          tag: letters[0],
          letters: letters.slice(0, 1 + 2 + tagLength),
          value: parser(tagWords)
          // see: parsers for more comments
        });
        letters = letters.slice(1 + 2 + tagLength);
      }
      sections.push({
        name: "signature",
        letters: letters.slice(0, 104),
        value: hex2.encode(bech322.fromWordsUnsafe(sigWords))
      });
      letters = letters.slice(104);
      sections.push({
        name: "checksum",
        letters
      });
      let result = {
        paymentRequest,
        sections,
        get expiry() {
          let exp = sections.find((s) => s.name === "expiry");
          if (exp) return getValue("timestamp") + exp.value;
        },
        get route_hints() {
          return sections.filter((s) => s.name === "route_hint").map((s) => s.value);
        }
      };
      for (let name in TAGCODES) {
        if (name === "route_hint") {
          continue;
        }
        Object.defineProperty(result, name, {
          get() {
            return getValue(name);
          }
        });
      }
      return result;
      function getValue(name) {
        let section = sections.find((s) => s.name === name);
        return section ? section.value : void 0;
      }
    }
    module.exports = {
      decode: decode3,
      hrpToMillisat
    };
  }
});

// node_modules/snstr/dist/esm/src/utils/websocket.js
var import_websocket_polyfill = __toESM(require_lib(), 1);
var OriginalWebSocket = globalThis.WebSocket;
var PolyfilledWebSocket = globalThis.WebSocket;
function hasRequiredWebSocketFeatures(wsCtor) {
  if (!wsCtor || !wsCtor.prototype) {
    return false;
  }
  const proto = wsCtor.prototype;
  const binaryTypeDescriptor = Object.getOwnPropertyDescriptor(proto, "binaryType");
  const hasSend = typeof proto.send === "function";
  const hasClose = typeof proto.close === "function";
  const hasBinaryTypeSetter = typeof binaryTypeDescriptor?.set === "function";
  return hasSend && hasClose && hasBinaryTypeSetter;
}
function resolveDefaultWebSocket() {
  const currentGlobal = globalThis.WebSocket;
  const candidatesWithPriority = [];
  if (currentGlobal && currentGlobal !== OriginalWebSocket && currentGlobal !== PolyfilledWebSocket) {
    candidatesWithPriority.push(currentGlobal);
  }
  candidatesWithPriority.push(OriginalWebSocket, PolyfilledWebSocket);
  for (const candidate of candidatesWithPriority) {
    if (hasRequiredWebSocketFeatures(candidate)) {
      return candidate;
    }
  }
  const fallbackCandidates = [
    OriginalWebSocket,
    currentGlobal,
    PolyfilledWebSocket
  ];
  for (const candidate of fallbackCandidates) {
    if (candidate) {
      return candidate;
    }
  }
  return void 0;
}
var WebSocketImpl = resolveDefaultWebSocket();
function useWebSocketImplementation(wsCtor) {
  WebSocketImpl = wsCtor;
}
function resetWebSocketImplementation() {
  WebSocketImpl = resolveDefaultWebSocket();
}
function getWebSocketImplementation() {
  if (!WebSocketImpl) {
    throw new Error("WebSocket implementation not available. Make sure websocket-polyfill is properly loaded.");
  }
  return WebSocketImpl;
}

// node_modules/snstr/dist/esm/src/utils/inMemoryWebSocket.js
var import_events = __toESM(require_events(), 1);
var serverRegistry = /* @__PURE__ */ new Map();
function getInMemoryServer(port) {
  return serverRegistry.get(port);
}
function createInMemoryWebSocket(url) {
  try {
    const parsed = new URL(url);
    const hostname = parsed.hostname;
    const normalizedHostname = hostname.startsWith("[") && hostname.endsWith("]") ? hostname.slice(1, -1) : hostname;
    const protocol = parsed.protocol;
    if (normalizedHostname !== "127.0.0.1" && normalizedHostname !== "localhost" && normalizedHostname !== "::1") {
      return void 0;
    }
    let port;
    if (parsed.port) {
      port = Number(parsed.port);
    } else if (protocol === "ws:") {
      port = 80;
    } else if (protocol === "wss:") {
      port = 443;
    } else {
      return void 0;
    }
    if (!Number.isFinite(port) || port <= 0) {
      return void 0;
    }
    const server = getInMemoryServer(port);
    if (!server) {
      return void 0;
    }
    return server.connectClient();
  } catch (_error) {
    return void 0;
  }
}

// node_modules/snstr/dist/esm/src/types/nostr.js
var RelayEvent;
(function(RelayEvent2) {
  RelayEvent2["Connect"] = "connect";
  RelayEvent2["Disconnect"] = "disconnect";
  RelayEvent2["Error"] = "error";
  RelayEvent2["Notice"] = "notice";
  RelayEvent2["OK"] = "ok";
  RelayEvent2["Closed"] = "closed";
  RelayEvent2["Auth"] = "auth";
})(RelayEvent || (RelayEvent = {}));
var RelayStatus;
(function(RelayStatus2) {
  RelayStatus2["DISCONNECTED"] = "disconnected";
  RelayStatus2["CONNECTING"] = "connecting";
  RelayStatus2["CONNECTED"] = "connected";
  RelayStatus2["RECONNECTING"] = "reconnecting";
  RelayStatus2["CLOSED"] = "closed";
})(RelayStatus || (RelayStatus = {}));
var NostrKind;
(function(NostrKind2) {
  NostrKind2[NostrKind2["Metadata"] = 0] = "Metadata";
  NostrKind2[NostrKind2["ShortNote"] = 1] = "ShortNote";
  NostrKind2[NostrKind2["RecommendRelay"] = 2] = "RecommendRelay";
  NostrKind2[NostrKind2["Contacts"] = 3] = "Contacts";
  NostrKind2[NostrKind2["DirectMessage"] = 4] = "DirectMessage";
  NostrKind2[NostrKind2["Deletion"] = 5] = "Deletion";
  NostrKind2[NostrKind2["Repost"] = 6] = "Repost";
  NostrKind2[NostrKind2["Reaction"] = 7] = "Reaction";
  NostrKind2[NostrKind2["BadgeAward"] = 8] = "BadgeAward";
})(NostrKind || (NostrKind = {}));
var WebSocketReadyState;
(function(WebSocketReadyState2) {
  WebSocketReadyState2[WebSocketReadyState2["CONNECTING"] = 0] = "CONNECTING";
  WebSocketReadyState2[WebSocketReadyState2["OPEN"] = 1] = "OPEN";
  WebSocketReadyState2[WebSocketReadyState2["CLOSING"] = 2] = "CLOSING";
  WebSocketReadyState2[WebSocketReadyState2["CLOSED"] = 3] = "CLOSED";
})(WebSocketReadyState || (WebSocketReadyState = {}));
var RelayErrorType;
(function(RelayErrorType2) {
  RelayErrorType2["CONNECTION_ERROR"] = "connection_error";
  RelayErrorType2["TIMEOUT"] = "timeout";
  RelayErrorType2["DISCONNECTED"] = "disconnected";
  RelayErrorType2["VALIDATION_ERROR"] = "validation_error";
  RelayErrorType2["EVENT_REJECTED"] = "event_rejected";
  RelayErrorType2["RATE_LIMITED"] = "rate_limited";
  RelayErrorType2["AUTH_REQUIRED"] = "auth_required";
  RelayErrorType2["AUTH_FAILED"] = "auth_failed";
  RelayErrorType2["IP_BLOCKED"] = "ip_blocked";
  RelayErrorType2["READ_ONLY"] = "read_only";
  RelayErrorType2["PAYLOAD_TOO_LARGE"] = "payload_too_large";
  RelayErrorType2["INVALID_MESSAGE"] = "invalid_message";
  RelayErrorType2["MAX_SUBSCRIPTIONS"] = "max_subscriptions";
  RelayErrorType2["UNKNOWN"] = "unknown";
})(RelayErrorType || (RelayErrorType = {}));
var NIP20Prefix;
(function(NIP20Prefix2) {
  NIP20Prefix2["Duplicate"] = "duplicate:";
  NIP20Prefix2["PoW"] = "pow:";
  NIP20Prefix2["RateLimited"] = "rate-limited:";
  NIP20Prefix2["Invalid"] = "invalid:";
  NIP20Prefix2["Error"] = "error:";
  NIP20Prefix2["Blocked"] = "blocked:";
  NIP20Prefix2["AuthRequired"] = "auth-required:";
  NIP20Prefix2["Restricted"] = "restricted:";
})(NIP20Prefix || (NIP20Prefix = {}));

// node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  abytes(bytes2);
  if (hasHexBuiltin)
    return bytes2.toHex();
  let hex2 = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex2 += hexes[bytes2[i]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi));
    const n2 = asciiToBase16(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@noble/hashes/esm/sha2.js
var SHA256_K = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super(28);
    this.A = SHA224_IV[0] | 0;
    this.B = SHA224_IV[1] | 0;
    this.C = SHA224_IV[2] | 0;
    this.D = SHA224_IV[3] | 0;
    this.E = SHA224_IV[4] | 0;
    this.F = SHA224_IV[5] | 0;
    this.G = SHA224_IV[6] | 0;
    this.H = SHA224_IV[7] | 0;
  }
};
var K512 = (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_Kh = (() => K512[0])();
var SHA512_Kl = (() => K512[1])();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super(48);
    this.Ah = SHA384_IV[0] | 0;
    this.Al = SHA384_IV[1] | 0;
    this.Bh = SHA384_IV[2] | 0;
    this.Bl = SHA384_IV[3] | 0;
    this.Ch = SHA384_IV[4] | 0;
    this.Cl = SHA384_IV[5] | 0;
    this.Dh = SHA384_IV[6] | 0;
    this.Dl = SHA384_IV[7] | 0;
    this.Eh = SHA384_IV[8] | 0;
    this.El = SHA384_IV[9] | 0;
    this.Fh = SHA384_IV[10] | 0;
    this.Fl = SHA384_IV[11] | 0;
    this.Gh = SHA384_IV[12] | 0;
    this.Gl = SHA384_IV[13] | 0;
    this.Hh = SHA384_IV[14] | 0;
    this.Hl = SHA384_IV[15] | 0;
  }
};
var T224_IV = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var SHA512_224 = class extends SHA512 {
  constructor() {
    super(28);
    this.Ah = T224_IV[0] | 0;
    this.Al = T224_IV[1] | 0;
    this.Bh = T224_IV[2] | 0;
    this.Bl = T224_IV[3] | 0;
    this.Ch = T224_IV[4] | 0;
    this.Cl = T224_IV[5] | 0;
    this.Dh = T224_IV[6] | 0;
    this.Dl = T224_IV[7] | 0;
    this.Eh = T224_IV[8] | 0;
    this.El = T224_IV[9] | 0;
    this.Fh = T224_IV[10] | 0;
    this.Fl = T224_IV[11] | 0;
    this.Gh = T224_IV[12] | 0;
    this.Gl = T224_IV[13] | 0;
    this.Hh = T224_IV[14] | 0;
    this.Hl = T224_IV[15] | 0;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super(32);
    this.Ah = T256_IV[0] | 0;
    this.Al = T256_IV[1] | 0;
    this.Bh = T256_IV[2] | 0;
    this.Bl = T256_IV[3] | 0;
    this.Ch = T256_IV[4] | 0;
    this.Cl = T256_IV[5] | 0;
    this.Dh = T256_IV[6] | 0;
    this.Dl = T256_IV[7] | 0;
    this.Eh = T256_IV[8] | 0;
    this.El = T256_IV[9] | 0;
    this.Fh = T256_IV[10] | 0;
    this.Fl = T256_IV[11] | 0;
    this.Gh = T256_IV[12] | 0;
    this.Gl = T256_IV[13] | 0;
    this.Hh = T256_IV[14] | 0;
    this.Hl = T256_IV[15] | 0;
  }
};
var sha256 = createHasher(() => new SHA256());
var sha224 = createHasher(() => new SHA224());
var sha512 = createHasher(() => new SHA512());
var sha384 = createHasher(() => new SHA384());
var sha512_256 = createHasher(() => new SHA512_256());
var sha512_224 = createHasher(() => new SHA512_224());

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key = toBytes(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash.create();
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54 ^ 92;
    this.oHash.update(pad2);
    clean(pad2);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

// node_modules/@noble/curves/esm/utils.js
var _0n = BigInt(0);
var _1n = BigInt(1);
function _abool2(value, title = "") {
  if (typeof value !== "boolean") {
    const prefix = title && `"${title}"`;
    throw new Error(prefix + "expected boolean, got type=" + typeof value);
  }
  return value;
}
function _abytes2(value, length, title = "") {
  const bytes2 = isBytes(value);
  const len = value?.length;
  const needsLen = length !== void 0;
  if (!bytes2 || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes2 ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function numberToHexUnpadded(num2) {
  const hex2 = num2.toString(16);
  return hex2.length & 1 ? "0" + hex2 : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return hex2 === "" ? _0n : BigInt("0x" + hex2);
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes(bytes2);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
var bitMask = (n) => (_1n << BigInt(n)) - _1n;
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n = (len) => new Uint8Array(len);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n(0)) => {
    k = h(u8of(0), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8of(1), seed);
    v = h();
  };
  const gen = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function isHash(val) {
  return typeof val === "function" && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
function memoized(fn) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _7n = BigInt(7);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod(number2, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd2 = b;
  if (gcd2 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function assertIsSquare(Fp, root, n) {
  if (!Fp.eql(Fp.sqr(root), n))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp, n) {
  const p1div4 = (Fp.ORDER + _1n2) / _4n;
  const root = Fp.pow(n, p1div4);
  assertIsSquare(Fp, root, n);
  return root;
}
function sqrt5mod8(Fp, n) {
  const p5div8 = (Fp.ORDER - _5n) / _8n;
  const n2 = Fp.mul(n, _2n);
  const v = Fp.pow(n2, p5div8);
  const nv = Fp.mul(n, v);
  const i = Fp.mul(Fp.mul(nv, _2n), v);
  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
  assertIsSquare(Fp, root, n);
  return root;
}
function sqrt9mod16(P) {
  const Fp_ = Field(P);
  const tn = tonelliShanks(P);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n) / _16n;
  return (Fp, n) => {
    let tv1 = Fp.pow(n, c4);
    let tv2 = Fp.mul(tv1, c1);
    const tv3 = Fp.mul(tv1, c2);
    const tv4 = Fp.mul(tv1, c3);
    const e1 = Fp.eql(Fp.sqr(tv2), n);
    const e2 = Fp.eql(Fp.sqr(tv3), n);
    tv1 = Fp.cmov(tv1, tv2, e1);
    tv2 = Fp.cmov(tv4, tv3, e2);
    const e3 = Fp.eql(Fp.sqr(tv2), n);
    const root = Fp.cmov(tv1, tv2, e3);
    assertIsSquare(Fp, root, n);
    return root;
  };
}
function tonelliShanks(P) {
  if (P < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp, n) {
    if (Fp.is0(n))
      return n;
    if (FpLegendre(Fp, n) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp.mul(Fp.ONE, cc);
    let t = Fp.pow(n, Q);
    let R = Fp.pow(n, Q1div2);
    while (!Fp.eql(t, Fp.ONE)) {
      if (Fp.is0(t))
        return Fp.ZERO;
      let i = 1;
      let t_tmp = Fp.sqr(t);
      while (!Fp.eql(t_tmp, Fp.ONE)) {
        i++;
        t_tmp = Fp.sqr(t_tmp);
        if (i === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i - 1);
      const b = Fp.pow(c, exponent);
      M = i;
      c = Fp.sqr(b);
      t = Fp.mul(t, c);
      R = Fp.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n)
    return sqrt3mod4;
  if (P % _8n === _5n)
    return sqrt5mod8;
  if (P % _16n === _9n)
    return sqrt9mod16(P);
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow(Fp, num2, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp.ONE;
  if (power === _1n2)
    return num2;
  let p = Fp.ONE;
  let d = num2;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp.mul(p, d);
    d = Fp.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num2, i) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i] = acc;
    return Fp.mul(acc, num2);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num2, i) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i] = Fp.mul(acc, inverted[i]);
    return Fp.mul(acc, num2);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n) {
  const p1mod2 = (Fp.ORDER - _1n2) / _2n;
  const powered = Fp.pow(n, p1mod2);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero = Fp.eql(powered, Fp.ZERO);
  const no = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLenOrOpts, isLE3 = false, opts = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  let modFromBytes = false;
  let allowedLengths = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE3)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE3 = _opts.isLE;
    if (typeof _opts.modFromBytes === "boolean")
      modFromBytes = _opts.modFromBytes;
    allowedLengths = _opts.allowedLengths;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE3,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    allowedLengths,
    create: (num2) => mod(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num2);
      return _0n2 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n2,
    // is valid and invertible
    isValidNot0: (num2) => !f.is0(num2) && f.isValid(num2),
    isOdd: (num2) => (num2 & _1n2) === _1n2,
    neg: (num2) => mod(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod(num2 * num2, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow(f, num2, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert(num2, ORDER),
    sqrt: _sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    toBytes: (num2) => isLE3 ? numberToBytesLE(num2, BYTES) : numberToBytesBE(num2, BYTES),
    fromBytes: (bytes2, skipValidation = true) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes2.length) || bytes2.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes2.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes2, isLE3 ? 0 : padded.length - bytes2.length);
        bytes2 = padded;
      }
      if (bytes2.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
      let scalar = isLE3 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
      if (modFromBytes)
        scalar = mod(scalar, ORDER);
      if (!skipValidation) {
        if (!f.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a, b, c) => c ? b : a
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num2 = isLE3 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num2, fieldOrder - _1n2) + _1n2;
  return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, points) {
  const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
  if (n !== _0n3)
    throw new Error("invalid wNAF");
}
var wNAF = class {
  // Parametrized with a given Point class (not individual point)
  constructor(Point, bits) {
    this.BASE = Point.BASE;
    this.ZERO = Point.ZERO;
    this.Fn = Point.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n, p = this.ZERO) {
    let d = elm;
    while (n > _0n3) {
      if (n & _1n3)
        p = p.add(d);
      d = d.double();
      n >>= _1n3;
    }
    return p;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(ðâ1) * (Math.ceil(ð / ð) + 1), where:
   * - ð is the window size
   * - ð is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point, W) {
    const { windows, windowSize } = calcWOpts(W, this.bits);
    const points = [];
    let p = point;
    let base = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base = p;
      points.push(base);
      for (let i = 1; i < windowSize; i++) {
        base = base.add(p);
        points.push(base);
      }
      p = base.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W, precomputes, n) {
    if (!this.Fn.isValid(n))
      throw new Error("invalid scalar");
    let p = this.ZERO;
    let f = this.BASE;
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
      n = nextN;
      if (isZero) {
        f = f.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p = p.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n);
    return { p, f };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      if (n === _0n3)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
      n = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n);
    return acc;
  }
  getPrecomputes(W, point, transform) {
    let comp = pointPrecomputes.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W);
      if (W !== 1) {
        if (typeof transform === "function")
          comp = transform(comp);
        pointPrecomputes.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform) {
    const W = getW(point);
    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
  }
  unsafe(point, scalar, transform, prev) {
    const W = getW(point);
    if (W === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P, W) {
    validateW(W, this.bits);
    pointWindowSizes.set(P, W);
    pointPrecomputes.delete(P);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
};
function mulEndoUnsafe(Point, point, k1, k2) {
  let acc = point;
  let p1 = Point.ZERO;
  let p2 = Point.ZERO;
  while (k1 > _0n3 || k2 > _0n3) {
    if (k1 & _1n3)
      p1 = p1.add(acc);
    if (k2 & _1n3)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n3;
    k2 >>= _1n3;
  }
  return { p1, p2 };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field, isLE3) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE: isLE3 });
  }
}
function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type === "edwards";
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
  const _b = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  CURVE = Object.freeze(Object.assign({}, CURVE));
  return { CURVE, Fp, Fn };
}

// node_modules/@noble/curves/esm/abstract/weierstrass.js
var divNearest = (num2, den) => (num2 + (num2 >= 0 ? den : -den) / _2n2) / den;
function _splitEndoScalar(k, basis, n) {
  const [[a1, b1], [a2, b2]] = basis;
  const c1 = divNearest(b2 * k, n);
  const c2 = divNearest(-b1 * k, n);
  let k1 = k - c1 * a1 - c2 * a2;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n4;
  const k2neg = k2 < _0n4;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n4;
  if (k1 < _0n4 || k1 >= MAX_NUM || k2 < _0n4 || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format) {
  if (!["compact", "recovered", "der"].includes(format))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format;
}
function validateSigOpts(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  _abool2(optsn.lowS, "lowS");
  _abool2(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat(optsn.format);
  return optsn;
}
var DERErr = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t = numberToHexUnpadded(tag);
      return t + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length = 0;
      if (!isLong)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length = length << 8 | b;
        pos += lenLen;
        if (length < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length);
      if (v.length !== length)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num2) {
      const { Err: E } = DER;
      if (num2 < _0n4)
        throw new E("integer: negative integers are not allowed");
      let hex2 = numberToHexUnpadded(num2);
      if (Number.parseInt(hex2[0], 16) & 8)
        hex2 = "00" + hex2;
      if (hex2.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex2;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(hex2) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = ensureBytes("signature", hex2);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n2 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function _normFnElement(Fn, key) {
  const { BYTES: expected } = Fn;
  let num2;
  if (typeof key === "bigint") {
    num2 = key;
  } else {
    let bytes2 = ensureBytes("private key", key);
    try {
      num2 = Fn.fromBytes(bytes2);
    } catch (error) {
      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
    }
  }
  if (!Fn.isValidNot0(num2))
    throw new Error("invalid private key: out of range [1..N-1]");
  return num2;
}
function weierstrassN(params, extraOpts = {}) {
  const validated = _createCurveFields("weierstrass", params, extraOpts);
  const { Fp, Fn } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = extraOpts;
  if (endo) {
    if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths = getWLengths(Fp, Fn);
  function assertCompressionIsSupported() {
    if (!Fp.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes2(_c, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp.toBytes(x);
    _abool2(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp.isOdd(y);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp.toBytes(y));
    }
  }
  function pointFromBytes(bytes2) {
    _abytes2(bytes2, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    const length = bytes2.length;
    const head = bytes2[0];
    const tail = bytes2.subarray(1);
    if (length === comp && (head === 2 || head === 3)) {
      const x = Fp.fromBytes(tail);
      if (!Fp.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp.isOdd(y);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp.neg(y);
      return { x, y };
    } else if (length === uncomp && head === 4) {
      const L = Fp.BYTES;
      const x = Fp.fromBytes(tail.subarray(0, L));
      const y = Fp.fromBytes(tail.subarray(L, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint = extraOpts.toBytes || pointToBytes2;
  const decodePoint = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x) {
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
  }
  function isValidXY(x, y) {
    const left = Fp.sqr(y);
    const right = weierstrassEquation(x);
    return Fp.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n2), _4n2);
  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
  if (Fp.is0(Fp.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n, banZero = false) {
    if (!Fp.isValid(n) || banZero && Fp.is0(n))
      throw new Error(`bad point coordinate ${title}`);
    return n;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  function splitEndoScalarN(k) {
    if (!endo || !endo.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k, endo.basises, Fn.ORDER);
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X, Y, Z } = p;
    if (Fp.eql(Z, Fp.ONE))
      return { x: X, y: Y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(Z);
    const x = Fp.mul(X, iz);
    const y = Fp.mul(Y, iz);
    const zz = Fp.mul(Z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X, Y, Z) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      if (Fp.is0(x) && Fp.is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp.ONE);
    }
    static fromBytes(bytes2) {
      const P = Point.fromAffine(decodePoint(_abytes2(bytes2, void 0, "point")));
      P.assertValidity();
      return P;
    }
    static fromHex(hex2) {
      return Point.fromBytes(ensureBytes("pointHex", hex2));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n2);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point(this.X, Fp.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = extraOpts;
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f } = mul(scalar);
        point = p;
        fake = f;
      }
      return normalizeZ(Point, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = extraOpts;
      const p = this;
      if (!Fn.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n4 || p.is0())
        return Point.ZERO;
      if (sc === _1n4)
        return p;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
      return sum.is0() ? void 0 : sum;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      _abool2(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    static normalizeZ(points) {
      return normalizeZ(Point, points);
    }
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    static fromPrivateKey(privateKey2) {
      return Point.BASE.multiply(_normFnElement(Fn, privateKey2));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  Point.Fp = Fp;
  Point.Fn = Fn;
  const bits = Fn.BITS;
  const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point.BASE.precompute(8);
  return Point;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function SWUFpSqrtRatio(Fp, Z) {
  const q = Fp.ORDER;
  let l = _0n4;
  for (let o = q - _1n4; o % _2n2 === _0n4; o /= _2n2)
    l += _1n4;
  const c1 = l;
  const _2n_pow_c1_1 = _2n2 << c1 - _1n4 - _1n4;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n2;
  const c2 = (q - _1n4) / _2n_pow_c1;
  const c3 = (c2 - _1n4) / _2n2;
  const c4 = _2n_pow_c1 - _1n4;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp.pow(Z, c2);
  const c7 = Fp.pow(Z, (c2 + _1n4) / _2n2);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp.pow(v, c4);
    let tv3 = Fp.sqr(tv2);
    tv3 = Fp.mul(tv3, v);
    let tv5 = Fp.mul(u, tv3);
    tv5 = Fp.pow(tv5, c3);
    tv5 = Fp.mul(tv5, tv2);
    tv2 = Fp.mul(tv5, v);
    tv3 = Fp.mul(tv5, u);
    let tv4 = Fp.mul(tv3, tv2);
    tv5 = Fp.pow(tv4, c5);
    let isQR = Fp.eql(tv5, Fp.ONE);
    tv2 = Fp.mul(tv3, c7);
    tv5 = Fp.mul(tv4, tv1);
    tv3 = Fp.cmov(tv2, tv3, isQR);
    tv4 = Fp.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n4; i--) {
      let tv52 = i - _2n2;
      tv52 = _2n2 << tv52 - _1n4;
      let tvv5 = Fp.pow(tv4, tv52);
      const e1 = Fp.eql(tvv5, Fp.ONE);
      tv2 = Fp.mul(tv3, tv1);
      tv1 = Fp.mul(tv1, tv1);
      tvv5 = Fp.mul(tv4, tv1);
      tv3 = Fp.cmov(tv2, tv3, e1);
      tv4 = Fp.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp.ORDER % _4n2 === _3n2) {
    const c12 = (Fp.ORDER - _3n2) / _4n2;
    const c22 = Fp.sqrt(Fp.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp.sqr(v);
      const tv2 = Fp.mul(u, v);
      tv1 = Fp.mul(tv1, tv2);
      let y1 = Fp.pow(tv1, c12);
      y1 = Fp.mul(y1, tv2);
      const y2 = Fp.mul(y1, c22);
      const tv3 = Fp.mul(Fp.sqr(y1), v);
      const isQR = Fp.eql(tv3, u);
      let y = Fp.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp, opts) {
  validateField(Fp);
  const { A, B, Z } = opts;
  if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
  if (!Fp.isOdd)
    throw new Error("Field does not have .isOdd()");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp.sqr(u);
    tv1 = Fp.mul(tv1, Z);
    tv2 = Fp.sqr(tv1);
    tv2 = Fp.add(tv2, tv1);
    tv3 = Fp.add(tv2, Fp.ONE);
    tv3 = Fp.mul(tv3, B);
    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
    tv4 = Fp.mul(tv4, A);
    tv2 = Fp.sqr(tv3);
    tv6 = Fp.sqr(tv4);
    tv5 = Fp.mul(tv6, A);
    tv2 = Fp.add(tv2, tv5);
    tv2 = Fp.mul(tv2, tv3);
    tv6 = Fp.mul(tv6, tv4);
    tv5 = Fp.mul(tv6, B);
    tv2 = Fp.add(tv2, tv5);
    x = Fp.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp.mul(tv1, u);
    y = Fp.mul(y, value);
    x = Fp.cmov(x, tv3, isValid);
    y = Fp.cmov(y, value, isValid);
    const e1 = Fp.isOdd(u) === Fp.isOdd(y);
    y = Fp.cmov(Fp.neg(y), y, e1);
    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];
    x = Fp.mul(x, tv4_inv);
    return { x, y };
  };
}
function getWLengths(Fp, Fn) {
  return {
    secretKey: Fn.BYTES,
    publicKey: 1 + Fp.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn.BYTES
  };
}
function ecdh(Point, ecdhOpts = {}) {
  const { Fn } = Point;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
  const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      return !!_normFnElement(Fn, secretKey);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths;
    try {
      const l = publicKey.length;
      if (isCompressed === true && l !== comp)
        return false;
      if (isCompressed === false && l !== publicKeyUncompressed)
        return false;
      return !!Point.fromBytes(publicKey);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return mapHashToField(_abytes2(seed, lengths.seed, "seed"), Fn.ORDER);
  }
  function getPublicKey3(secretKey, isCompressed = true) {
    return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
  }
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey3(secretKey) };
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point)
      return true;
    const { secretKey, publicKey, publicKeyUncompressed } = lengths;
    if (Fn.allowedLengths || secretKey === publicKey)
      return void 0;
    const l = ensureBytes("key", item).length;
    return l === publicKey || l === publicKeyUncompressed;
  }
  function getSharedSecret3(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s = _normFnElement(Fn, secretKeyA);
    const b = Point.fromHex(publicKeyB);
    return b.multiply(s).toBytes(isCompressed);
  }
  const utils = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey,
    // TODO: remove
    isValidPrivateKey: isValidSecretKey,
    randomPrivateKey: randomSecretKey,
    normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
    precompute(windowSize = 8, point = Point.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({ getPublicKey: getPublicKey3, getSharedSecret: getSharedSecret3, keygen, Point, utils, lengths });
}
function ecdsa(Point, hash, ecdsaOpts = {}) {
  ahash(hash);
  _validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes2 = ecdsaOpts.randomBytes || randomBytes;
  const hmac2 = ecdsaOpts.hmac || ((key, ...msgs) => hmac(hash, key, concatBytes(...msgs)));
  const { Fp, Fn } = Point;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
  const { keygen, getPublicKey: getPublicKey3, getSharedSecret: getSharedSecret3, utils, lengths } = ecdh(Point, ecdsaOpts);
  const defaultSigOpts = {
    prehash: false,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
    format: void 0,
    //'compact' as ECDSASigFormat,
    extraEntropy: false
  };
  const defaultSigOpts_format = "compact";
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n4;
    return number2 > HALF;
  }
  function validateRS(title, num2) {
    if (!Fn.isValidNot0(num2))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num2;
  }
  function validateSigLength(bytes2, format) {
    validateSigFormat(format);
    const size = lengths.signature;
    const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
    return _abytes2(bytes2, sizer, `${format} signature`);
  }
  class Signature {
    constructor(r, s, recovery) {
      this.r = validateRS("r", r);
      this.s = validateRS("s", s);
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromBytes(bytes2, format = defaultSigOpts_format) {
      validateSigLength(bytes2, format);
      let recid;
      if (format === "der") {
        const { r: r2, s: s2 } = DER.toSig(_abytes2(bytes2));
        return new Signature(r2, s2);
      }
      if (format === "recovered") {
        recid = bytes2[0];
        format = "compact";
        bytes2 = bytes2.subarray(1);
      }
      const L = Fn.BYTES;
      const r = bytes2.subarray(0, L);
      const s = bytes2.subarray(L, L * 2);
      return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
    }
    static fromHex(hex2, format) {
      return this.fromBytes(hexToBytes(hex2), format);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash) {
      const FIELD_ORDER = Fp.ORDER;
      const { r, s, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n2 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
      if (!Fp.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x = Fp.toBytes(radj);
      const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));
      const ir = Fn.inv(radj);
      const h = bits2int_modN(ensureBytes("msgHash", messageHash));
      const u1 = Fn.create(-h * ir);
      const u2 = Fn.create(s * ir);
      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format = defaultSigOpts_format) {
      validateSigFormat(format);
      if (format === "der")
        return hexToBytes(DER.hexFromSig(this));
      const r = Fn.toBytes(this.r);
      const s = Fn.toBytes(this.s);
      if (format === "recovered") {
        if (this.recovery == null)
          throw new Error("recovery bit must be present");
        return concatBytes(Uint8Array.of(this.recovery), r, s);
      }
      return concatBytes(r, s);
    }
    toHex(format) {
      return bytesToHex(this.toBytes(format));
    }
    // TODO: remove
    assertValidity() {
    }
    static fromCompact(hex2) {
      return Signature.fromBytes(ensureBytes("sig", hex2), "compact");
    }
    static fromDER(hex2) {
      return Signature.fromBytes(ensureBytes("sig", hex2), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex(this.toBytes("compact"));
    }
  }
  const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes2) {
    if (bytes2.length > 8192)
      throw new Error("input is too large");
    const num2 = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - fnBits;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes2) {
    return Fn.create(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets(num2) {
    aInRange("num < 2^" + fnBits, num2, _0n4, ORDER_MASK);
    return Fn.toBytes(num2);
  }
  function validateMsgAndHash(message, prehash) {
    _abytes2(message, void 0, "message");
    return prehash ? _abytes2(hash(message), void 0, "prehashed message") : message;
  }
  function prepSig(message, privateKey2, opts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    const h1int = bits2int_modN(message);
    const d = _normFnElement(Fn, privateKey2);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e = extraEntropy === true ? randomBytes2(lengths.secretKey) : extraEntropy;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn.isValidNot0(k))
        return;
      const ik = Fn.inv(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = Fn.create(q.x);
      if (r === _0n4)
        return;
      const s = Fn.create(ik * Fn.create(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = Fn.neg(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  function sign(message, secretKey, opts = {}) {
    message = ensureBytes("message", message);
    const { seed, k2sig } = prepSig(message, secretKey, opts);
    const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac2);
    const sig = drbg(seed, k2sig);
    return sig;
  }
  function tryParsingSig(sg) {
    let sig = void 0;
    const isHex = typeof sg === "string" || isBytes(sg);
    const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (isObj) {
      sig = new Signature(sg.r, sg.s);
    } else if (isHex) {
      try {
        sig = Signature.fromBytes(ensureBytes("sig", sg), "der");
      } catch (derError) {
        if (!(derError instanceof DER.Err))
          throw derError;
      }
      if (!sig) {
        try {
          sig = Signature.fromBytes(ensureBytes("sig", sg), "compact");
        } catch (error) {
          return false;
        }
      }
    }
    if (!sig)
      return false;
    return sig;
  }
  function verify(signature, message, publicKey, opts = {}) {
    const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
    publicKey = ensureBytes("publicKey", publicKey);
    message = validateMsgAndHash(ensureBytes("message", message), prehash);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes(ensureBytes("sig", signature), format);
    if (sig === false)
      return false;
    try {
      const P = Point.fromBytes(publicKey);
      if (lowS && sig.hasHighS())
        return false;
      const { r, s } = sig;
      const h = bits2int_modN(message);
      const is = Fn.inv(s);
      const u1 = Fn.create(h * is);
      const u2 = Fn.create(r * is);
      const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn.create(R.x);
      return v === r;
    } catch (e) {
      return false;
    }
  }
  function recoverPublicKey(signature, message, opts = {}) {
    const { prehash } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey: getPublicKey3,
    getSharedSecret: getSharedSecret3,
    utils,
    lengths,
    Point,
    sign,
    verify,
    recoverPublicKey,
    Signature,
    hash
  });
}
function _weierstrass_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    b: c.b,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp = c.Fp;
  let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
  const Fn = Field(CURVE.n, {
    BITS: c.nBitLength,
    allowedLengths,
    modFromBytes: c.wrapPrivateKey
  });
  const curveOpts = {
    Fp,
    Fn,
    allowInfinityPoint: c.allowInfinityPoint,
    endo: c.endo,
    isTorsionFree: c.isTorsionFree,
    clearCofactor: c.clearCofactor,
    fromBytes: c.fromBytes,
    toBytes: c.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
  const ecdsaOpts = {
    hmac: c.hmac,
    randomBytes: c.randomBytes,
    lowS: c.lowS,
    bits2int: c.bits2int,
    bits2int_modN: c.bits2int_modN
  };
  return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
  const Point = _ecdsa.Point;
  return Object.assign({}, _ecdsa, {
    ProjectivePoint: Point,
    CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS))
  });
}
function weierstrass(c) {
  const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
  const Point = weierstrassN(CURVE, curveOpts);
  const signs = ecdsa(Point, hash, ecdsaOpts);
  return _ecdsa_new_output_to_legacy(c, signs);
}

// node_modules/@noble/curves/esm/_shortw_utils.js
function createCurve(curveDef, defHash) {
  const create = (hash) => weierstrass({ ...curveDef, hash });
  return { ...create(defHash), create };
}

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  anum(value);
  anum(length);
  if (value < 0 || value >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function normDST(DST) {
  if (!isBytes(DST) && typeof DST !== "string")
    throw new Error("DST must be Uint8Array or string");
  return typeof DST === "string" ? utf8ToBytes(DST) : DST;
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255)
    DST = H(concatBytes(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes(...args));
  }
  const pseudo_random_bytes = concatBytes(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  _validateObject(options, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p, k, m, hash, expand: expand2, DST } = options;
  if (!isHash(options.hash))
    throw new Error("expected valid hash");
  abytes(msg);
  anum(count);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand2 === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
  } else if (expand2 === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
  } else if (expand2 === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const coeff = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);
    x = field.mul(xn, xd_inv);
    y = field.mul(y, field.mul(yn, yd_inv));
    return { x, y };
  };
}
var _DST_scalar = utf8ToBytes("HashToScalar-");
function createHasher2(Point, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map(num2) {
    return Point.fromAffine(mapToCurve(num2));
  }
  function clear(initial) {
    const P = initial.clearCofactor();
    if (P.equals(Point.ZERO))
      return Point.ZERO;
    P.assertValidity();
    return P;
  }
  return {
    defaults,
    hashToCurve(msg, options) {
      const opts = Object.assign({}, defaults, options);
      const u = hash_to_field(msg, 2, opts);
      const u0 = map(u[0]);
      const u1 = map(u[1]);
      return clear(u0.add(u1));
    },
    encodeToCurve(msg, options) {
      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
      const opts = Object.assign({}, defaults, optsDst, options);
      const u = hash_to_field(msg, 1, opts);
      const u0 = map(u[0]);
      return clear(u0);
    },
    /** See {@link H2CHasher} */
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i of scalars)
        if (typeof i !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map(scalars));
    },
    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
    hashToScalar(msg, options) {
      const N = Point.Fn.ORDER;
      const opts = Object.assign({}, defaults, { p: N, m: 1, DST: _DST_scalar }, options);
      return hash_to_field(msg, 1, opts)[0][0];
    }
  };
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n3 = BigInt(2);
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n3, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n3, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
var secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(utf8ToBytes(tag));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes(tagP, ...messages));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var Pointk1 = (() => secp256k1.Point)();
var hasEven = (y) => y % _2n3 === _0n5;
function schnorrGetExtPubKey(priv) {
  const { Fn, BASE } = Pointk1;
  const d_ = _normFnElement(Fn, priv);
  const p = BASE.multiply(d_);
  const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  const Fp = Fpk1;
  if (!Fp.isValidNot0(x))
    throw new Error("invalid x: Fail if x â¥ p");
  const xx = Fp.create(x * x);
  const c = Fp.create(xx * x + BigInt(7));
  let y = Fp.sqrt(c);
  if (!hasEven(y))
    y = Fp.neg(y);
  const p = Pointk1.fromAffine({ x, y });
  p.assertValidity();
  return p;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message, secretKey, auxRand = randomBytes(32)) {
  const { Fn } = Pointk1;
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = Fn.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const { Fn, BASE } = Pointk1;
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n5, secp256k1_CURVE.p))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n5, secp256k1_CURVE.n))
      return false;
    const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
    const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
    const { x, y } = R.toAffine();
    if (R.is0() || !hasEven(y) || x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => {
  const size = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes(seedLength)) => {
    return mapHashToField(seed, secp256k1_CURVE.n);
  };
  secp256k1.utils.randomSecretKey;
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
  }
  return {
    keygen,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    Point: Pointk1,
    utils: {
      randomSecretKey,
      randomPrivateKey: randomSecretKey,
      taggedHash,
      // TODO: remove
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      mod
    },
    lengths: {
      secretKey: size,
      publicKey: size,
      publicKeyHasPrefix: false,
      signature: size * 2,
      seed: seedLength
    }
  };
})();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = (() => createHasher2(secp256k1.Point, (scalars) => {
  const { x, y } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => secp256k1_hasher.hashToCurve)();
var encodeToCurve = (() => secp256k1_hasher.encodeToCurve)();

// node_modules/snstr/dist/esm/src/utils/crypto.js
async function signEvent(eventId, privateKey2) {
  const privateKeyBytes = hexToBytes(privateKey2);
  const eventIdBytes = hexToBytes(eventId);
  const signatureBytes = await schnorr.sign(eventIdBytes, privateKeyBytes);
  return bytesToHex(signatureBytes);
}
async function verifySignature(eventId, signature, publicKey) {
  try {
    const eventIdBytes = hexToBytes(eventId);
    const signatureBytes = hexToBytes(signature);
    const publicKeyBytes = hexToBytes(publicKey);
    return await schnorr.verify(signatureBytes, eventIdBytes, publicKeyBytes);
  } catch (error) {
    console.error("Failed to verify signature:", error);
    return false;
  }
}
async function generateKeypair() {
  const privateKey2 = bytesToHex(schnorr.utils.randomPrivateKey());
  const publicKey = getPublicKey(privateKey2);
  return { privateKey: privateKey2, publicKey };
}
function getPublicKey(privateKey2) {
  const privateKeyBytes = hexToBytes(privateKey2);
  const publicKeyBytes = schnorr.getPublicKey(privateKeyBytes);
  return bytesToHex(publicKeyBytes);
}
function sha256Hex(data) {
  if (typeof data === "string") {
    data = new TextEncoder().encode(data);
  }
  return bytesToHex(sha256(data));
}

// node_modules/@scure/base/lib/esm/index.js
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes2(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber2(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode3 = args.map((x) => x.decode).reduce(wrap, id);
  return { encode, decode: decode3 };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber2(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  afn(fn);
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber2(d);
    if (d < 0 || d >= from)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < dlen; i++) {
      const digit = digits[i];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
var radix2carry = (from, to) => from + (to - gcd(from, to));
var powers = (() => {
  let res = [];
  for (let i = 0; i < 40; i++)
    res.push(2 ** i);
  return res;
})();
function convertRadix2(data, from, to, padding2) {
  aArr(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from];
  const mask = powers[to] - 1;
  const res = [];
  for (const n of data) {
    anumber2(n);
    if (n >= max)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
    carry = carry << from | n;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num2) {
  anumber2(num2);
  const _256 = 2 ** 8;
  return {
    encode: (bytes2) => {
      if (!isBytes2(bytes2))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes2), _256, num2);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num2, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber2(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!isBytes2(bytes2))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  afn(fn);
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var decodeBase64Builtin = (s, isUrl) => {
  astr("base64", s);
  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
  const alphabet2 = isUrl ? "base64url" : "base64";
  if (s.length > 0 && !re.test(s))
    throw new Error("invalid base64");
  return Uint8Array.fromBase64(s, { alphabet: alphabet2, lastChunkHandling: "strict" });
};
var base64 = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64();
  },
  decode(s) {
    return decodeBase64Builtin(s, false);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64({ alphabet: "base64url" });
  },
  decode(s) {
    return decodeBase64Builtin(s, true);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b >> i & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i = 0; i < len; i++) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i = 0; i < len; i++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i = 0; i < 6; i++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes2(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode3(str, limit = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode3);
  function decodeToBytes(str) {
    const { prefix, words } = decode3(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes2) {
    return encode(prefix, toWords(bytes2));
  }
  return {
    encode,
    decode: decode3,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hasHexBuiltin2 = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes2(data);
    return data.toHex();
  },
  decode(s) {
    astr("hex", s);
    return Uint8Array.fromHex(s);
  }
};
var hex = hasHexBuiltin2 ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/snstr/dist/esm/src/nip19/types.js
var Prefix;
(function(Prefix2) {
  Prefix2["PublicKey"] = "npub";
  Prefix2["PrivateKey"] = "nsec";
  Prefix2["Note"] = "note";
  Prefix2["Profile"] = "nprofile";
  Prefix2["Event"] = "nevent";
  Prefix2["Address"] = "naddr";
})(Prefix || (Prefix = {}));
var TLVType;
(function(TLVType2) {
  TLVType2[TLVType2["Special"] = 0] = "Special";
  TLVType2[TLVType2["Relay"] = 1] = "Relay";
  TLVType2[TLVType2["Author"] = 2] = "Author";
  TLVType2[TLVType2["Kind"] = 3] = "Kind";
})(TLVType || (TLVType = {}));

// node_modules/snstr/dist/esm/src/nip19/secure.js
function isValidHostname(hostname) {
  if (!hostname || typeof hostname !== "string") {
    return false;
  }
  if (hostname.length > 255) {
    return false;
  }
  if (hostname.startsWith(".") || hostname.endsWith(".")) {
    return false;
  }
  if (hostname.includes("..")) {
    return false;
  }
  const labels = hostname.split(".");
  if (labels.length === 0) {
    return false;
  }
  for (const label of labels) {
    if (label.length === 0 || label.length > 63) {
      return false;
    }
    if (label.startsWith("-") || label.endsWith("-")) {
      return false;
    }
    if (!/^[a-zA-Z0-9-]+$/.test(label)) {
      return false;
    }
  }
  return true;
}
function isValidRelayUrl(url) {
  try {
    if (!url.startsWith("wss://") && !url.startsWith("ws://")) {
      return false;
    }
    if ([...url].some((char) => {
      const code = char.charCodeAt(0);
      return code <= 31 || code >= 127 && code <= 159;
    })) {
      return false;
    }
    if (url.includes("%00") || url.toLowerCase().includes("%0a") || url.toLowerCase().includes("%0d")) {
      return false;
    }
    if (url.includes("@")) {
      return false;
    }
    if (url.includes("\\")) {
      return false;
    }
    if (/^ws+:\/\/\//.test(url)) {
      return false;
    }
    const normalized = url.toLowerCase();
    if (!normalized.match(new RegExp("^wss://[^/]|^ws://[^/]"))) {
      return false;
    }
    const parsedUrl = new URL(url);
    if (parsedUrl.username || parsedUrl.password) {
      return false;
    }
    if (parsedUrl.port) {
      const portNum = parseInt(parsedUrl.port, 10);
      if (isNaN(portNum) || portNum <= 0 || portNum > 65535) {
        return false;
      }
    }
    if (parsedUrl.hostname.startsWith("[") && parsedUrl.hostname.endsWith("]")) {
      const ipv6Content = parsedUrl.hostname.slice(1, -1);
      if (ipv6Content.length === 0) {
        return false;
      }
    } else {
      if (!isValidHostname(parsedUrl.hostname)) {
        return false;
      }
    }
    if (parsedUrl.hostname.length === 0) {
      return false;
    }
    if (parsedUrl.search && (parsedUrl.search.includes("%00") || parsedUrl.search.toLowerCase().includes("%0a") || parsedUrl.search.toLowerCase().includes("%0d"))) {
      return false;
    }
    return true;
  } catch (error) {
    return false;
  }
}

// node_modules/snstr/dist/esm/src/nip19/index.js
var DEFAULT_LIMIT = 5e3;
var MAX_RELAY_URL_LENGTH = 512;
var MAX_IDENTIFIER_LENGTH = 1024;
var MAX_TLV_ENTRIES = 20;
function encodeBech32WithLimit(prefix, words, limit = DEFAULT_LIMIT) {
  try {
    return bech32.encode(prefix, words, limit);
  } catch (error) {
    throw new Error(`Failed to encode bech32: ${error instanceof Error ? error.message : "unknown error"}`);
  }
}
function decodeBech32WithLimit(bech32Str, limit = DEFAULT_LIMIT) {
  try {
    return bech32.decode(bech32Str, limit);
  } catch (error) {
    throw new Error(`Failed to decode bech32: ${error instanceof Error ? error.message : "unknown error"}`);
  }
}
function encodeBech32(prefix, data) {
  const dataBytes = hexToBytes2(data);
  const words = bech32.toWords(dataBytes);
  return bech32.encode(prefix, words);
}
function decodeBech32(bech32Str) {
  const hrp = bech32Str.slice(0, bech32Str.indexOf("1"));
  try {
    const { prefix, words } = bech32.decode(bech32Str);
    const bytes2 = bech32.fromWords(words);
    const data = bytesToHex2(bytes2);
    return { prefix, data };
  } catch (error) {
    if (error instanceof Error && error.message.includes("invalid string length") && !Object.values(Prefix).includes(hrp)) {
      throw new Error(`Invalid prefix: expected valid prefix, got '${hrp}'`);
    }
    throw error;
  }
}
function encodePublicKey(publicKey) {
  if (typeof publicKey !== "string") {
    throw new Error("Invalid public key: input must be a string.");
  }
  const bytes2 = hexToBytes2(publicKey);
  if (bytes2.length !== 32) {
    throw new Error(`Invalid public key hex: expected 32 bytes (64 hex chars), got ${bytes2.length} bytes (${publicKey.length} hex chars). Ensure it is not empty and has correct length.`);
  }
  const words = bech32.toWords(bytes2);
  return encodeBech32WithLimit(Prefix.PublicKey, words);
}
function handleDecodingError(error, entityType) {
  if (error instanceof Error) {
    if (error.message.includes("invalid string length") && error.message.includes("Expected") && error.message.includes(")")) {
      const match = error.message.match(/\(([^)]+)\)/);
      if (match && match[1]) {
        const bech32Str = match[1];
        const actualPrefix = bech32Str.split("1")[0];
        const expectedPrefix = getExpectedPrefixForEntityType(entityType);
        if (actualPrefix && expectedPrefix && actualPrefix !== expectedPrefix) {
          throw new Error(`Invalid prefix: expected '${expectedPrefix}', got '${actualPrefix}'`);
        }
      }
    }
    if (error.message.startsWith("Invalid prefix") || error.message.startsWith("TLV type") || error.message.startsWith("Missing") || error.message.includes("should be") || error.message.startsWith("Invalid TLV structure") || error.message.startsWith("Invalid relay URL") || error.message.includes("too long") || error.message.includes("exceeds maximum")) {
      throw error;
    }
    if (error.message.startsWith("Failed to decode bech32")) {
      throw new Error(`Invalid ${entityType} format: bech32 decoding failed - ${error.message}`);
    }
    if (error.message.includes("Invalid")) {
      throw new Error(`Invalid ${entityType} format: ${error.message}`);
    }
  }
  const errorMessage = error instanceof Error ? error.message : String(error) || "unknown error";
  throw new Error(`Error decoding ${entityType}: ${errorMessage}`);
}
function getExpectedPrefixForEntityType(entityType) {
  switch (entityType) {
    case "npub":
      return Prefix.PublicKey;
    case "nsec":
      return Prefix.PrivateKey;
    case "note":
      return Prefix.Note;
    case "nprofile":
      return Prefix.Profile;
    case "nevent":
      return Prefix.Event;
    case "naddr":
      return Prefix.Address;
    default:
      return null;
  }
}
function decodePublicKey(npub) {
  try {
    const { prefix, data } = decodeBech32(npub);
    if (prefix !== Prefix.PublicKey) {
      throw new Error(`Invalid prefix: expected '${Prefix.PublicKey}', got '${prefix}'`);
    }
    return data;
  } catch (error) {
    handleDecodingError(error, "npub");
  }
}
function encodePrivateKey(privateKey2) {
  if (typeof privateKey2 !== "string") {
    throw new Error("Invalid private key: input must be a string.");
  }
  const bytes2 = hexToBytes2(privateKey2);
  if (bytes2.length !== 32) {
    throw new Error(`Invalid private key hex: expected 32 bytes (64 hex chars), got ${bytes2.length} bytes (${privateKey2.length} hex chars). Ensure it is not empty and has correct length.`);
  }
  const words = bech32.toWords(bytes2);
  return encodeBech32WithLimit(Prefix.PrivateKey, words);
}
function decodePrivateKey(nsec) {
  try {
    const { prefix, data } = decodeBech32(nsec);
    if (prefix !== Prefix.PrivateKey) {
      throw new Error(`Invalid prefix: expected '${Prefix.PrivateKey}', got '${prefix}'`);
    }
    return data;
  } catch (error) {
    handleDecodingError(error, "nsec");
  }
}
function encodeNoteId(noteId) {
  if (typeof noteId !== "string") {
    throw new Error("Invalid note ID: input must be a string.");
  }
  const bytes2 = hexToBytes2(noteId);
  if (bytes2.length !== 32) {
    throw new Error(`Invalid note ID hex: expected 32 bytes (64 hex chars), got ${bytes2.length} bytes (${noteId.length} hex chars). Ensure it is not empty and has correct length.`);
  }
  const words = bech32.toWords(bytes2);
  return encodeBech32WithLimit(Prefix.Note, words);
}
function decodeNoteId(note) {
  try {
    const { prefix, data } = decodeBech32(note);
    if (prefix !== Prefix.Note) {
      throw new Error(`Invalid prefix: expected '${Prefix.Note}', got '${prefix}'`);
    }
    return data;
  } catch (error) {
    handleDecodingError(error, "note");
  }
}
function encodeTLV(entries) {
  let totalLength = 0;
  for (const entry of entries) {
    totalLength += 2 + entry.value.length;
  }
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const entry of entries) {
    result[offset++] = entry.type;
    result[offset++] = entry.value.length;
    result.set(entry.value, offset);
    offset += entry.value.length;
  }
  return result;
}
function decodeTLV(data) {
  const entries = [];
  let offset = 0;
  while (offset < data.length - 1) {
    const type = data[offset++];
    const length = data[offset++];
    if (offset + length > data.length) {
      throw new Error("Invalid TLV structure: data too short");
    }
    const value = data.slice(offset, offset + length);
    offset += length;
    if (entries.length >= MAX_TLV_ENTRIES) {
      throw new Error(`TLV entry count exceeds maximum of ${MAX_TLV_ENTRIES}`);
    }
    entries.push({ type, value });
  }
  return entries;
}
function encodeProfile(data) {
  if (!data.pubkey || data.pubkey.length !== 64) {
    throw new Error("Invalid pubkey: must be a 32-byte hex string");
  }
  const entries = [
    {
      type: TLVType.Special,
      value: hexToBytes2(data.pubkey)
    }
  ];
  if (data.relays && data.relays.length > 0) {
    if (data.relays.length > MAX_TLV_ENTRIES - 1) {
      throw new Error(`Too many relay entries (max ${MAX_TLV_ENTRIES - 1})`);
    }
    for (const relay of data.relays) {
      if (relay.length > MAX_RELAY_URL_LENGTH) {
        throw new Error(`Relay URL too long (max ${MAX_RELAY_URL_LENGTH} characters)`);
      }
      if (!isValidRelayUrl(relay)) {
        throw new Error(`Invalid relay URL: ${relay}`);
      }
      entries.push({
        type: TLVType.Relay,
        value: new TextEncoder().encode(relay)
      });
    }
  }
  const tlvData = encodeTLV(entries);
  const words = bech32.toWords(tlvData);
  return encodeBech32WithLimit(Prefix.Profile, words);
}
function decodeProfile(nprofile) {
  try {
    const { prefix, words } = decodeBech32WithLimit(nprofile);
    if (prefix !== Prefix.Profile) {
      throw new Error(`Invalid prefix: expected '${Prefix.Profile}', got '${prefix}'`);
    }
    const data = bech32.fromWords(words);
    const entries = decodeTLV(data);
    let pubkey2;
    const relays = [];
    for (const entry of entries) {
      if (entry.type === TLVType.Special) {
        if (entry.value.length !== 32) {
          throw new Error("Invalid pubkey length: should be 32 bytes");
        }
        pubkey2 = bytesToHex2(entry.value);
      } else if (entry.type === TLVType.Relay) {
        const relay = new TextDecoder().decode(entry.value);
        relays.push(relay);
        if (!isValidRelayUrl(relay)) {
          console.warn(`Warning: Invalid relay URL format found while decoding: ${relay}`);
        }
      }
    }
    if (!pubkey2) {
      throw new Error("Missing pubkey in nprofile");
    }
    return {
      pubkey: pubkey2,
      relays: relays.length > 0 ? relays : void 0
    };
  } catch (error) {
    handleDecodingError(error, "nprofile");
  }
}
function encodeEvent(data) {
  if (!data.id || data.id.length !== 64) {
    throw new Error("Invalid event ID: must be a 32-byte hex string");
  }
  const entries = [
    {
      type: TLVType.Special,
      value: hexToBytes2(data.id)
    }
  ];
  if (data.relays && data.relays.length > 0) {
    if (data.relays.length > MAX_TLV_ENTRIES - 3) {
      throw new Error(`Too many relay entries (max ${MAX_TLV_ENTRIES - 3})`);
    }
    for (const relay of data.relays) {
      if (relay.length > MAX_RELAY_URL_LENGTH) {
        throw new Error(`Relay URL too long (max ${MAX_RELAY_URL_LENGTH} characters)`);
      }
      if (!isValidRelayUrl(relay)) {
        throw new Error(`Invalid relay URL: ${relay}`);
      }
      entries.push({
        type: TLVType.Relay,
        value: new TextEncoder().encode(relay)
      });
    }
  }
  if (data.author) {
    if (data.author.length !== 64) {
      throw new Error("Invalid author pubkey: must be a 32-byte hex string");
    }
    entries.push({
      type: TLVType.Author,
      value: hexToBytes2(data.author)
    });
  }
  const tlvData = encodeTLV(entries);
  const words = bech32.toWords(tlvData);
  return encodeBech32WithLimit(Prefix.Event, words);
}
function decodeEvent(nevent) {
  try {
    const { prefix, words } = decodeBech32WithLimit(nevent);
    if (prefix !== Prefix.Event) {
      throw new Error(`Invalid prefix: expected '${Prefix.Event}', got '${prefix}'`);
    }
    const data = bech32.fromWords(words);
    const entries = decodeTLV(data);
    let id;
    const relays = [];
    let author;
    for (const entry of entries) {
      if (entry.type === TLVType.Special) {
        if (entry.value.length !== 32) {
          throw new Error("Invalid event ID length: should be 32 bytes");
        }
        id = bytesToHex2(entry.value);
      } else if (entry.type === TLVType.Relay) {
        const relay = new TextDecoder().decode(entry.value);
        relays.push(relay);
        if (!isValidRelayUrl(relay)) {
          console.warn(`Warning: Invalid relay URL format found while decoding: ${relay}`);
        }
      } else if (entry.type === TLVType.Author) {
        if (entry.value.length !== 32) {
          throw new Error("Invalid author pubkey length: should be 32 bytes");
        }
        author = bytesToHex2(entry.value);
      }
    }
    if (!id) {
      throw new Error("Missing event ID in nevent");
    }
    return {
      id,
      relays: relays.length > 0 ? relays : void 0,
      author
    };
  } catch (error) {
    handleDecodingError(error, "nevent");
  }
}
function encodeAddress(data) {
  if (!data.identifier) {
    throw new Error("Missing identifier in address data");
  }
  if (!data.pubkey || data.pubkey.length !== 64) {
    throw new Error("Invalid pubkey: must be a 32-byte hex string");
  }
  if (data.kind === void 0 || data.kind < 0 || data.kind > 4294967295) {
    throw new Error("Invalid kind: must be a 32-bit unsigned integer (0 to 4294967295)");
  }
  if (data.identifier.length > MAX_IDENTIFIER_LENGTH) {
    throw new Error(`Identifier too long (max ${MAX_IDENTIFIER_LENGTH} characters)`);
  }
  const entries = [
    {
      type: TLVType.Special,
      value: new TextEncoder().encode(data.identifier)
    }
  ];
  if (data.relays && data.relays.length > 0) {
    if (data.relays.length > MAX_TLV_ENTRIES - 3) {
      throw new Error(`Too many relay entries (max ${MAX_TLV_ENTRIES - 3})`);
    }
    for (const relay of data.relays) {
      if (relay.length > MAX_RELAY_URL_LENGTH) {
        throw new Error(`Relay URL too long (max ${MAX_RELAY_URL_LENGTH} characters)`);
      }
      if (!isValidRelayUrl(relay)) {
        throw new Error(`Invalid relay URL: ${relay}`);
      }
      entries.push({
        type: TLVType.Relay,
        value: new TextEncoder().encode(relay)
      });
    }
  }
  entries.push({
    type: TLVType.Author,
    value: hexToBytes2(data.pubkey)
  });
  const kindBytes = new Uint8Array(4);
  kindBytes[0] = data.kind >> 24 & 255;
  kindBytes[1] = data.kind >> 16 & 255;
  kindBytes[2] = data.kind >> 8 & 255;
  kindBytes[3] = data.kind & 255;
  entries.push({
    type: TLVType.Kind,
    value: kindBytes
  });
  const tlvData = encodeTLV(entries);
  const words = bech32.toWords(tlvData);
  return encodeBech32WithLimit(Prefix.Address, words);
}
function decodeAddress(naddr) {
  try {
    const { prefix, words } = decodeBech32WithLimit(naddr);
    if (prefix !== Prefix.Address) {
      throw new Error(`Invalid prefix: expected '${Prefix.Address}', got '${prefix}'`);
    }
    const data = bech32.fromWords(words);
    const entries = decodeTLV(data);
    let identifier;
    const relays = [];
    let pubkey2;
    let kind;
    for (const entry of entries) {
      if (entry.type === TLVType.Special) {
        identifier = new TextDecoder().decode(entry.value);
      } else if (entry.type === TLVType.Relay) {
        const relay = new TextDecoder().decode(entry.value);
        relays.push(relay);
        if (!isValidRelayUrl(relay)) {
          console.warn(`Warning: Invalid relay URL format found while decoding: ${relay}`);
        }
      } else if (entry.type === TLVType.Author) {
        if (entry.value.length !== 32) {
          throw new Error("Invalid pubkey length: should be 32 bytes");
        }
        pubkey2 = bytesToHex2(entry.value);
      } else if (entry.type === TLVType.Kind) {
        if (entry.value.length !== 4) {
          throw new Error("Invalid kind length: should be 4 bytes");
        }
        kind = (entry.value[0] << 24) + (entry.value[1] << 16) + (entry.value[2] << 8) + entry.value[3];
      }
    }
    if (!identifier) {
      throw new Error("Missing identifier in naddr");
    }
    if (!pubkey2) {
      throw new Error("Missing pubkey in naddr");
    }
    if (kind === void 0) {
      throw new Error("Missing kind in naddr");
    }
    return {
      identifier,
      pubkey: pubkey2,
      kind,
      relays: relays.length > 0 ? relays : void 0
    };
  } catch (error) {
    handleDecodingError(error, "naddr");
  }
}
function hexToBytes2(hex2) {
  if (typeof hex2 !== "string") {
    throw new Error("Invalid hex string: input must be a string.");
  }
  if (hex2.length === 0) {
    throw new Error("Invalid hex string: cannot be empty.");
  }
  if (hex2.length % 2 !== 0) {
    throw new Error("Invalid hex string: length must be even.");
  }
  if (!/^[0-9a-fA-F]*$/.test(hex2)) {
    throw new Error("Invalid hex string: contains non-hex characters.");
  }
  const bytes2 = new Uint8Array(hex2.length / 2);
  for (let i = 0; i < bytes2.length; i++) {
    const start = i * 2;
    const hexByte = hex2.slice(start, start + 2);
    const byte = parseInt(hexByte, 16);
    if (isNaN(byte)) {
      throw new Error(`Invalid hex string: "${hexByte}" is not a valid hex byte`);
    }
    bytes2[i] = byte;
  }
  return bytes2;
}
function bytesToHex2(bytes2) {
  let hex2 = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex2 += bytes2[i].toString(16).padStart(2, "0");
  }
  return hex2;
}
function decode(bech32Str) {
  if (!bech32Str.includes("1")) {
    throw new Error("Invalid bech32 string format: missing separator character '1'");
  }
  const prefix = bech32Str.slice(0, bech32Str.indexOf("1"));
  switch (prefix) {
    case Prefix.PublicKey:
      return {
        type: Prefix.PublicKey,
        data: decodePublicKey(bech32Str)
      };
    case Prefix.PrivateKey:
      return {
        type: Prefix.PrivateKey,
        data: decodePrivateKey(bech32Str)
      };
    case Prefix.Note:
      return {
        type: Prefix.Note,
        data: decodeNoteId(bech32Str)
      };
    case Prefix.Profile:
      return {
        type: Prefix.Profile,
        data: decodeProfile(bech32Str)
      };
    case Prefix.Event:
      return {
        type: Prefix.Event,
        data: decodeEvent(bech32Str)
      };
    case Prefix.Address:
      return {
        type: Prefix.Address,
        data: decodeAddress(bech32Str)
      };
    default:
      throw new Error(`Unknown prefix: ${prefix}`);
  }
}

// node_modules/@noble/hashes/esm/hkdf.js
function extract(hash, ikm, salt) {
  ahash(hash);
  if (salt === void 0)
    salt = new Uint8Array(hash.outputLen);
  return hmac(hash, toBytes(salt), toBytes(ikm));
}
var HKDF_COUNTER = Uint8Array.from([0]);
var EMPTY_BUFFER = Uint8Array.of();
function expand(hash, prk, info, length = 32) {
  ahash(hash);
  anumber(length);
  const olen = hash.outputLen;
  if (length > 255 * olen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length / olen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  const okm = new Uint8Array(blocks * olen);
  const HMAC2 = hmac.create(hash, prk);
  const HMACTmp = HMAC2._cloneInto();
  const T = new Uint8Array(HMAC2.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, olen * counter);
    HMAC2._cloneInto(HMACTmp);
  }
  HMAC2.destroy();
  HMACTmp.destroy();
  clean(T, HKDF_COUNTER);
  return okm.slice(0, length);
}

// node_modules/@noble/ciphers/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function isBytes3(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
var hexes2 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  else if (isBytes3(data))
    data = data.slice();
  else
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
    throw new Error("options must be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function ensureBytes2(b, len) {
  if (!isBytes3(b))
    throw new Error("Uint8Array expected");
  if (typeof len === "number") {
    if (b.length !== len)
      throw new Error(`Uint8Array length ${len} expected`);
  }
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
var wrapCipher = (params, c) => {
  Object.assign(c, params);
  return c;
};
function setBigUint642(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}

// node_modules/@noble/ciphers/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function isBytes4(a) {
  return a != null && typeof a === "object" && (a instanceof Uint8Array || a.constructor.name === "Uint8Array");
}
function bytes(b, ...lengths) {
  if (!isBytes4(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
var Poly1305 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes2(key);
    ensureBytes2(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i = 0; i < 8; i++)
      this.pad[i] = u8to16(key, 16 + 2 * i);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad: pad2 } = this;
    const g = new Uint16Array(10);
    let c = h[1] >>> 13;
    h[1] &= 8191;
    for (let i = 2; i < 10; i++) {
      h[i] += c;
      c = h[i] >>> 13;
      h[i] &= 8191;
    }
    h[0] += c * 5;
    c = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c;
    c = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c;
    g[0] = h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i = 1; i < 10; i++) {
      g[i] = h[i] + c;
      c = g[i] >>> 13;
      g[i] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i = 0; i < 10; i++)
      g[i] &= mask;
    mask = ~mask;
    for (let i = 0; i < 10; i++)
      h[i] = h[i] & mask | g[i];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f = h[0] + pad2[0];
    h[0] = f & 65535;
    for (let i = 1; i < 8; i++) {
      f = (h[i] + pad2[i] | 0) + (f >>> 16) | 0;
      h[i] = f & 65535;
    }
  }
  update(data) {
    exists(this);
    const { buffer, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(buffer, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    this.h.fill(0);
    this.r.fill(0);
    this.buffer.fill(0);
    this.pad.fill(0);
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, h } = this;
    let { pos } = this;
    if (pos) {
      buffer[pos++] = 1;
      for (; pos < 16; pos++)
        buffer[pos] = 0;
      this.process(buffer, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i = 0; i < 8; i++) {
      out[opos++] = h[i] >>> 0;
      out[opos++] = h[i] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes2(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

// node_modules/@noble/ciphers/esm/_arx.js
var sigma16 = utf8ToBytes2("expand 16-byte k");
var sigma32 = utf8ToBytes2("expand 32-byte k");
var sigma16_32 = u32(sigma16);
var sigma32_32 = u32(sigma32);
function rotl(a, b) {
  return a << b | a >>> 32 - b;
}
function isAligned32(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = new Uint32Array();
function runCipher(core, sigma, key, nonce, data, output2, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u32(block);
  const isAligned = isAligned32(data) && isAligned32(output2);
  const d32 = isAligned ? u32(data) : U32_EMPTY;
  const o32 = isAligned ? u32(output2) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core(sigma, key, nonce, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take; j++) {
      posj = pos + j;
      output2[posj] = data[posj] ^ block[j];
    }
    pos += take;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  number(counterLength);
  number(rounds);
  bool(counterRight);
  bool(allowShortKeys);
  return (key, nonce, data, output2, counter = 0) => {
    bytes(key);
    bytes(nonce);
    bytes(data);
    const len = data.length;
    if (!output2)
      output2 = new Uint8Array(len);
    bytes(output2);
    number(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output2.length < len)
      throw new Error(`arx: output (${output2.length}) is shorter than data (${len})`);
    const toClean = [];
    let l = key.length, k, sigma;
    if (l === 32) {
      k = key.slice();
      toClean.push(k);
      sigma = sigma32_32;
    } else if (l === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else {
      throw new Error(`arx: invalid 32-byte key, got length=${l}`);
    }
    if (!isAligned32(nonce)) {
      nonce = nonce.slice();
      toClean.push(nonce);
    }
    const k32 = u32(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u32(nonce);
    runCipher(core, sigma, k32, n32, data, output2, counter, rounds);
    while (toClean.length > 0)
      toClean.pop().fill(0);
    return output2;
  };
}

// node_modules/@noble/ciphers/esm/chacha.js
function chachaCore(s, k, n, out, cnt, rounds = 20) {
  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r = 0; r < rounds; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s, k, i, o32) {
  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
  for (let r = 0; r < 20; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x01;
  o32[oi++] = x02;
  o32[oi++] = x03;
  o32[oi++] = x12;
  o32[oi++] = x13;
  o32[oi++] = x14;
  o32[oi++] = x15;
}
var chacha20orig = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  allowShortKeys: true
});
var chacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
var chacha8 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 8
});
var chacha12 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 12
});
var ZEROS16 = new Uint8Array(16);
var updatePadded = (h, msg) => {
  h.update(msg);
  const left = msg.length % 16;
  if (left)
    h.update(ZEROS16.subarray(left));
};
var ZEROS32 = new Uint8Array(32);
function computeTag(fn, key, nonce, data, AAD) {
  const authKey = fn(key, nonce, ZEROS32);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, data);
  const num2 = new Uint8Array(16);
  const view = createView2(num2);
  setBigUint642(view, 0, BigInt(AAD ? AAD.length : 0), true);
  setBigUint642(view, 8, BigInt(data.length), true);
  h.update(num2);
  const res = h.digest();
  authKey.fill(0);
  return res;
}
var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
  const tagLength = 16;
  ensureBytes2(key, 32);
  ensureBytes2(nonce);
  return {
    encrypt: (plaintext, output2) => {
      const plength = plaintext.length;
      const clength = plength + tagLength;
      if (output2) {
        ensureBytes2(output2, clength);
      } else {
        output2 = new Uint8Array(clength);
      }
      xorStream(key, nonce, plaintext, output2, 1);
      const tag = computeTag(xorStream, key, nonce, output2.subarray(0, -tagLength), AAD);
      output2.set(tag, plength);
      return output2;
    },
    decrypt: (ciphertext, output2) => {
      const clength = ciphertext.length;
      const plength = clength - tagLength;
      if (clength < tagLength)
        throw new Error(`encrypted data must be at least ${tagLength} bytes`);
      if (output2) {
        ensureBytes2(output2, plength);
      } else {
        output2 = new Uint8Array(plength);
      }
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag(xorStream, key, nonce, data, AAD);
      if (!equalBytes(passedTag, tag))
        throw new Error("invalid tag");
      xorStream(key, nonce, data, output2, 1);
      return output2;
    }
  };
};
var chacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
var xchacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

// node_modules/snstr/dist/esm/src/nip44/index.js
var CURRENT_VERSION = 2;
var MIN_SUPPORTED_VERSION = 0;
var MAX_SUPPORTED_VERSION = 2;
var NONCE_SIZE_V0 = 32;
var NONCE_SIZE_V1 = 32;
var NONCE_SIZE_V2 = 32;
var MAC_SIZE_V0 = 32;
var MAC_SIZE_V1 = 32;
var MAC_SIZE_V2 = 32;
var KEY_SIZE = 32;
var MIN_PLAINTEXT_SIZE = 1;
var MAX_PLAINTEXT_SIZE = 65535;
var VERSION_BYTE_SIZE = 1;
var MIN_BASE64_PAYLOAD_LENGTH = 132;
var MAX_BASE64_PAYLOAD_LENGTH = 87472;
var MIN_DECODED_PAYLOAD_LENGTH = 99;
var MAX_DECODED_PAYLOAD_LENGTH = 65603;
function base64Encode(bytes2) {
  if (typeof globalThis?.btoa === "function") {
    try {
      return globalThis.btoa(String.fromCharCode(...bytes2));
    } catch (error) {
    }
  }
  if (typeof Buffer !== "undefined") {
    try {
      return Buffer.from(bytes2).toString("base64");
    } catch (error) {
    }
  }
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  let result = "";
  let i = 0;
  while (i < bytes2.length) {
    const a = bytes2[i++];
    const b = i < bytes2.length ? bytes2[i++] : 0;
    const c = i < bytes2.length ? bytes2[i++] : 0;
    const bitmap = a << 16 | b << 8 | c;
    result += chars.charAt(bitmap >> 18 & 63);
    result += chars.charAt(bitmap >> 12 & 63);
    result += i - 2 < bytes2.length ? chars.charAt(bitmap >> 6 & 63) : "=";
    result += i - 1 < bytes2.length ? chars.charAt(bitmap & 63) : "=";
  }
  return result;
}
var BASE64_VALIDATION_REGEX = /^(?:(?:[A-Za-z0-9+/]{4})+(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?|[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)$/;
function base64Decode(str) {
  if (!BASE64_VALIDATION_REGEX.test(str)) {
    throw new Error("NIP-44: Invalid base64 alphabet in ciphertext");
  }
  if (typeof globalThis?.atob === "function") {
    try {
      const binaryString = globalThis.atob(str);
      const bytes3 = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes3[i] = binaryString.charCodeAt(i);
      }
      return bytes3;
    } catch (error) {
      throw new Error("NIP-44: Invalid base64 encoding in ciphertext");
    }
  }
  if (typeof Buffer !== "undefined") {
    try {
      return new Uint8Array(Buffer.from(str, "base64"));
    } catch (error) {
      throw new Error("NIP-44: Invalid base64 encoding in ciphertext");
    }
  }
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  const lookup = new Array(256).fill(-1);
  for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }
  lookup["=".charCodeAt(0)] = 0;
  const len = str.length;
  let bufferLength = Math.floor(len * 0.75);
  if (str[len - 1] === "=") {
    bufferLength--;
    if (str[len - 2] === "=") {
      bufferLength--;
    }
  }
  const bytes2 = new Uint8Array(bufferLength);
  let p = 0;
  for (let i = 0; i < len; i += 4) {
    const encoded1 = lookup[str.charCodeAt(i)];
    const encoded2 = lookup[str.charCodeAt(i + 1)];
    const encoded3 = lookup[str.charCodeAt(i + 2)];
    const encoded4 = lookup[str.charCodeAt(i + 3)];
    if (encoded1 === -1 || encoded2 === -1 || encoded3 === -1 || encoded4 === -1) {
      throw new Error("NIP-44: Invalid base64 encoding in ciphertext");
    }
    bytes2[p++] = encoded1 << 2 | encoded2 >> 4;
    if (p < bufferLength) {
      bytes2[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    }
    if (p < bufferLength) {
      bytes2[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
  }
  return bytes2;
}
function calcPaddedLen(unpadded_len) {
  if (unpadded_len <= 0 || unpadded_len > MAX_PLAINTEXT_SIZE) {
    throw new Error(`NIP-44: Invalid plaintext length: ${unpadded_len}`);
  }
  if (unpadded_len <= 32) {
    return 32;
  }
  const nextPower = 1 << Math.floor(Math.log2(unpadded_len - 1)) + 1;
  const chunk = nextPower <= 256 ? 32 : nextPower / 8;
  return chunk * (Math.floor((unpadded_len - 1) / chunk) + 1);
}
function pad(plaintext) {
  const unpadded = utf8ToBytes(plaintext);
  const unpadded_len = unpadded.length;
  if (unpadded_len < MIN_PLAINTEXT_SIZE || unpadded_len > MAX_PLAINTEXT_SIZE) {
    throw new Error(`NIP-44: Invalid plaintext length: ${unpadded_len}. Must be between ${MIN_PLAINTEXT_SIZE} and ${MAX_PLAINTEXT_SIZE}.`);
  }
  const prefix = new Uint8Array(2);
  prefix[0] = unpadded_len >> 8 & 255;
  prefix[1] = unpadded_len & 255;
  const padded_len = calcPaddedLen(unpadded_len);
  const suffix = new Uint8Array(padded_len - unpadded_len);
  return concatBytes(prefix, unpadded, suffix);
}
function unpad(padded) {
  if (padded.length < 2) {
    throw new Error("NIP-44: Padded data too short to contain length prefix");
  }
  const unpadded_len = padded[0] << 8 | padded[1];
  if (unpadded_len < MIN_PLAINTEXT_SIZE || unpadded_len > MAX_PLAINTEXT_SIZE) {
    throw new Error(`NIP-44: Invalid unpadded length in padded data: ${unpadded_len}`);
  }
  if (padded.length < 2 + unpadded_len) {
    throw new Error(`NIP-44: Padded data too short (${padded.length}) to contain claimed unpadded length (${unpadded_len})`);
  }
  const expected_padded_len = 2 + calcPaddedLen(unpadded_len);
  if (padded.length !== expected_padded_len) {
    throw new Error(`NIP-44: Padded length mismatch: ${padded.length} vs expected ${expected_padded_len}`);
  }
  const unpadded = padded.slice(2, 2 + unpadded_len);
  if (unpadded.length !== unpadded_len) {
    throw new Error(`NIP-44: Extracted data length (${unpadded.length}) doesn't match claimed length (${unpadded_len})`);
  }
  try {
    return new TextDecoder().decode(unpadded);
  } catch (error) {
    throw new Error(`NIP-44: Failed to decode unpadded data: ${error instanceof Error ? error.message : "unknown error"}`);
  }
}
var FIELD_PRIME = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
function isValidPublicKeyFormat(publicKey) {
  if (!/^[0-9a-f]{64}$/i.test(publicKey)) {
    return false;
  }
  if (publicKey === "0000000000000000000000000000000000000000000000000000000000000000") {
    return false;
  }
  if (publicKey === "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff") {
    return false;
  }
  try {
    const keyValue = BigInt("0x" + publicKey);
    if (keyValue >= FIELD_PRIME) {
      return false;
    }
  } catch {
    return false;
  }
  return true;
}
function isValidPublicKeyPoint(publicKey) {
  if (!isValidPublicKeyFormat(publicKey)) {
    return false;
  }
  const prefixes = ["02", "03"];
  for (const prefix of prefixes) {
    try {
      secp256k1.ProjectivePoint.fromHex(prefix + publicKey);
      return true;
    } catch {
    }
  }
  return false;
}
function isValidPrivateKey(privateKey2) {
  if (!/^[0-9a-f]{64}$/i.test(privateKey2)) {
    return false;
  }
  try {
    secp256k1.getPublicKey(privateKey2);
    return true;
  } catch {
    return false;
  }
}
function getSharedSecret(privateKey2, publicKey) {
  if (!isValidPrivateKey(privateKey2)) {
    throw new Error("NIP-44: Invalid private key format or value.");
  }
  if (!isValidPublicKeyPoint(publicKey)) {
    throw new Error("NIP-44: Invalid public key format. Expected 64-character hex string.");
  }
  try {
    let sharedPoint;
    try {
      sharedPoint = secp256k1.getSharedSecret(privateKey2, "02" + publicKey);
    } catch {
      try {
        sharedPoint = secp256k1.getSharedSecret(privateKey2, "03" + publicKey);
      } catch {
        throw new Error("NIP-44: Invalid public key: not a point on the secp256k1 curve");
      }
    }
    const shared_x = sharedPoint.subarray(1, 33);
    const salt = utf8ToBytes("nip44-v2");
    return extract(sha256, shared_x, salt);
  } catch (error) {
    if (error instanceof Error) {
      if (error.message.startsWith("NIP-44:")) {
        throw error;
      }
      throw new Error(`NIP-44: Failed to derive shared secret: ${error.message}`);
    }
    throw new Error("NIP-44: Failed to derive shared secret");
  }
}
function getMessageKeys(conversation_key, nonce) {
  if (conversation_key.length !== KEY_SIZE) {
    throw new Error(`NIP-44: Invalid conversation key length: ${conversation_key.length}`);
  }
  if (nonce.length < NONCE_SIZE_V0) {
    throw new Error(`NIP-44: Nonce too short for key derivation. Min expected: ${NONCE_SIZE_V0}, got: ${nonce.length}`);
  }
  const keys = expand(sha256, conversation_key, nonce, 76);
  return {
    chacha_key: keys.subarray(0, 32),
    // 32 bytes for ChaCha20 encryption key
    chacha_nonce: keys.subarray(32, 44),
    // 12 bytes for ChaCha20 nonce
    hmac_key: keys.subarray(44, 76)
    // 32 bytes for HMAC-SHA256 key
  };
}
function generateNonce() {
  return randomBytes(NONCE_SIZE_V2);
}
function hmacWithAAD(key, message, aad) {
  if (aad.length < NONCE_SIZE_V0) {
    throw new Error(`NIP-44: AAD (nonce) too short. Min expected: ${NONCE_SIZE_V0} bytes, got: ${aad.length}`);
  }
  return hmac(sha256, key, concatBytes(aad, message));
}
function secureWipe(buffer) {
  if (buffer.length === 0)
    return;
  try {
    const randomData = randomBytes(buffer.length);
    buffer.set(randomData);
    buffer.fill(0);
    randomData.fill(0);
  } catch (error) {
    buffer.fill(0);
  }
}
function constantTimeEqual(a, b) {
  if (a.length !== b.length) {
    return 0;
  }
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a[i] ^ b[i];
  }
  result = (result | result >>> 1 | result >>> 2 | result >>> 3 | result >>> 4 | result >>> 5 | result >>> 6 | result >>> 7) & 1;
  return 1 - result;
}
function encryptV2(plaintext, privateKey2, publicKey, nonce) {
  const nonceBytes = nonce || generateNonce();
  if (nonceBytes.length !== NONCE_SIZE_V2) {
    throw new Error(`NIP-44 (v2): Nonce must be ${NONCE_SIZE_V2} bytes, got ${nonceBytes.length}`);
  }
  const conversation_key = getSharedSecret(privateKey2, publicKey);
  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversation_key, nonceBytes);
  const padded = pad(plaintext);
  const ciphertext = chacha20(chacha_key, chacha_nonce, padded);
  const mac = hmacWithAAD(hmac_key, ciphertext, nonceBytes);
  const payload = concatBytes(
    new Uint8Array([2]),
    // Hardcode version 2 for V2 encryption
    nonceBytes,
    ciphertext,
    mac
  );
  return base64Encode(payload);
}
function encrypt(plaintext, privateKey2, publicKey, nonce, options) {
  if (!isValidPublicKeyPoint(publicKey)) {
    throw new Error("NIP-44: Invalid public key format. Expected 64-character hex string.");
  }
  if (!isValidPrivateKey(privateKey2)) {
    throw new Error("NIP-44: Invalid private key format or value.");
  }
  const versionToEncryptWith = options?.version ?? CURRENT_VERSION;
  if (versionToEncryptWith === 0) {
    throw new Error("NIP-44: Encryption with version 0 is not permitted by the NIP-44 specification. Only decryption is supported for v0.");
  }
  if (versionToEncryptWith === 1) {
    throw new Error("NIP-44: Encryption with version 1 is not permitted by the NIP-44 specification. Only decryption is supported for v1.");
  }
  if (versionToEncryptWith !== CURRENT_VERSION) {
    throw new Error(`NIP-44: Unsupported encryption version: ${versionToEncryptWith}. Only version ${CURRENT_VERSION} is supported for encryption.`);
  }
  if (versionToEncryptWith > MAX_SUPPORTED_VERSION) {
    throw new Error(`NIP-44: Encryption version ${versionToEncryptWith} is outside the maximum supported range [${MIN_SUPPORTED_VERSION}-${MAX_SUPPORTED_VERSION}].`);
  }
  try {
    if (versionToEncryptWith === 2) {
      return encryptV2(plaintext, privateKey2, publicKey, nonce);
    } else {
      throw new Error(`NIP-44: Unexpected encryption version after validation: ${versionToEncryptWith}. Expected ${CURRENT_VERSION}.`);
    }
  } catch (error) {
    if (error instanceof Error) {
      if (error.message.startsWith("NIP-44:")) {
        throw error;
      }
      throw new Error(`NIP-44: Encryption failed (version ${versionToEncryptWith}): ${error.message}`);
    }
    throw new Error(`NIP-44: Encryption failed (version ${versionToEncryptWith})`);
  }
}
function decodePayload(payload) {
  const raw = payload.trim();
  if (raw.length > 0 && raw[0] === "#") {
    throw new Error("NIP-44: Unsupported version (non-base64 encoding detected)");
  }
  if (raw.length < MIN_BASE64_PAYLOAD_LENGTH) {
    throw new Error(`NIP-44: Invalid ciphertext length. Base64 payload must be between ${MIN_BASE64_PAYLOAD_LENGTH} and ${MAX_BASE64_PAYLOAD_LENGTH} characters, got ${raw.length}.`);
  }
  if (raw.length > MAX_BASE64_PAYLOAD_LENGTH) {
    throw new Error(`NIP-44: Invalid ciphertext length. Base64 payload must be between ${MIN_BASE64_PAYLOAD_LENGTH} and ${MAX_BASE64_PAYLOAD_LENGTH} characters, got ${raw.length}.`);
  }
  let data;
  try {
    data = base64Decode(raw);
  } catch (error) {
    if (error instanceof Error && error.message.includes("NIP-44:")) {
      throw error;
    }
    throw new Error("NIP-44: Invalid base64 encoding in ciphertext");
  }
  if (data.length < MIN_DECODED_PAYLOAD_LENGTH) {
    throw new Error(`NIP-44: Invalid decoded payload length. Must be between ${MIN_DECODED_PAYLOAD_LENGTH} and ${MAX_DECODED_PAYLOAD_LENGTH} bytes, got ${data.length}.`);
  }
  if (data.length > MAX_DECODED_PAYLOAD_LENGTH) {
    throw new Error(`NIP-44: Invalid decoded payload length. Must be between ${MIN_DECODED_PAYLOAD_LENGTH} and ${MAX_DECODED_PAYLOAD_LENGTH} bytes, got ${data.length}.`);
  }
  if (data.length < 1) {
    throw new Error(`NIP-44: Invalid payload, too short to contain version byte.`);
  }
  const version = data[0];
  if (version < MIN_SUPPORTED_VERSION || version > MAX_SUPPORTED_VERSION) {
    throw new Error(`NIP-44: Unsupported version: ${version}. This implementation supports versions ${MIN_SUPPORTED_VERSION}-${MAX_SUPPORTED_VERSION}.`);
  }
  const nonceSize = version === 0 ? NONCE_SIZE_V0 : version === 1 ? NONCE_SIZE_V1 : NONCE_SIZE_V2;
  const macSize = version === 0 ? MAC_SIZE_V0 : version === 1 ? MAC_SIZE_V1 : MAC_SIZE_V2;
  const minVersionedPayloadSize = VERSION_BYTE_SIZE + nonceSize + 1 + macSize;
  if (data.length < minVersionedPayloadSize) {
    throw new Error(`NIP-44: Payload too short (${data.length} bytes) for version ${version}. Minimum is ${minVersionedPayloadSize} bytes.`);
  }
  const nonce = data.subarray(VERSION_BYTE_SIZE, VERSION_BYTE_SIZE + nonceSize);
  const mac = data.subarray(data.length - macSize);
  const ciphertext = data.subarray(VERSION_BYTE_SIZE + nonceSize, data.length - macSize);
  if (ciphertext.length === 0) {
    throw new Error(`NIP-44: Ciphertext cannot be empty for version ${version}.`);
  }
  return { version, nonce, ciphertext, mac };
}
function decryptV2(encryptedData, nonce, mac, privateKey2, publicKey) {
  const conversation_key = getSharedSecret(privateKey2, publicKey);
  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversation_key, nonce);
  const calculated_mac = hmacWithAAD(hmac_key, encryptedData, nonce);
  const mac_valid = constantTimeEqual(calculated_mac, mac) === 1;
  if (!mac_valid) {
    throw new Error("NIP-44 (v2): Authentication failed. Message may be tampered with or keys are incorrect.");
  }
  const padded = chacha20(chacha_key, chacha_nonce, encryptedData);
  return unpad(padded);
}
function decryptV1(encryptedData, nonce, mac, privateKey2, publicKey) {
  try {
    return decryptV2(encryptedData, nonce, mac, privateKey2, publicKey);
  } catch (error) {
    if (error instanceof Error && error.message.includes("NIP-44 (v2)")) {
      throw new Error(error.message.replace("NIP-44 (v2)", "NIP-44 (v1)"));
    }
    throw error;
  }
}
function decryptV0(encryptedData, nonce, mac, privateKey2, publicKey) {
  try {
    return decryptV2(encryptedData, nonce, mac, privateKey2, publicKey);
  } catch (error) {
    if (error instanceof Error && error.message.includes("NIP-44 (v2)")) {
      throw new Error(error.message.replace("NIP-44 (v2)", "NIP-44 (v0)"));
    }
    throw error;
  }
}
function decrypt(ciphertext, privateKey2, publicKey) {
  if (!isValidPublicKeyPoint(publicKey)) {
    throw new Error("NIP-44: Invalid public key format. Expected 64-character hex string.");
  }
  if (!isValidPrivateKey(privateKey2)) {
    throw new Error("NIP-44: Invalid private key format or value.");
  }
  try {
    const { version, nonce, ciphertext: encryptedData, mac } = decodePayload(ciphertext);
    if (version === 0) {
      return decryptV0(encryptedData, nonce, mac, privateKey2, publicKey);
    } else if (version === 1) {
      return decryptV1(encryptedData, nonce, mac, privateKey2, publicKey);
    } else if (version === 2) {
      return decryptV2(encryptedData, nonce, mac, privateKey2, publicKey);
    } else {
      throw new Error(`NIP-44: Unexpected version ${version} after decoding.`);
    }
  } catch (error) {
    if (error instanceof Error) {
      if (error.message.startsWith("NIP-44:")) {
        throw error;
      }
      throw new Error(`NIP-44: Failed to decrypt message: ${error.message}`);
    }
    throw new Error("NIP-44: Failed to decrypt message");
  }
}

// node_modules/snstr/dist/esm/src/utils/time.js
function getUnixTime() {
  return Math.floor(Date.now() / 1e3);
}

// node_modules/snstr/dist/esm/src/utils/security-validator.js
var SECURITY_LIMITS = {
  // Content size limits (prevent DoS via large payloads)
  MAX_CONTENT_SIZE: 1e5,
  // 100KB
  MAX_TAG_SIZE: 1e3,
  MAX_TAG_COUNT: 100,
  MAX_TAG_ELEMENT_SIZE: 512,
  // Filter limits (prevent DoS via complex filters)
  MAX_FILTER_COUNT: 20,
  MAX_FILTER_IDS: 1e3,
  MAX_FILTER_AUTHORS: 1e3,
  MAX_FILTER_KINDS: 100,
  MAX_FILTER_TAG_VALUES: 1e3,
  MAX_SEARCH_LENGTH: 500,
  // Array access safety
  MAX_ARRAY_SIZE: 1e4,
  MAX_OBJECT_DEPTH: 10,
  // String limits
  MAX_STRING_LENGTH: 1e5,
  MAX_URL_LENGTH: 2048,
  MAX_PUBKEY_LENGTH: 64,
  MAX_SIGNATURE_LENGTH: 128,
  MAX_ID_LENGTH: 64,
  // Numeric limits
  MIN_KIND: 0,
  MAX_KIND: 65535,
  MIN_CREATED_AT: 946684800,
  // Jan 1, 2000
  MAX_CREATED_AT: 4102444800,
  // Jan 1, 2100
  MIN_LIMIT: 0,
  MAX_LIMIT: 5e3,
  MIN_SINCE: 946684800,
  // Jan 1, 2000
  MAX_SINCE: 4102444800,
  // Jan 1, 2100
  MIN_UNTIL: 946684800,
  // Jan 1, 2000
  MAX_UNTIL: 4102444800,
  // Jan 1, 2100
  // Memory limits for relay buffers (prevent memory exhaustion)
  MAX_RELAY_EVENT_BUFFERS: 1e3,
  // Maximum number of event buffers per relay
  MAX_EVENTS_PER_BUFFER: 100,
  // Maximum events per buffer
  MAX_REPLACEABLE_EVENT_PUBKEYS: 1e4,
  // Maximum pubkeys to track replaceable events
  MAX_REPLACEABLE_EVENTS_PER_PUBKEY: 50,
  // Maximum replaceable events per pubkey
  MAX_ADDRESSABLE_EVENTS: 5e4
  // Maximum addressable events to store
};
var SecurityValidationError = class extends Error {
  constructor(message, code, field) {
    super(message);
    this.code = code;
    this.field = field;
    this.name = "SecurityValidationError";
  }
};
function getSecureCrypto() {
  if (typeof crypto !== "undefined" && crypto.getRandomValues) {
    return {
      randomBytes: (length) => {
        const array = new Uint8Array(length);
        crypto.getRandomValues(array);
        return array;
      },
      randomUint32: () => {
        const array = new Uint32Array(1);
        crypto.getRandomValues(array);
        return array[0];
      }
    };
  } else if (typeof process !== "undefined" && process.versions && process.versions.node) {
    const nodeCrypto = eval('require("crypto")');
    return {
      randomBytes: (length) => nodeCrypto.randomBytes(length),
      randomUint32: () => nodeCrypto.randomInt(0, 4294967296)
    };
  } else {
    throw new SecurityValidationError("No secure random source available", "NO_SECURE_RANDOM");
  }
}
function secureRandomBytes(length) {
  const crypto3 = getSecureCrypto();
  return crypto3.randomBytes(length);
}
function secureRandomHex(length) {
  if (typeof length !== "number" || length < 1 || !Number.isInteger(length)) {
    throw new SecurityValidationError("Length must be a positive integer", "INVALID_LENGTH");
  }
  const bytes2 = secureRandomBytes(Math.ceil(length / 2));
  return Array.from(bytes2, (byte) => byte.toString(16).padStart(2, "0")).join("").slice(0, length);
}
function getSecureRandom() {
  const crypto3 = getSecureCrypto();
  return crypto3.randomUint32() / (4294967295 + 1);
}
function sanitizeString(input, maxLength = SECURITY_LIMITS.MAX_STRING_LENGTH) {
  if (typeof input !== "string") {
    throw new SecurityValidationError("Input must be a string", "INVALID_TYPE", "string");
  }
  if (input.length > maxLength) {
    throw new SecurityValidationError(`String exceeds maximum length of ${maxLength}`, "STRING_TOO_LONG", "length");
  }
  return input;
}
function validateArrayAccess(array, index, context = "array") {
  if (!Array.isArray(array)) {
    throw new SecurityValidationError(`${context} must be an array`, "NOT_ARRAY", context);
  }
  if (array.length > SECURITY_LIMITS.MAX_ARRAY_SIZE) {
    throw new SecurityValidationError(`${context} exceeds maximum size of ${SECURITY_LIMITS.MAX_ARRAY_SIZE}`, "ARRAY_TOO_LARGE", context);
  }
  if (index < 0 || index >= array.length) {
    throw new SecurityValidationError(`Array index ${index} out of bounds for ${context} with length ${array.length}`, "INDEX_OUT_OF_BOUNDS", context);
  }
  return array[index];
}
function safeArrayAccess(array, index, defaultValue) {
  if (!Array.isArray(array) || index < 0 || index >= array.length) {
    return defaultValue;
  }
  return array[index];
}
function validateNumber(value, min, max, field) {
  if (typeof value !== "number" || isNaN(value) || !Number.isFinite(value)) {
    throw new SecurityValidationError(`${field} must be a valid finite number`, "INVALID_NUMBER", field);
  }
  if (value < min || value > max) {
    throw new SecurityValidationError(`${field} must be between ${min} and ${max}`, "NUMBER_OUT_OF_RANGE", field);
  }
  return value;
}
function validateEventContent(content2) {
  const contentStr = sanitizeString(content2, SECURITY_LIMITS.MAX_CONTENT_SIZE);
  return contentStr;
}
function validateTags(tags2) {
  if (!Array.isArray(tags2)) {
    throw new SecurityValidationError("Tags must be an array", "INVALID_TAGS_TYPE", "tags");
  }
  if (tags2.length > SECURITY_LIMITS.MAX_TAG_COUNT) {
    throw new SecurityValidationError(`Too many tags: ${tags2.length} (max ${SECURITY_LIMITS.MAX_TAG_COUNT})`, "TOO_MANY_TAGS", "tags");
  }
  return tags2.map((tag, tagIndex) => {
    if (!Array.isArray(tag)) {
      throw new SecurityValidationError(`Tag at index ${tagIndex} must be an array`, "INVALID_TAG_TYPE", `tags[${tagIndex}]`);
    }
    if (tag.length > SECURITY_LIMITS.MAX_TAG_SIZE) {
      throw new SecurityValidationError(`Tag at index ${tagIndex} has too many elements: ${tag.length} (max ${SECURITY_LIMITS.MAX_TAG_SIZE})`, "TAG_TOO_LARGE", `tags[${tagIndex}]`);
    }
    return tag.map((element, _elementIndex) => {
      const elementStr = sanitizeString(element, SECURITY_LIMITS.MAX_TAG_ELEMENT_SIZE);
      return elementStr;
    });
  });
}
function validateFilter(filter) {
  if (!filter || typeof filter !== "object") {
    throw new SecurityValidationError("Filter must be an object", "INVALID_FILTER_TYPE", "filter");
  }
  const f = filter;
  const validatedFilter = {};
  if (f.ids !== void 0) {
    if (!Array.isArray(f.ids)) {
      throw new SecurityValidationError("Filter ids must be an array", "INVALID_FILTER_IDS_TYPE", "filter.ids");
    }
    if (f.ids.length > SECURITY_LIMITS.MAX_FILTER_IDS) {
      throw new SecurityValidationError(`Too many filter ids: ${f.ids.length} (max ${SECURITY_LIMITS.MAX_FILTER_IDS})`, "TOO_MANY_FILTER_IDS", "filter.ids");
    }
    validatedFilter.ids = f.ids.map((id, index) => {
      const idStr = sanitizeString(id, SECURITY_LIMITS.MAX_ID_LENGTH);
      if (!/^[0-9a-f]+$/i.test(idStr)) {
        throw new SecurityValidationError(`Invalid ID format at index ${index}: ${idStr}`, "INVALID_ID_FORMAT", `filter.ids[${index}]`);
      }
      return idStr;
    });
  }
  if (f.authors !== void 0) {
    if (!Array.isArray(f.authors)) {
      throw new SecurityValidationError("Filter authors must be an array", "INVALID_FILTER_AUTHORS_TYPE", "filter.authors");
    }
    if (f.authors.length > SECURITY_LIMITS.MAX_FILTER_AUTHORS) {
      throw new SecurityValidationError(`Too many filter authors: ${f.authors.length} (max ${SECURITY_LIMITS.MAX_FILTER_AUTHORS})`, "TOO_MANY_FILTER_AUTHORS", "filter.authors");
    }
    validatedFilter.authors = f.authors.map((author, index) => {
      const authorStr = sanitizeString(author, SECURITY_LIMITS.MAX_PUBKEY_LENGTH);
      if (!/^[0-9a-f]+$/i.test(authorStr)) {
        throw new SecurityValidationError(`Invalid author format at index ${index}: ${authorStr}`, "INVALID_AUTHOR_FORMAT", `filter.authors[${index}]`);
      }
      return authorStr;
    });
  }
  if (f.kinds !== void 0) {
    if (!Array.isArray(f.kinds)) {
      throw new SecurityValidationError("Filter kinds must be an array", "INVALID_FILTER_KINDS_TYPE", "filter.kinds");
    }
    if (f.kinds.length > SECURITY_LIMITS.MAX_FILTER_KINDS) {
      throw new SecurityValidationError(`Too many filter kinds: ${f.kinds.length} (max ${SECURITY_LIMITS.MAX_FILTER_KINDS})`, "TOO_MANY_FILTER_KINDS", "filter.kinds");
    }
    validatedFilter.kinds = f.kinds.map((kind, index) => {
      return validateNumber(kind, SECURITY_LIMITS.MIN_KIND, SECURITY_LIMITS.MAX_KIND, `filter.kinds[${index}]`);
    });
  }
  if (f.limit !== void 0) {
    validatedFilter.limit = validateNumber(f.limit, SECURITY_LIMITS.MIN_LIMIT, SECURITY_LIMITS.MAX_LIMIT, "filter.limit");
  }
  if (f.since !== void 0) {
    validatedFilter.since = validateNumber(f.since, SECURITY_LIMITS.MIN_SINCE, SECURITY_LIMITS.MAX_SINCE, "filter.since");
  }
  if (f.until !== void 0) {
    validatedFilter.until = validateNumber(f.until, SECURITY_LIMITS.MIN_UNTIL, SECURITY_LIMITS.MAX_UNTIL, "filter.until");
  }
  if (validatedFilter.since !== void 0 && validatedFilter.until !== void 0) {
    if (validatedFilter.since >= validatedFilter.until) {
      throw new SecurityValidationError(`Filter 'since' (${validatedFilter.since}) must be strictly less than 'until' (${validatedFilter.until})`, "INVALID_TIME_RANGE", "filter.since_until");
    }
  }
  if (f.search !== void 0) {
    validatedFilter.search = sanitizeString(f.search, SECURITY_LIMITS.MAX_SEARCH_LENGTH);
  }
  for (const [key, value] of Object.entries(f)) {
    if (key.startsWith("#") && key.length === 2) {
      if (!Array.isArray(value)) {
        throw new SecurityValidationError(`Filter tag ${key} must be an array`, "INVALID_FILTER_TAG_TYPE", `filter.${key}`);
      }
      if (value.length > SECURITY_LIMITS.MAX_FILTER_TAG_VALUES) {
        throw new SecurityValidationError(`Too many filter tag values for ${key}: ${value.length} (max ${SECURITY_LIMITS.MAX_FILTER_TAG_VALUES})`, "TOO_MANY_FILTER_TAG_VALUES", `filter.${key}`);
      }
      validatedFilter[key] = value.map((tagValue, _index) => {
        return sanitizeString(tagValue, SECURITY_LIMITS.MAX_TAG_ELEMENT_SIZE);
      });
    }
  }
  return validatedFilter;
}
function validateFilters(filters) {
  if (!Array.isArray(filters)) {
    throw new SecurityValidationError("Filters must be an array", "INVALID_FILTERS_TYPE", "filters");
  }
  if (filters.length > SECURITY_LIMITS.MAX_FILTER_COUNT) {
    throw new SecurityValidationError(`Too many filters: ${filters.length} (max ${SECURITY_LIMITS.MAX_FILTER_COUNT})`, "TOO_MANY_FILTERS", "filters");
  }
  return filters.map((filter, index) => {
    try {
      return validateFilter(filter);
    } catch (error) {
      if (error instanceof SecurityValidationError) {
        throw new SecurityValidationError(`Filter at index ${index}: ${error.message}`, error.code, `filters[${index}].${error.field || "unknown"}`);
      }
      throw error;
    }
  });
}
function validateEvent(event2) {
  if (!event2 || typeof event2 !== "object") {
    throw new SecurityValidationError("Event must be an object", "INVALID_EVENT_TYPE", "event");
  }
  const e = event2;
  const id = sanitizeString(e.id, SECURITY_LIMITS.MAX_ID_LENGTH);
  const pubkey2 = sanitizeString(e.pubkey, SECURITY_LIMITS.MAX_PUBKEY_LENGTH);
  const sig = sanitizeString(e.sig, SECURITY_LIMITS.MAX_SIGNATURE_LENGTH);
  const content2 = validateEventContent(e.content);
  const tags2 = validateTags(e.tags);
  const kind = validateNumber(e.kind, SECURITY_LIMITS.MIN_KIND, SECURITY_LIMITS.MAX_KIND, "event.kind");
  const created_at = validateNumber(e.created_at, SECURITY_LIMITS.MIN_CREATED_AT, SECURITY_LIMITS.MAX_CREATED_AT, "event.created_at");
  if (!/^[0-9a-f]{64}$/i.test(id)) {
    throw new SecurityValidationError("Event ID must be 64-character hex", "INVALID_EVENT_ID_FORMAT", "event.id");
  }
  if (!/^[0-9a-f]{64}$/i.test(pubkey2)) {
    throw new SecurityValidationError("Event pubkey must be 64-character hex", "INVALID_EVENT_PUBKEY_FORMAT", "event.pubkey");
  }
  if (!/^[0-9a-f]{128}$/i.test(sig)) {
    throw new SecurityValidationError("Event signature must be 128-character hex", "INVALID_EVENT_SIGNATURE_FORMAT", "event.sig");
  }
  return {
    id,
    pubkey: pubkey2,
    sig,
    content: content2,
    tags: tags2,
    kind,
    created_at
  };
}
function checkRateLimit(state, limit, windowMs, now = Date.now()) {
  if (now - state.windowStart >= windowMs) {
    state.count = 0;
    state.windowStart = now;
    state.blocked = false;
  }
  if (state.blocked) {
    const retryAfter = Math.ceil((windowMs - (now - state.windowStart)) / 1e3);
    return { allowed: false, retryAfter };
  }
  if (state.count >= limit) {
    state.blocked = true;
    const retryAfter = Math.ceil((windowMs - (now - state.windowStart)) / 1e3);
    return { allowed: false, retryAfter };
  }
  state.count++;
  return { allowed: true };
}
function secureStringZero(str) {
  if (typeof str !== "string") {
    return;
  }
  try {
    if (typeof global !== "undefined" && global.gc) {
      global.gc();
    }
  } catch {
  }
}
function secureBufferZero(buffer) {
  if (!buffer || !(buffer instanceof Uint8Array)) {
    return;
  }
  try {
    const secureCrypto = getSecureCrypto();
    const randomData = secureCrypto.randomBytes(buffer.length);
    buffer.set(randomData);
    buffer.fill(0);
    try {
      if (typeof global !== "undefined" && global.gc) {
        global.gc();
      }
    } catch {
    }
  } catch (error) {
    buffer.fill(0);
  }
}
function secureKeyCleanup(privateKey2) {
  if (!privateKey2 || typeof privateKey2 !== "string") {
    return;
  }
  try {
    const keyBuffer = new TextEncoder().encode(privateKey2);
    secureBufferZero(keyBuffer);
  } catch {
    secureStringZero(privateKey2);
  }
}
function validatePrivateKey(privateKey2, field = "privateKey") {
  if (typeof privateKey2 !== "string") {
    throw new SecurityValidationError("Private key must be a string", "INVALID_PRIVATE_KEY_TYPE", field);
  }
  const keyStr = privateKey2.trim();
  if (keyStr.length !== 64) {
    throw new SecurityValidationError("Private key must be exactly 64 characters (32 bytes hex)", "INVALID_PRIVATE_KEY_LENGTH", field);
  }
  if (!/^[0-9a-f]{64}$/i.test(keyStr)) {
    throw new SecurityValidationError("Private key must be valid hex (64 characters)", "INVALID_PRIVATE_KEY_FORMAT", field);
  }
  return keyStr;
}
function enforceMemoryLimits(map, maxSize, accessTracker, context = "memory") {
  if (map.size <= maxSize) {
    return;
  }
  const initialSize = map.size;
  let removedCount = 0;
  if (accessTracker && accessTracker.size > 0) {
    const entries = Array.from(accessTracker.entries());
    entries.sort((a, b) => a[1] - b[1]);
    for (const [key] of entries) {
      if (map.size <= maxSize) {
        break;
      }
      if (map.delete(key)) {
        accessTracker.delete(key);
        removedCount++;
      }
    }
  }
  if (map.size > maxSize) {
    const keys = Array.from(map.keys());
    for (const key of keys) {
      if (map.size <= maxSize) {
        break;
      }
      if (map.delete(key)) {
        if (accessTracker) {
          accessTracker.delete(key);
        }
        removedCount++;
      }
    }
  }
  if (typeof console !== "undefined" && console.warn && removedCount > 0) {
    console.warn(`Security: Enforced memory limit for ${context}, removed ${removedCount} entries (${initialSize} -> ${map.size})`);
  }
}

// node_modules/snstr/dist/esm/src/nip01/event.js
function isValidLowercasePublicKeyFormat(publicKey) {
  return /^[0-9a-f]{64}$/.test(publicKey);
}
var NostrValidationError = class extends Error {
  constructor(message, field, invalidData) {
    super(message);
    this.name = "NostrValidationError";
    this.field = field;
    this.invalidData = invalidData;
  }
};
async function getEventHash(event2) {
  if (!event2.pubkey)
    throw new NostrValidationError("Invalid event: missing pubkey", "pubkey", event2);
  if (event2.created_at === void 0 || event2.created_at === null)
    throw new NostrValidationError("Invalid event: missing created_at", "created_at", event2);
  if (event2.kind === void 0)
    throw new NostrValidationError("Invalid event: missing kind", "kind", event2);
  if (!Array.isArray(event2.tags))
    throw new NostrValidationError("Invalid event: tags must be an array", "tags", event2);
  for (const tag of event2.tags) {
    if (!Array.isArray(tag))
      throw new NostrValidationError("Invalid event: each tag must be an array", "tags", event2);
    for (const item of tag) {
      if (typeof item !== "string")
        throw new NostrValidationError("Invalid event: tag items must be strings", "tags", event2);
    }
  }
  if (typeof event2.content !== "string")
    throw new NostrValidationError("Invalid event: content must be a string", "content", event2);
  const eventData = [
    0,
    event2.pubkey,
    event2.created_at,
    event2.kind,
    event2.tags,
    event2.content
  ];
  const serialized = JSON.stringify(eventData);
  return sha256Hex(serialized);
}
function createEvent(template, pubkey2) {
  if (!isValidLowercasePublicKeyFormat(pubkey2)) {
    throw new NostrValidationError("Invalid pubkey format: must be a 64-character lowercase hex string", "pubkey");
  }
  if (!isValidPublicKeyPoint(pubkey2)) {
    throw new NostrValidationError("Invalid pubkey: not a valid point on the secp256k1 curve", "pubkey");
  }
  if (template.kind === void 0) {
    throw new NostrValidationError("Event template must include a kind", "kind", template);
  }
  return {
    pubkey: pubkey2,
    created_at: template.created_at || getUnixTime(),
    kind: template.kind,
    tags: template.tags || [],
    content: template.content
  };
}
async function createSignedEvent(event2, privateKey2) {
  if (!isValidPrivateKey(privateKey2)) {
    throw new NostrValidationError("Invalid private key", "privateKey");
  }
  try {
    const id = await getEventHash(event2);
    const sig = await signEvent(id, privateKey2);
    return {
      ...event2,
      id,
      sig
    };
  } catch (error) {
    if (error instanceof NostrValidationError) {
      throw error;
    }
    throw new NostrValidationError(`Failed to create signed event: ${error instanceof Error ? error.message : String(error)}`, void 0, event2);
  }
}
function createTextNote(content2, privateKey2, tags2 = []) {
  if (!content2 || typeof content2 !== "string") {
    throw new NostrValidationError("Content must be a non-empty string", "content");
  }
  try {
    const validatedContent2 = validateEventContent(content2);
    const validatedTags2 = validateTags(tags2);
    const contentByteLength2 = new TextEncoder().encode(validatedContent2).length;
    if (contentByteLength2 > SECURITY_LIMITS.MAX_CONTENT_SIZE) {
      throw new SecurityValidationError(`Content too large: ${contentByteLength2} bytes (max ${SECURITY_LIMITS.MAX_CONTENT_SIZE})`, "CONTENT_TOO_LARGE", "content");
    }
    if (!isValidPrivateKey(privateKey2)) {
      throw new NostrValidationError("Invalid private key", "privateKey");
    }
    const pubkey2 = getPublicKey(privateKey2);
    return {
      pubkey: pubkey2,
      created_at: getUnixTime(),
      kind: NostrKind.ShortNote,
      tags: validatedTags2,
      content: validatedContent2
    };
  } catch (error) {
    if (error instanceof SecurityValidationError) {
      throw new NostrValidationError(error.message, error.field);
    }
    throw error;
  }
}
async function createDirectMessage(content, recipientPubkey, privateKey, tags = []) {
  if (!content || typeof content !== "string") {
    throw new NostrValidationError("Content must be a non-empty string", "content");
  }
  if (!isValidPublicKeyPoint(recipientPubkey)) {
    throw new NostrValidationError("Invalid recipient public key: must be a valid secp256k1 curve point", "recipientPubkey");
  }
  if (!isValidPrivateKey(privateKey)) {
    throw new NostrValidationError("Invalid private key", "privateKey");
  }
  try {
    const validatedContent = validateEventContent(content);
    const validatedTags = validateTags(tags);
    const contentByteLength = new TextEncoder().encode(validatedContent).length;
    if (contentByteLength > SECURITY_LIMITS.MAX_CONTENT_SIZE) {
      throw new SecurityValidationError(`Content too large: ${contentByteLength} bytes (max ${SECURITY_LIMITS.MAX_CONTENT_SIZE})`, "CONTENT_TOO_LARGE", "content");
    }
    const pubkey = getPublicKey(privateKey);
    const encryptNIP04 = (() => {
      try {
        if (typeof process !== "undefined" && process.versions && process.versions.node) {
          return eval('require("../nip04")').encrypt;
        }
      } catch {
      }
      try {
        return eval('require("../nip04/web")').encrypt;
      } catch {
      }
      throw new Error("NIP-04 module not available in this environment");
    })();
    const encryptedContent = await encryptNIP04(privateKey, recipientPubkey, validatedContent);
    return {
      pubkey,
      created_at: getUnixTime(),
      kind: NostrKind.DirectMessage,
      tags: [["p", recipientPubkey], ...validatedTags],
      content: encryptedContent
    };
  } catch (error) {
    if (error instanceof SecurityValidationError) {
      throw new NostrValidationError(error.message, error.field);
    }
    if (error instanceof NostrValidationError) {
      throw error;
    }
    throw new NostrValidationError(`Failed to encrypt message: ${error instanceof Error ? error.message : String(error)}`, "encryption");
  }
}
function createMetadataEvent(metadata, privateKey2) {
  if (!metadata || typeof metadata !== "object") {
    throw new NostrValidationError("Metadata must be a valid object", "metadata");
  }
  if (!isValidPrivateKey(privateKey2)) {
    throw new NostrValidationError("Invalid private key", "privateKey");
  }
  const pubkey2 = getPublicKey(privateKey2);
  return {
    pubkey: pubkey2,
    created_at: getUnixTime(),
    kind: NostrKind.Metadata,
    tags: [],
    content: JSON.stringify(metadata)
  };
}
function createAddressableEvent(kind, dTagValue, content2, privateKey2, additionalTags = []) {
  if (kind < 3e4 || kind >= 4e4 || !Number.isInteger(kind)) {
    throw new NostrValidationError("Addressable events must have kind between 30000-39999", "kind", { kind });
  }
  if (typeof dTagValue !== "string") {
    throw new NostrValidationError("D-tag value must be a string", "dTagValue");
  }
  if (dTagValue.length > SECURITY_LIMITS.MAX_TAG_ELEMENT_SIZE) {
    throw new NostrValidationError(`D-tag value too long: ${dTagValue.length} chars (max ${SECURITY_LIMITS.MAX_TAG_ELEMENT_SIZE})`, "dTagValue");
  }
  if (!content2 || typeof content2 !== "string") {
    throw new NostrValidationError("Content must be a non-empty string", "content");
  }
  try {
    const validatedContent2 = validateEventContent(content2);
    const validatedTags2 = validateTags(additionalTags);
    const contentByteLength2 = new TextEncoder().encode(validatedContent2).length;
    if (contentByteLength2 > SECURITY_LIMITS.MAX_CONTENT_SIZE) {
      throw new SecurityValidationError(`Content too large: ${contentByteLength2} bytes (max ${SECURITY_LIMITS.MAX_CONTENT_SIZE})`, "CONTENT_TOO_LARGE", "content");
    }
    if (!isValidPrivateKey(privateKey2)) {
      throw new NostrValidationError("Invalid private key", "privateKey");
    }
    const pubkey2 = getPublicKey(privateKey2);
    const dTag = ["d", dTagValue];
    const tags2 = [dTag, ...validatedTags2];
    return {
      pubkey: pubkey2,
      created_at: getUnixTime(),
      kind,
      tags: tags2,
      content: validatedContent2
    };
  } catch (error) {
    if (error instanceof SecurityValidationError) {
      throw new NostrValidationError(error.message, error.field);
    }
    throw error;
  }
}
async function validateEvent2(event2, options = {}) {
  const {
    validateSignatures = true,
    maxTimestampDrift = 60 * 60,
    // 1 hour by default
    validateIds = true,
    validateFields = true,
    validateTags: validateTags2 = true,
    validateContent = true,
    customValidator
  } = options;
  if (validateFields) {
    if (!event2.id || typeof event2.id !== "string" || event2.id.length !== 64) {
      throw new NostrValidationError("Invalid or missing event ID: must be a 64-character hex string", "id", event2);
    }
    if (event2.id !== event2.id.toLowerCase()) {
      throw new NostrValidationError("Invalid event ID: must be lowercase hex", "id", event2);
    }
    if (!event2.pubkey || typeof event2.pubkey !== "string") {
      throw new NostrValidationError("Invalid or missing pubkey: must be a string", "pubkey", event2);
    }
    if (!isValidLowercasePublicKeyFormat(event2.pubkey)) {
      if (/^[0-9A-F]{64}$/.test(event2.pubkey)) {
        throw new NostrValidationError("Invalid pubkey: must be lowercase hex", "pubkey", event2);
      }
      if (event2.pubkey.length !== 64) {
        throw new NostrValidationError("Invalid pubkey: must be 64 characters long", "pubkey", event2);
      }
      throw new NostrValidationError("Invalid pubkey: must be a 64-character lowercase hex string", "pubkey", event2);
    }
    if (!isValidPublicKeyPoint(event2.pubkey)) {
      throw new NostrValidationError("Invalid pubkey: must be a valid secp256k1 curve point", "pubkey", event2);
    }
    if (!event2.sig || typeof event2.sig !== "string" || event2.sig.length !== 128) {
      throw new NostrValidationError("Invalid or missing signature: must be a 128-character hex string", "sig", event2);
    }
    if (event2.sig !== event2.sig.toLowerCase()) {
      throw new NostrValidationError("Invalid signature: must be lowercase hex", "sig", event2);
    }
    if (typeof event2.kind !== "number") {
      throw new NostrValidationError("Kind must be a number", "kind", event2);
    }
    if (typeof event2.created_at !== "number" || event2.created_at < 0) {
      throw new NostrValidationError("Invalid created_at timestamp", "created_at", event2);
    }
    if (typeof event2.content !== "string") {
      throw new NostrValidationError("Content must be a string", "content", event2);
    }
  }
  if (validateTags2) {
    if (!Array.isArray(event2.tags)) {
      throw new NostrValidationError("Tags must be an array", "tags", event2);
    }
    for (const tag of event2.tags) {
      if (!Array.isArray(tag)) {
        throw new NostrValidationError("Each tag must be an array", "tags", event2);
      }
      if (tag.length === 0) {
        throw new NostrValidationError("Tags cannot be empty arrays", "tags", event2);
      }
      for (const item of tag) {
        if (typeof item !== "string") {
          throw new NostrValidationError("Tag items must be strings", "tags", event2);
        }
      }
    }
  }
  if (maxTimestampDrift > 0) {
    const now = getUnixTime();
    const drift = Math.abs(now - event2.created_at);
    if (drift > maxTimestampDrift) {
      throw new NostrValidationError(`Event timestamp is too far from current time (drift: ${drift}s, max allowed: ${maxTimestampDrift}s)`, "created_at", event2);
    }
  }
  if (validateIds) {
    const unsignedEvent = {
      pubkey: event2.pubkey,
      created_at: event2.created_at,
      kind: event2.kind,
      tags: event2.tags,
      content: event2.content
    };
    const calculatedId = await getEventHash(unsignedEvent);
    if (calculatedId !== event2.id) {
      throw new NostrValidationError("Event ID does not match content hash", "id", event2);
    }
  }
  if (validateSignatures) {
    const isValid = await verifySignature(event2.id, event2.sig, event2.pubkey);
    if (!isValid) {
      throw new NostrValidationError("Invalid signature", "sig", event2);
    }
  }
  if (validateContent) {
    switch (event2.kind) {
      case NostrKind.Metadata:
        try {
          const metadata = JSON.parse(event2.content);
          if (typeof metadata !== "object" || metadata === null) {
            throw new NostrValidationError("Metadata event content must be a valid JSON object", "content", event2);
          }
        } catch (error) {
          throw new NostrValidationError("Metadata event has invalid JSON content", "content", event2);
        }
        break;
      case NostrKind.Contacts: {
        for (const tag of event2.tags) {
          if (tag[0] === "p") {
            if (tag.length < 2 || typeof tag[1] !== "string" || !isValidPublicKeyPoint(tag[1])) {
              throw new NostrValidationError(`Invalid NIP-02 'p' tag: Pubkey at tag[1] is missing, not a string, or not a valid secp256k1 curve point. Received: '${tag[1]}'.`, "tags", event2);
            }
            if (tag.length > 2) {
              const relayUrl = tag[2];
              if (typeof relayUrl !== "string") {
                throw new NostrValidationError("Invalid NIP-02 'p' tag: Relay URL at tag[2] must be a string if present.", "tags", event2);
              }
              if (relayUrl.length > 0 && !isValidRelayUrl(relayUrl)) {
                throw new NostrValidationError(`Invalid NIP-02 'p' tag: Relay URL "${relayUrl}" at tag[2] is not a valid ws:// or wss:// URL, or an empty string.`, "tags", event2);
              }
            }
            if (tag.length > 3) {
              const petname = tag[3];
              if (typeof petname !== "string") {
                throw new NostrValidationError("Invalid NIP-02 'p' tag: Petname at tag[3] must be a string if present.", "tags", event2);
              }
              if (typeof tag[2] !== "string") {
                throw new NostrValidationError("Invalid NIP-02 'p' tag: Relay URL at tag[2] must be present (and a string, can be empty) if petname at tag[3] is specified.", "tags", event2);
              }
            }
            if (tag.length > 4) {
              throw new NostrValidationError("Invalid NIP-02 'p' tag: Exceeds maximum of 4 elements (p, pubkey, relay, petname).", "tags", event2);
            }
          }
        }
        break;
      }
      case NostrKind.DirectMessage: {
        const pTags = event2.tags.filter((tag) => {
          try {
            return validateArrayAccess(tag, 0) && safeArrayAccess(tag, 0) === "p";
          } catch {
            return false;
          }
        });
        if (pTags.length !== 1) {
          throw new NostrValidationError("Direct message event must have exactly one p tag", "tags", event2);
        }
        try {
          if (!validateArrayAccess(pTags, 0)) {
            throw new NostrValidationError("Direct message p-tag validation error: No valid p tags found", "tags", event2);
          }
          const pTag2 = safeArrayAccess(pTags, 0);
          if (!Array.isArray(pTag2) || !validateArrayAccess(pTag2, 1)) {
            throw new NostrValidationError("Direct message p-tag validation error: Invalid p tag structure", "tags", event2);
          }
          const pubkeyValue = safeArrayAccess(pTag2, 1);
          if (typeof pubkeyValue !== "string" || !isValidPublicKeyPoint(pubkeyValue)) {
            throw new NostrValidationError(`Invalid 'p' tag in Direct Message: Pubkey at tag[1] (pTag[1]) must be a valid secp256k1 curve point. Received: '${pubkeyValue}'.`, "tags", event2);
          }
        } catch (error) {
          if (error instanceof SecurityValidationError) {
            throw new NostrValidationError(`Direct message validation bounds checking error: ${error.message}`, "tags", event2);
          }
          throw error;
        }
        break;
      }
    }
  }
  if (customValidator) {
    const customValid = await Promise.resolve(customValidator(event2));
    if (!customValid) {
      throw new NostrValidationError("Event failed custom validation", void 0, event2);
    }
  }
  return true;
}
function getTagValues(event2, tagName) {
  return event2.tags.filter((tag) => tag[0] === tagName).flatMap((tag) => tag.slice(1));
}
function getTagValue(event2, tagName, index = 0) {
  if (index < 0) {
    throw new SecurityValidationError(`Tag index must be non-negative: ${index}`, "INVALID_TAG_INDEX", "index");
  }
  const tag = event2.tags.find((tag2) => tag2[0] === tagName);
  if (!tag || !Array.isArray(tag)) {
    return void 0;
  }
  const targetIndex = index + 1;
  if (targetIndex >= tag.length) {
    return void 0;
  }
  return tag[targetIndex];
}
function extractTags(event2) {
  const result = {};
  for (const tag of event2.tags) {
    if (tag.length < 1)
      continue;
    const tagName = tag[0];
    const tagValues = tag.slice(1);
    if (!result[tagName]) {
      result[tagName] = [];
    }
    result[tagName].push(...tagValues);
  }
  return result;
}
function createTaggedEvent(event2) {
  return {
    ...event2,
    tagValues: (name) => event2.tags.filter((tag) => tag[0] === name).flatMap((tag) => tag.slice(1)),
    getTag: (name, index = 0) => {
      const tag = event2.tags.find((tag2) => tag2[0] === name);
      return tag && tag.length > index + 1 ? tag[index + 1] : void 0;
    }
  };
}

// node_modules/snstr/dist/esm/src/nip46/utils/logger.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["NONE"] = 0] = "NONE";
  LogLevel2[LogLevel2["ERROR"] = 1] = "ERROR";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["INFO"] = 3] = "INFO";
  LogLevel2[LogLevel2["DEBUG"] = 4] = "DEBUG";
  LogLevel2[LogLevel2["TRACE"] = 5] = "TRACE";
})(LogLevel || (LogLevel = {}));
var Logger = class {
  constructor(options = {}) {
    this.level = options.level ?? LogLevel.INFO;
    this.prefix = options.prefix ?? "";
    this.includeTimestamp = options.includeTimestamp ?? false;
    this.silent = options.silent ?? false;
  }
  formatMessage(message) {
    let formattedMessage = "";
    if (this.includeTimestamp) {
      formattedMessage += `[${(/* @__PURE__ */ new Date()).toISOString()}] `;
    }
    if (this.prefix) {
      formattedMessage += `[${this.prefix}] `;
    }
    return formattedMessage + message;
  }
  error(message, ...args) {
    if (!this.silent && this.level >= LogLevel.ERROR) {
      console.error(this.formatMessage(message), ...args);
    }
  }
  warn(message, ...args) {
    if (!this.silent && this.level >= LogLevel.WARN) {
      console.warn(this.formatMessage(message), ...args);
    }
  }
  info(message, ...args) {
    if (!this.silent && this.level >= LogLevel.INFO) {
      console.log(this.formatMessage(message), ...args);
    }
  }
  debug(message, ...args) {
    if (!this.silent && this.level >= LogLevel.DEBUG) {
      console.log(this.formatMessage(message), ...args);
    }
  }
  trace(message, ...args) {
    if (!this.silent && this.level >= LogLevel.TRACE) {
      console.log(this.formatMessage(message), ...args);
    }
  }
  setLevel(level) {
    this.level = level;
  }
};

// node_modules/snstr/dist/esm/src/nip01/relay.js
var WS_READY_STATE = {
  CONNECTING: 0,
  OPEN: 1,
  CLOSING: 2,
  CLOSED: 3
};
var Relay = class {
  constructor(url, options = {}) {
    this.ws = null;
    this.connected = false;
    this.subscriptions = /* @__PURE__ */ new Map();
    this.eventHandlers = {};
    this.connectionPromise = null;
    this.connectionTimeout = 1e4;
    this.eventBuffers = /* @__PURE__ */ new Map();
    this.eventBufferAccessTimes = /* @__PURE__ */ new Map();
    this.maxEventBuffers = SECURITY_LIMITS.MAX_RELAY_EVENT_BUFFERS;
    this.maxEventsPerBuffer = SECURITY_LIMITS.MAX_EVENTS_PER_BUFFER;
    this.bufferFlushInterval = null;
    this.bufferFlushDelay = 50;
    this.reconnectAttempts = 0;
    this.reconnectTimer = null;
    this.autoReconnect = true;
    this.maxReconnectAttempts = 10;
    this.maxReconnectDelay = 3e4;
    this.replaceableEvents = /* @__PURE__ */ new Map();
    this.replaceableEventAccessTimes = /* @__PURE__ */ new Map();
    this.maxReplaceableEventPubkeys = SECURITY_LIMITS.MAX_REPLACEABLE_EVENT_PUBKEYS;
    this.maxReplaceableEventsPerPubkey = SECURITY_LIMITS.MAX_REPLACEABLE_EVENTS_PER_PUBKEY;
    this.addressableEvents = /* @__PURE__ */ new Map();
    this.addressableEventAccessTimes = /* @__PURE__ */ new Map();
    this.maxAddressableEvents = SECURITY_LIMITS.MAX_ADDRESSABLE_EVENTS;
    this.pendingValidationCounts = /* @__PURE__ */ new Map();
    this.pendingEoseSubscriptions = /* @__PURE__ */ new Set();
    this.url = url;
    this.logger = new Logger({
      prefix: `Relay(${url})`,
      level: LogLevel.WARN,
      // Default to WARN level for production use
      includeTimestamp: false
    });
    if (options.connectionTimeout !== void 0) {
      this.connectionTimeout = options.connectionTimeout;
    }
    if (options.bufferFlushDelay !== void 0) {
      this.bufferFlushDelay = options.bufferFlushDelay;
    }
    if (options.autoReconnect !== void 0) {
      this.autoReconnect = options.autoReconnect;
    }
    if (options.maxReconnectAttempts !== void 0) {
      this.maxReconnectAttempts = options.maxReconnectAttempts;
    }
    if (options.maxReconnectDelay !== void 0) {
      this.maxReconnectDelay = options.maxReconnectDelay;
    }
  }
  async connect() {
    if (this.connected)
      return true;
    if (this.connectionPromise)
      return this.connectionPromise;
    if (this.ws) {
      try {
        this.ws.close();
      } catch (e) {
      }
      this.ws = null;
    }
    const connectionPromise = new Promise((resolve, reject) => {
      try {
        const inMemorySocket = createInMemoryWebSocket(this.url);
        if (inMemorySocket) {
          this.ws = inMemorySocket;
        } else {
          const WS = getWebSocketImplementation();
          this.ws = new WS(this.url);
        }
        const socket = this.ws;
        if (!socket) {
          throw new Error("WebSocket implementation unavailable");
        }
        const timeoutId = setTimeout(() => {
          if (this.ws && !this.connected) {
            this.triggerEvent(RelayEvent.Error, this.url, new Error("connection timeout"));
            try {
              this.ws.close();
            } catch (e) {
            }
            this.ws = null;
            this.connectionPromise = null;
            reject(new Error("connection timeout"));
          }
        }, this.connectionTimeout);
        socket.onopen = () => {
          clearTimeout(timeoutId);
          this.connected = true;
          this.resetReconnectAttempts();
          this.setupBufferFlush();
          this.triggerEvent(RelayEvent.Connect, this.url);
          resolve(true);
        };
        socket.onclose = () => {
          clearTimeout(timeoutId);
          const wasConnected = this.connected;
          this.connected = false;
          this.clearBufferFlush();
          this.triggerEvent(RelayEvent.Disconnect, this.url);
          if (!wasConnected && this.connectionPromise) {
            this.connectionPromise = null;
            reject(new Error("connection closed"));
          }
          if (this.autoReconnect && wasConnected) {
            this.scheduleReconnect();
          }
        };
        socket.onerror = (error) => {
          clearTimeout(timeoutId);
          this.triggerEvent(RelayEvent.Error, this.url, error);
          if (!this.connected && this.connectionPromise) {
            this.connectionPromise = null;
            reject(error instanceof Error ? error : new Error("websocket error"));
          }
        };
        socket.onmessage = (message) => {
          try {
            const data = JSON.parse(message.data);
            this.handleMessage(data);
          } catch (error) {
            this.triggerEvent(RelayEvent.Error, this.url, error);
          }
        };
      } catch (error) {
        this.connectionPromise = null;
        reject(error);
      }
    }).catch((_error) => {
      this.logger.error(`Connection failed:`, _error);
      if (this.autoReconnect) {
        this.scheduleReconnect();
      }
      return false;
    });
    this.connectionPromise = connectionPromise;
    connectionPromise.then(() => {
      if (this.connectionPromise === connectionPromise) {
        this.connectionPromise = null;
      }
    }, () => {
      if (this.connectionPromise === connectionPromise) {
        this.connectionPromise = null;
      }
    });
    return this.connectionPromise;
  }
  disconnect() {
    this.cancelReconnect();
    if (!this.ws)
      return;
    try {
      this.subscriptions.clear();
      this.eventBuffers.clear();
      this.eventBufferAccessTimes.clear();
      this.replaceableEvents.clear();
      this.replaceableEventAccessTimes.clear();
      this.addressableEvents.clear();
      this.addressableEventAccessTimes.clear();
      this.clearBufferFlush();
      if (this.ws && (this.ws.readyState === WS_READY_STATE.OPEN || this.ws.readyState === WS_READY_STATE.CONNECTING)) {
        try {
          this.ws.close();
        } catch (e) {
        }
        this.connectionPromise = null;
      }
    } catch (error) {
      console.error(`Error closing WebSocket for ${this.url}:`, error);
    } finally {
      this.ws = null;
      this.connected = false;
      this.triggerEvent(RelayEvent.Disconnect, this.url);
    }
  }
  /**
   * Schedule a reconnection attempt with exponential backoff
   */
  scheduleReconnect() {
    this.cancelReconnect();
    if (this.maxReconnectAttempts > 0 && this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.warn(`Maximum reconnection attempts (${this.maxReconnectAttempts}) reached for ${this.url}`);
      return;
    }
    const baseDelay = Math.min(1e3 * Math.pow(2, this.reconnectAttempts), this.maxReconnectDelay);
    let secureJitter;
    try {
      secureJitter = getSecureRandom();
    } catch (error) {
      secureJitter = Math.random();
    }
    const jitter = secureJitter * 0.3 * baseDelay;
    const reconnectDelay = baseDelay + jitter;
    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempts++;
      this.connect().catch((error) => {
        console.error(`Reconnection attempt ${this.reconnectAttempts} failed for ${this.url}:`, error);
      });
    }, reconnectDelay);
  }
  /**
   * Cancel any scheduled reconnection attempt
   */
  cancelReconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }
  /**
   * Reset the reconnection attempt counter
   */
  resetReconnectAttempts() {
    this.reconnectAttempts = 0;
    this.cancelReconnect();
  }
  /**
   * Enable or disable automatic reconnection
   */
  setAutoReconnect(enable) {
    this.autoReconnect = enable;
    if (!enable) {
      this.cancelReconnect();
    }
  }
  /**
   * Set the maximum number of reconnection attempts
   * @param max Maximum number of attempts (0 for unlimited)
   */
  setMaxReconnectAttempts(max) {
    if (max < 0) {
      throw new Error("Maximum reconnect attempts must be a non-negative number");
    }
    this.maxReconnectAttempts = max;
  }
  /**
   * Set the maximum delay between reconnection attempts
   * @param maxDelayMs Maximum delay in milliseconds
   */
  setMaxReconnectDelay(maxDelayMs) {
    if (maxDelayMs < 1e3) {
      throw new Error("Maximum reconnect delay must be at least 1000ms");
    }
    this.maxReconnectDelay = maxDelayMs;
  }
  on(event2, callback) {
    if (typeof callback !== "function")
      return;
    const existingCallbacks = this.eventHandlers[event2];
    if (!existingCallbacks) {
      this.eventHandlers[event2] = [callback];
    } else {
      if (!existingCallbacks.includes(callback)) {
        existingCallbacks.push(callback);
      }
    }
  }
  off(event2, callback) {
    if (typeof callback !== "function")
      return;
    const handlerOrArray = this.eventHandlers[event2];
    if (!handlerOrArray) {
      return;
    }
    if (typeof handlerOrArray === "function") {
      if (handlerOrArray === callback) {
        delete this.eventHandlers[event2];
      }
    } else if (Array.isArray(handlerOrArray)) {
      const callbacksArray = handlerOrArray;
      const index = callbacksArray.indexOf(callback);
      if (index > -1) {
        callbacksArray.splice(index, 1);
      }
      if (callbacksArray.length === 0) {
        delete this.eventHandlers[event2];
      }
    }
  }
  async publish(event2, options = {}) {
    if (!this.connected) {
      try {
        const connected = await this.connect();
        if (!connected) {
          return {
            success: false,
            reason: "connection_failed",
            relay: this.url
          };
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : "unknown error";
        return {
          success: false,
          reason: `connection_error: ${errorMsg}`,
          relay: this.url
        };
      }
    }
    if (!this.connected || !this.ws || this.ws.readyState !== WS_READY_STATE.OPEN) {
      return { success: false, reason: "not_connected", relay: this.url };
    }
    try {
      const message = JSON.stringify(["EVENT", event2]);
      this.ws.send(message);
      if (options.waitForAck === false) {
        return { success: true, relay: this.url };
      }
      return new Promise((resolve) => {
        const timeout = options.timeout ?? 1e4;
        let timeoutId = setTimeout(() => {
          cleanup();
          resolve({ success: false, reason: "timeout", relay: this.url });
        }, timeout);
        const handleOk = (eventId, success, details) => {
          if (eventId === event2.id) {
            cleanup();
            resolve({
              success,
              reason: details.rawMessage,
              parsedReason: details,
              relay: this.url
            });
          }
        };
        const handleError = (_, error) => {
          cleanup();
          const errorMsg = error instanceof Error ? error.message : "unknown error";
          resolve({
            success: false,
            reason: `error: ${errorMsg}`,
            relay: this.url
          });
        };
        const handleDisconnect = () => {
          cleanup();
          resolve({ success: false, reason: "disconnected", relay: this.url });
        };
        const cleanup = () => {
          this.off(RelayEvent.OK, handleOk);
          this.off(RelayEvent.Error, handleError);
          this.off(RelayEvent.Disconnect, handleDisconnect);
          clearTimeout(timeoutId);
        };
        this.on(RelayEvent.OK, handleOk);
        this.on(RelayEvent.Error, handleError);
        this.on(RelayEvent.Disconnect, handleDisconnect);
        timeoutId = setTimeout(() => {
          cleanup();
          resolve({ success: false, reason: "timeout", relay: this.url });
        }, timeout);
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "unknown error";
      console.error(`Error publishing event to ${this.url}:`, errorMessage);
      return {
        success: false,
        reason: `error: ${errorMessage}`,
        relay: this.url
      };
    }
  }
  subscribe(filters, onEvent, onEOSE, options = {}) {
    const id = secureRandomHex(16);
    const fieldsToValidate = ["ids", "authors", "#e", "#p"];
    for (const filter of filters) {
      for (const field of fieldsToValidate) {
        const values = filter[field];
        if (Array.isArray(values)) {
          for (const item of values) {
            if (!this._isValidNip01FilterIdentifier(item)) {
              const fieldName = field;
              throw new NostrValidationError(`Invalid NIP-01 filter value for '${fieldName}': item '${item}' is not a 64-character lowercase hex string.`, fieldName, filter);
            }
          }
        }
      }
    }
    const subscription = {
      id,
      filters,
      onEvent,
      onEOSE,
      options
    };
    if (options.autoClose && options.eoseTimeout && options.eoseTimeout > 0) {
      subscription.eoseTimer = setTimeout(() => {
        this.unsubscribe(id);
      }, options.eoseTimeout);
    }
    this.subscriptions.set(id, subscription);
    this.eventBuffers.set(id, []);
    if (this.connected && this.ws) {
      const message = JSON.stringify(["REQ", id, ...filters]);
      this.ws.send(message);
    }
    return id;
  }
  unsubscribe(id) {
    const subscription = this.subscriptions.get(id);
    if (!subscription)
      return;
    if (subscription.eoseTimer) {
      clearTimeout(subscription.eoseTimer);
    }
    this.subscriptions.delete(id);
    this.eventBuffers.delete(id);
    this.eventBufferAccessTimes.delete(id);
    this.pendingEoseSubscriptions.delete(id);
    this.pendingValidationCounts.delete(id);
    if (this.connected && this.ws) {
      const message = JSON.stringify(["CLOSE", id]);
      this.ws.send(message);
    }
  }
  handleMessage(data) {
    if (!Array.isArray(data))
      return;
    const [type, ...rest] = data;
    switch (type) {
      case "EVENT": {
        const [subscriptionId, event2] = rest;
        if (typeof subscriptionId !== "string") {
          this.triggerEvent(RelayEvent.Error, this.url, new Error("Invalid subscription identifier in EVENT message"));
          break;
        }
        this.incrementPendingValidation(subscriptionId);
        if (!this.isNostrEvent(event2)) {
          this.decrementPendingValidation(subscriptionId);
          this.triggerEvent(RelayEvent.Error, this.url, new Error(`Invalid event structure: ${JSON.stringify(event2)}`));
          break;
        }
        if (!this.performBasicValidation(event2)) {
          this.triggerEvent(RelayEvent.Error, this.url, new Error(`Invalid event: ${event2.id}`));
          this.decrementPendingValidation(subscriptionId);
          break;
        }
        this.validateEventAsync(event2).then((isValid) => {
          if (isValid) {
            this.processValidatedEvent(event2, subscriptionId);
          } else {
            this.triggerEvent(RelayEvent.Error, this.url, new Error(`Async validation failed for event: ${event2.id}`));
          }
        }).catch((error) => {
          this.triggerEvent(RelayEvent.Error, this.url, new Error(`Validation error: ${error instanceof Error ? error.message : "unknown error"}`));
        }).finally(() => {
          this.decrementPendingValidation(subscriptionId);
        });
        break;
      }
      case "EOSE": {
        const [subscriptionId] = rest;
        if (typeof subscriptionId === "string") {
          this.markEosePending(subscriptionId);
        }
        break;
      }
      case "NOTICE": {
        const [notice] = rest;
        const noticeStr = typeof notice === "string" ? notice : String(notice || "");
        this.triggerEvent(RelayEvent.Notice, this.url, noticeStr);
        break;
      }
      case "OK": {
        const [eventId, success, rawMessageUntyped] = rest;
        const eventIdStr = typeof eventId === "string" ? eventId : String(eventId || "");
        const successBool = Boolean(success);
        const rawMessageStr = typeof rawMessageUntyped === "string" ? rawMessageUntyped : void 0;
        const parsedDetails = this.parseOkMessage(rawMessageStr);
        this.triggerEvent(RelayEvent.OK, eventIdStr, successBool, parsedDetails);
        break;
      }
      case "CLOSED": {
        const [subscriptionId, message] = rest;
        const subIdStr = typeof subscriptionId === "string" ? subscriptionId : String(subscriptionId || "");
        const messageStr = typeof message === "string" ? message : String(message || "");
        this.triggerEvent(RelayEvent.Closed, subIdStr, messageStr);
        if (typeof subscriptionId === "string") {
          this.subscriptions.delete(subscriptionId);
        }
        break;
      }
      case "AUTH": {
        const [challengeEvent] = rest;
        if (this.isNostrEvent(challengeEvent)) {
          this.triggerEvent(RelayEvent.Auth, challengeEvent);
        } else {
          this.triggerEvent(RelayEvent.Error, this.url, new Error(`Invalid AUTH challenge: ${JSON.stringify(challengeEvent)}`));
        }
        break;
      }
      default:
        console.warn(`Relay(${this.url}): Unknown message type:`, type, rest);
        break;
    }
  }
  /**
   * Process a validated event - called only after both basic and async validation
   */
  processValidatedEvent(event2, subscriptionId) {
    if (event2.kind === 0 || event2.kind === 3 || event2.kind >= 1e4 && event2.kind < 2e4) {
      this.processReplaceableEvent(event2);
    } else if (event2.kind >= 3e4 && event2.kind < 4e4) {
      this.processAddressableEvent(event2);
    }
    const subscription = this.subscriptions.get(subscriptionId);
    if (subscription) {
      this.addToEventBuffer(subscriptionId, event2);
      this.maybeFinalizeEOSE(subscriptionId);
    }
  }
  // Helper function to check if a string is a valid hex string of a specific length
  isHexString(value, length) {
    if (typeof value !== "string") {
      return false;
    }
    if (!/^[0-9a-fA-F]+$/.test(value)) {
      return false;
    }
    if (length !== void 0 && value.length !== length) {
      return false;
    }
    return true;
  }
  /**
   * Perform basic synchronous validation of an event
   *
   * This checks:
   * 1. Required fields are present with correct types
   * 2. Fields have valid formats (lengths, structure)
   * 3. Timestamps are reasonable
   */
  performBasicValidation(event2) {
    if (!this.isNostrEvent(event2)) {
      return false;
    }
    try {
      if (!this.isHexString(event2.id, 64)) {
        return false;
      }
      if (!this.isHexString(event2.pubkey, 64)) {
        return false;
      }
      if (event2.kind < 0 || event2.kind > 65535) {
        return false;
      }
      for (const tag of event2.tags) {
        if (!Array.isArray(tag) || tag.length === 0) {
          return false;
        }
        for (const item of tag) {
          if (typeof item !== "string") {
            return false;
          }
        }
        const tagName = tag[0];
        if (tagName === "e" || tagName === "p") {
          if (tag.length < 2 || !this.isHexString(tag[1], 64)) {
            return false;
          }
        } else if (tagName === "a") {
          if (tag.length < 2 || typeof tag[1] !== "string") {
            return false;
          }
          const valueParts = tag[1].split(":");
          if (valueParts.length !== 3) {
            return false;
          }
          const kindStr = valueParts[0];
          const pubkeyStr = valueParts[1];
          const kindNum = parseInt(kindStr, 10);
          if (isNaN(kindNum) || !Number.isInteger(kindNum) || kindNum < 0 || // Kinds must be non-negative
          String(kindNum) !== kindStr) {
            return false;
          }
          if (!this.isHexString(pubkeyStr, 64)) {
            return false;
          }
        }
      }
      if (!this.isHexString(event2.sig, 128)) {
        return false;
      }
      const now = getUnixTime();
      if (event2.created_at > now + 3600) {
        return false;
      }
      if (event2.kind === 24133) {
        const hasValidPTagForNIP46 = event2.tags.some((tag) => tag.length >= 2 && tag[0] === "p");
        if (!hasValidPTagForNIP46) {
          return false;
        }
      }
      if (event2.created_at < now - 31536e3) {
      }
      return true;
    } catch (error) {
      return false;
    }
  }
  /**
   * Validate an event (deprecated - use async validation directly)
   * Maintained for backward compatibility with existing code
   */
  validateEvent(event2) {
    if (!this.isNostrEvent(event2)) {
      return false;
    }
    if (!this.performBasicValidation(event2)) {
      return false;
    }
    if (event2.kind === 24133) {
      return true;
    }
    return true;
  }
  /**
   * Perform async validations on an event
   *
   * This includes:
   * 1. Verifying the event ID matches the hash of serialized data
   * 2. Verifying the signature is valid
   *
   * These operations are computationally expensive, so they're performed
   * asynchronously to avoid blocking the main thread.
   */
  async validateEventAsync(event2) {
    try {
      const eventData = {
        pubkey: event2.pubkey,
        created_at: event2.created_at,
        kind: event2.kind,
        tags: event2.tags,
        content: event2.content
      };
      const calculatedId = await getEventHash(eventData);
      if (calculatedId !== event2.id) {
        return false;
      }
      return await verifySignature(event2.id, event2.sig, event2.pubkey);
    } catch (error) {
      const debug = process.env.DEBUG?.includes("nostr:*") || false;
      if (debug) {
        console.error(`Relay(${this.url}): Event validation error:`, error);
      }
      return false;
    }
  }
  triggerEvent(event2, ...args) {
    const callbacks = this.eventHandlers[event2];
    if (callbacks && Array.isArray(callbacks)) {
      callbacks.forEach((callback) => {
        if (typeof callback === "function") {
          try {
            callback(...args);
          } catch (e) {
            console.error(`Relay(${this.url}): Error in ${event2} callback:`, e);
          }
        }
      });
    }
  }
  /**
   * Set connection timeout in milliseconds
   * @param timeout Timeout in milliseconds
   */
  setConnectionTimeout(timeout) {
    if (timeout < 0) {
      throw new Error("Connection timeout must be a positive number");
    }
    this.connectionTimeout = timeout;
  }
  /**
   * Get the current connection timeout in milliseconds
   */
  getConnectionTimeout() {
    return this.connectionTimeout;
  }
  /**
   * Get all subscription IDs for this relay
   * @returns A Set containing all active subscription IDs
   */
  getSubscriptionIds() {
    return new Set(this.subscriptions.keys());
  }
  /**
   * Get the current buffer flush delay in milliseconds
   */
  getBufferFlushDelay() {
    return this.bufferFlushDelay;
  }
  /**
   * Set up the interval to flush event buffers
   */
  setupBufferFlush() {
    this.clearBufferFlush();
    this.bufferFlushInterval = setInterval(() => {
      this.flushAllBuffers();
    }, this.bufferFlushDelay);
  }
  /**
   * Clear the buffer flush interval
   */
  clearBufferFlush() {
    if (this.bufferFlushInterval) {
      clearInterval(this.bufferFlushInterval);
      this.bufferFlushInterval = null;
    }
  }
  /**
   * Flush all event buffers for all subscriptions
   */
  flushAllBuffers() {
    for (const subscriptionId of this.eventBuffers.keys()) {
      this.flushSubscriptionBuffer(subscriptionId);
    }
  }
  incrementPendingValidation(subscriptionId) {
    const current = this.pendingValidationCounts.get(subscriptionId) ?? 0;
    this.pendingValidationCounts.set(subscriptionId, current + 1);
  }
  decrementPendingValidation(subscriptionId) {
    const current = this.pendingValidationCounts.get(subscriptionId) ?? 0;
    const next = Math.max(current - 1, 0);
    if (next === 0) {
      this.pendingValidationCounts.delete(subscriptionId);
      if (!this.pendingEoseSubscriptions.has(subscriptionId)) {
        this.flushSubscriptionBuffer(subscriptionId);
      }
    } else {
      this.pendingValidationCounts.set(subscriptionId, next);
    }
    this.maybeFinalizeEOSE(subscriptionId);
  }
  markEosePending(subscriptionId) {
    this.pendingEoseSubscriptions.add(subscriptionId);
    this.maybeFinalizeEOSE(subscriptionId);
  }
  maybeFinalizeEOSE(subscriptionId) {
    if (!this.pendingEoseSubscriptions.has(subscriptionId)) {
      return;
    }
    const pending = this.pendingValidationCounts.get(subscriptionId) ?? 0;
    if (pending > 0) {
      return;
    }
    this.flushSubscriptionBuffer(subscriptionId);
    const subscription = this.subscriptions.get(subscriptionId);
    if (subscription) {
      if (subscription.onEOSE) {
        subscription.onEOSE();
      }
      if (subscription.options?.autoClose) {
        this.unsubscribe(subscriptionId);
      }
    }
    this.pendingEoseSubscriptions.delete(subscriptionId);
  }
  /**
   * Flush the event buffer for a specific subscription
   */
  flushSubscriptionBuffer(subscriptionId) {
    const buffer = this.eventBuffers.get(subscriptionId);
    if (!buffer || buffer.length === 0)
      return;
    const subscription = this.subscriptions.get(subscriptionId);
    if (!subscription) {
      this.eventBuffers.delete(subscriptionId);
      return;
    }
    const sortedEvents = this.sortEvents(buffer);
    this.eventBuffers.delete(subscriptionId);
    this.eventBufferAccessTimes.delete(subscriptionId);
    for (const event2 of sortedEvents) {
      try {
        subscription.onEvent(event2);
      } catch (error) {
        console.error(`Error in subscription handler for ${subscriptionId}:`, error);
      }
    }
  }
  /**
   * Sort events according to NIP-01 specification:
   * 1. created_at timestamp (descending - newer events first)
   * 2. event id (lexical ascending) if timestamps are the same
   */
  sortEvents(events) {
    return [...events].sort((a, b) => {
      if (a.created_at !== b.created_at) {
        return b.created_at - a.created_at;
      }
      return a.id.localeCompare(b.id);
    });
  }
  // Add event to buffer with memory limits
  addToEventBuffer(subscriptionId, event2) {
    this.eventBufferAccessTimes.set(subscriptionId, Date.now());
    if (!this.eventBuffers.has(subscriptionId) && this.eventBuffers.size >= this.maxEventBuffers) {
      this.evictOldestEventBuffer();
    }
    if (!this.eventBuffers.has(subscriptionId)) {
      this.eventBuffers.set(subscriptionId, []);
    }
    const buffer = this.eventBuffers.get(subscriptionId);
    if (buffer.length >= this.maxEventsPerBuffer) {
      buffer.shift();
    }
    buffer.push(event2);
  }
  // Evict oldest accessed event buffer
  evictOldestEventBuffer() {
    let oldestTime = Infinity;
    let oldestId = "";
    for (const [id, time] of this.eventBufferAccessTimes) {
      if (time < oldestTime) {
        oldestTime = time;
        oldestId = id;
      }
    }
    if (oldestId) {
      this.eventBuffers.delete(oldestId);
      this.eventBufferAccessTimes.delete(oldestId);
      this.logger.debug(`Evicted event buffer for subscription: ${oldestId}`);
    }
  }
  // Process replaceable event with memory limits
  processReplaceableEvent(event2) {
    const pubkey2 = event2.pubkey;
    this.replaceableEventAccessTimes.set(pubkey2, Date.now());
    if (!this.replaceableEvents.has(pubkey2) && this.replaceableEvents.size >= this.maxReplaceableEventPubkeys) {
      this.evictOldestReplaceablePubkey();
    }
    if (!this.replaceableEvents.has(pubkey2)) {
      this.replaceableEvents.set(pubkey2, /* @__PURE__ */ new Map());
    }
    const kindMap = this.replaceableEvents.get(pubkey2);
    const existingEvent = kindMap.get(event2.kind);
    if (!existingEvent || event2.created_at > existingEvent.created_at) {
      if (kindMap.size >= this.maxReplaceableEventsPerPubkey && !kindMap.has(event2.kind)) {
        let oldestKind = -1;
        let oldestTime = Infinity;
        for (const [kind, evt] of kindMap) {
          if (evt.created_at < oldestTime) {
            oldestTime = evt.created_at;
            oldestKind = kind;
          }
        }
        if (oldestKind !== -1) {
          kindMap.delete(oldestKind);
          this.logger.debug(`Evicted replaceable event kind ${oldestKind} for pubkey: ${pubkey2}`);
        }
      }
      kindMap.set(event2.kind, event2);
    }
  }
  // Evict oldest accessed replaceable event pubkey
  evictOldestReplaceablePubkey() {
    let oldestTime = Infinity;
    let oldestPubkey = "";
    for (const [pubkey2, time] of this.replaceableEventAccessTimes) {
      if (time < oldestTime) {
        oldestTime = time;
        oldestPubkey = pubkey2;
      }
    }
    if (oldestPubkey) {
      this.replaceableEvents.delete(oldestPubkey);
      this.replaceableEventAccessTimes.delete(oldestPubkey);
      this.logger.debug(`Evicted replaceable events for pubkey: ${oldestPubkey}`);
    }
  }
  // Process addressable event with memory limits
  processAddressableEvent(event2) {
    const dTag = event2.tags.find((tag) => tag[0] === "d");
    const dValue = dTag ? dTag[1] : "";
    const addressId = `${event2.kind}:${event2.pubkey}:${dValue}`;
    this.addressableEventAccessTimes.set(addressId, Date.now());
    if (!this.addressableEvents.has(addressId) && this.addressableEvents.size >= this.maxAddressableEvents) {
      this.evictOldestAddressableEvent();
    }
    const existingEvent = this.addressableEvents.get(addressId);
    if (!existingEvent || event2.created_at > existingEvent.created_at || event2.created_at === existingEvent.created_at && event2.id < existingEvent.id) {
      this.addressableEvents.set(addressId, event2);
    }
  }
  // Evict oldest accessed addressable event
  evictOldestAddressableEvent() {
    let oldestTime = Infinity;
    let oldestId = "";
    for (const [id, time] of this.addressableEventAccessTimes) {
      if (time < oldestTime) {
        oldestTime = time;
        oldestId = id;
      }
    }
    if (oldestId) {
      this.addressableEvents.delete(oldestId);
      this.addressableEventAccessTimes.delete(oldestId);
      this.logger.debug(`Evicted addressable event: ${oldestId}`);
    }
  }
  // Update getLatestReplaceableEvent to use access tracking
  getLatestReplaceableEvent(pubkey2, kind) {
    this.replaceableEventAccessTimes.set(pubkey2, Date.now());
    const kindMap = this.replaceableEvents.get(pubkey2);
    return kindMap?.get(kind);
  }
  // Update getLatestAddressableEvent to use access tracking
  getLatestAddressableEvent(kind, pubkey2, dTagValue = "") {
    const addressId = `${kind}:${pubkey2}:${dTagValue}`;
    this.addressableEventAccessTimes.set(addressId, Date.now());
    return this.addressableEvents.get(addressId);
  }
  /**
   * Get all addressable events for a specific pubkey
   *
   * @param pubkey The public key of the user
   * @returns Array of addressable events
   */
  getAddressableEventsByPubkey(pubkey2) {
    return Array.from(this.addressableEvents.values()).filter((event2) => event2.pubkey === pubkey2);
  }
  /**
   * Get all addressable events for a specific kind
   *
   * @param kind The kind of event to retrieve (30000-39999)
   * @returns Array of addressable events
   */
  getAddressableEventsByKind(kind) {
    return Array.from(this.addressableEvents.values()).filter((event2) => event2.kind === kind);
  }
  // Helper function to parse NIP-20 prefixes from OK messages
  parseOkMessage(rawMessage) {
    const result = {
      rawMessage: rawMessage || "",
      message: rawMessage || ""
      // Default to full message if no prefix
    };
    if (rawMessage) {
      for (const nipPrefix of Object.values(NIP20Prefix)) {
        if (rawMessage.startsWith(nipPrefix)) {
          result.prefix = nipPrefix;
          result.message = rawMessage.substring(nipPrefix.length).trimStart();
          break;
        }
      }
    }
    return result;
  }
  // Add this helper method to type guard for NostrEvent
  isNostrEvent(event2) {
    if (!event2 || typeof event2 !== "object")
      return false;
    const e = event2;
    return typeof e.id === "string" && typeof e.pubkey === "string" && typeof e.created_at === "number" && typeof e.kind === "number" && Array.isArray(e.tags) && typeof e.content === "string" && typeof e.sig === "string";
  }
  // New private helper method for validating NIP-01 filter identifiers
  _isValidNip01FilterIdentifier(value) {
    if (typeof value !== "string") {
      return false;
    }
    return /^[0-9a-f]{64}$/.test(value);
  }
};

// node_modules/snstr/dist/esm/src/utils/relayUrl.js
var RelayUrlValidationError = class extends Error {
  constructor(message, errorType, invalidUrl) {
    super(message);
    this.name = "RelayUrlValidationError";
    this.errorType = errorType;
    this.invalidUrl = invalidUrl;
  }
};
function preprocessRelayUrl(url) {
  if (!url || typeof url !== "string") {
    throw new RelayUrlValidationError("URL must be a non-empty string", "format");
  }
  let trimmedUrl = url.trim();
  if (trimmedUrl.startsWith("//")) {
    trimmedUrl = trimmedUrl.slice(2);
  }
  if (!trimmedUrl) {
    throw new RelayUrlValidationError("URL cannot be empty or whitespace only", "format");
  }
  const schemePattern = /^([a-zA-Z][a-zA-Z0-9+.-]*):\/\//;
  const schemeMatch = trimmedUrl.match(schemePattern);
  if (schemeMatch) {
    const scheme = schemeMatch[1].toLowerCase();
    if (scheme === "ws" || scheme === "wss") {
      return trimmedUrl;
    }
    throw new RelayUrlValidationError(`Invalid relay URL scheme: "${scheme}://". Relay URLs must use WebSocket protocols (ws:// or wss://). Got: "${trimmedUrl}"`, "scheme", trimmedUrl);
  }
  if (trimmedUrl.includes("://")) {
    try {
      const originalParsed = new URL(trimmedUrl);
      if (originalParsed.protocol !== "ws:" && originalParsed.protocol !== "wss:") {
        throw new RelayUrlValidationError(`Invalid relay URL scheme: "${originalParsed.protocol}//". Relay URLs must use WebSocket protocols (ws:// or wss://). Got: "${trimmedUrl}"`, "scheme", trimmedUrl);
      }
      return trimmedUrl;
    } catch (urlError) {
      throw new RelayUrlValidationError(`Invalid URL format: "${trimmedUrl}". Unable to parse the provided URL.`, "format", trimmedUrl);
    }
  }
  const firstSlashIndex = trimmedUrl.indexOf("/");
  const hostPortPart = firstSlashIndex === -1 ? trimmedUrl : trimmedUrl.substring(0, firstSlashIndex);
  const pathQueryFragmentPart = firstSlashIndex === -1 ? "" : trimmedUrl.substring(firstSlashIndex);
  let hostPart = hostPortPart;
  let portPart = "";
  if (hostPart.includes(":") && !hostPart.startsWith("[")) {
    const lastColonIndex = hostPart.lastIndexOf(":");
    if (lastColonIndex !== -1) {
      const potentialPort = hostPart.substring(lastColonIndex + 1);
      const potentialHost = hostPart.substring(0, lastColonIndex);
      if (/^\d{1,5}$/.test(potentialPort)) {
        const portNumber = parseInt(potentialPort, 10);
        if (portNumber >= 1 && portNumber <= 65535) {
          const hostColonCount = (potentialHost.match(/:/g) || []).length;
          const hasDoubleColon2 = potentialHost.includes("::");
          const isLikelyIPv6 = hostColonCount >= 1 || hasDoubleColon2;
          if (isLikelyIPv6) {
            hostPart = potentialHost;
            portPart = `:${potentialPort}`;
          }
        }
      }
    }
    const colonCount = (hostPart.match(/:/g) || []).length;
    const hasDoubleColon = hostPart.includes("::");
    if (colonCount >= 2 || hasDoubleColon) {
      hostPart = `[${hostPart}]`;
    }
  }
  const fullHost = hostPart + portPart + pathQueryFragmentPart;
  const testUrl = `wss://${fullHost}`;
  try {
    new URL(testUrl);
    return testUrl;
  } catch (urlError) {
    throw new RelayUrlValidationError(`Invalid URL format: "${trimmedUrl}". Unable to construct a valid WebSocket URL.`, "construction", trimmedUrl);
  }
}
function normalizeRelayUrl(url) {
  const preprocessed = preprocessRelayUrl(url);
  const parsed = new URL(preprocessed);
  const includePathname = parsed.pathname && parsed.pathname !== "/";
  let normalized = `${parsed.protocol.toLowerCase()}//${parsed.host.toLowerCase()}`;
  if (includePathname) {
    normalized += parsed.pathname;
  }
  if (parsed.search) {
    normalized += parsed.search;
  }
  if (parsed.hash) {
    normalized += parsed.hash;
  }
  if (!isValidRelayUrl(normalized)) {
    throw new RelayUrlValidationError(`Normalized URL failed security validation: "${normalized}". The URL may contain invalid characters or unsafe patterns.`, "security", normalized);
  }
  return normalized;
}

// node_modules/snstr/dist/esm/src/nip01/nostr.js
var Nostr = class {
  /**
   * Create a new Nostr client
   * @param relayUrls List of relay URLs to connect to
   * @param options Client options
   * @param options.relayOptions Options to pass to each Relay instance
   * @param options.rateLimits Rate limiting configuration for different operations
   */
  constructor(relayUrls = [], options) {
    this.relays = /* @__PURE__ */ new Map();
    this.eventCallbacks = /* @__PURE__ */ new Map();
    this.subscribeRateLimit = {
      count: 0,
      windowStart: Date.now(),
      blocked: false
    };
    this.publishRateLimit = {
      count: 0,
      windowStart: Date.now(),
      blocked: false
    };
    this.fetchRateLimit = {
      count: 0,
      windowStart: Date.now(),
      blocked: false
    };
    this.relayOptions = options?.relayOptions;
    this.RATE_LIMITS = {
      SUBSCRIBE: options?.rateLimits?.subscribe || {
        limit: 50,
        windowMs: 6e4
      },
      // 50 subscriptions per minute
      PUBLISH: options?.rateLimits?.publish || { limit: 100, windowMs: 6e4 },
      // 100 publications per minute
      FETCH: options?.rateLimits?.fetch || { limit: 200, windowMs: 6e4 }
      // 200 fetches per minute
    };
    this.logger = new Logger({
      prefix: "Nostr",
      level: LogLevel.WARN,
      includeTimestamp: false,
      silent: false
    });
    relayUrls.forEach((url) => this.addRelay(url));
  }
  /**
   * Normalize a relay URL by lowercasing only the scheme and host,
   * while preserving the case of path, query, and fragment parts.
   * This is the correct behavior per URL standards.
   */
  normalizeRelayUrl(url) {
    return normalizeRelayUrl(url);
  }
  /**
   * Preprocesses a relay URL before normalization and validation.
   * Adds wss:// prefix only to URLs without any scheme.
   * Throws an error for URLs with incompatible schemes.
   *
   * @param url - The input URL string to preprocess
   * @returns The preprocessed URL with appropriate scheme
   * @throws Error if URL has an incompatible scheme
   */
  preprocessRelayUrl(url) {
    return preprocessRelayUrl(url);
  }
  // Helper function to create the event handler wrapper
  _createRelayEventHandler(relayUrl, originalCallback, event2) {
    switch (event2) {
      case RelayEvent.Connect:
      case RelayEvent.Disconnect:
        return () => {
          originalCallback(relayUrl);
        };
      case RelayEvent.Error:
        return (error) => {
          originalCallback(relayUrl, error);
        };
      case RelayEvent.Notice:
        return (notice) => {
          originalCallback(relayUrl, notice);
        };
      case RelayEvent.OK:
        return (eventId, success, details) => {
          originalCallback(relayUrl, eventId, success, details);
        };
      case RelayEvent.Closed:
        return (subscriptionId, message) => {
          originalCallback(relayUrl, subscriptionId, message);
        };
      case RelayEvent.Auth:
        return (challengeEvent) => {
          originalCallback(relayUrl, challengeEvent);
        };
      default:
        console.warn(`Unhandled RelayEvent type for handler creation: ${event2}`);
        return () => {
        };
    }
  }
  addRelay(url) {
    url = this.preprocessRelayUrl(url);
    url = this.normalizeRelayUrl(url);
    if (!isValidRelayUrl(url)) {
      throw new Error(`Invalid relay URL: ${url}`);
    }
    if (this.relays.has(url)) {
      return this.relays.get(url);
    }
    const relay = new Relay(url, this.relayOptions);
    this.relays.set(url, relay);
    this.eventCallbacks.forEach((callbacksSet, eventType) => {
      callbacksSet.forEach((originalCallback) => {
        const handler = this._createRelayEventHandler(url, originalCallback, eventType);
        switch (eventType) {
          case RelayEvent.Connect:
          case RelayEvent.Disconnect:
            relay.on(eventType, handler);
            break;
          case RelayEvent.Error:
            relay.on(eventType, handler);
            break;
          case RelayEvent.Notice:
            relay.on(eventType, handler);
            break;
          case RelayEvent.OK:
            relay.on(eventType, handler);
            break;
          case RelayEvent.Closed:
            relay.on(eventType, handler);
            break;
          case RelayEvent.Auth:
            relay.on(eventType, handler);
            break;
        }
      });
    });
    return relay;
  }
  getRelay(url) {
    try {
      url = this.preprocessRelayUrl(url);
      url = this.normalizeRelayUrl(url);
      if (!isValidRelayUrl(url)) {
        return void 0;
      }
      return this.relays.get(url);
    } catch (error) {
      if (error instanceof RelayUrlValidationError) {
        return void 0;
      }
      return void 0;
    }
  }
  removeRelay(url) {
    try {
      url = this.preprocessRelayUrl(url);
      url = this.normalizeRelayUrl(url);
      if (!isValidRelayUrl(url)) {
        return;
      }
      const relay = this.relays.get(url);
      if (relay) {
        relay.disconnect();
        this.relays.delete(url);
      }
    } catch (error) {
      if (error instanceof RelayUrlValidationError) {
        return;
      }
      return;
    }
  }
  async connectToRelays() {
    const connectPromises = Array.from(this.relays.values()).map((relay) => relay.connect());
    await Promise.all(connectPromises);
  }
  disconnectFromRelays() {
    this.relays.forEach((relay) => relay.disconnect());
  }
  setPrivateKey(privateKey2) {
    this.privateKey = privateKey2;
    this.publicKey = getPublicKey(privateKey2);
  }
  async generateKeys() {
    const keypair = await generateKeypair();
    this.privateKey = keypair.privateKey;
    this.publicKey = keypair.publicKey;
    return keypair;
  }
  getPublicKey() {
    return this.publicKey;
  }
  /**
   * Get current rate limit configuration
   * @returns Current rate limit settings
   */
  getRateLimits() {
    return {
      subscribe: { ...this.RATE_LIMITS.SUBSCRIBE },
      publish: { ...this.RATE_LIMITS.PUBLISH },
      fetch: { ...this.RATE_LIMITS.FETCH }
    };
  }
  /**
   * Update rate limit configuration
   * @param rateLimits New rate limit settings (partial updates allowed)
   */
  updateRateLimits(rateLimits) {
    if (rateLimits.subscribe) {
      this.RATE_LIMITS.SUBSCRIBE = { ...rateLimits.subscribe };
      this.subscribeRateLimit = {
        count: 0,
        windowStart: Date.now(),
        blocked: false
      };
    }
    if (rateLimits.publish) {
      this.RATE_LIMITS.PUBLISH = { ...rateLimits.publish };
      this.publishRateLimit = {
        count: 0,
        windowStart: Date.now(),
        blocked: false
      };
    }
    if (rateLimits.fetch) {
      this.RATE_LIMITS.FETCH = { ...rateLimits.fetch };
      this.fetchRateLimit = {
        count: 0,
        windowStart: Date.now(),
        blocked: false
      };
    }
  }
  /**
   * Reset rate limit counters for all operations
   */
  resetRateLimits() {
    this.subscribeRateLimit = {
      count: 0,
      windowStart: Date.now(),
      blocked: false
    };
    this.publishRateLimit = {
      count: 0,
      windowStart: Date.now(),
      blocked: false
    };
    this.fetchRateLimit = {
      count: 0,
      windowStart: Date.now(),
      blocked: false
    };
  }
  async publishEvent(event2, options) {
    if (!this.relays.size) {
      this.logger.warn("No relays configured for publishing", {
        eventId: event2.id,
        eventKind: event2.kind,
        operation: "publishEvent"
      });
      return {
        success: false,
        event: null,
        relayResults: /* @__PURE__ */ new Map()
      };
    }
    try {
      const relayResults = /* @__PURE__ */ new Map();
      const publishPromises = Array.from(this.relays.entries()).map(async ([url, relay]) => {
        const result = await relay.publish(event2, options);
        relayResults.set(url, result);
        return result;
      });
      const results = await Promise.all(publishPromises);
      const atLeastOneSuccess = results.some((result) => result.success);
      if (atLeastOneSuccess) {
        return {
          success: true,
          event: event2,
          relayResults
        };
      } else {
        const failureReasons = Array.from(relayResults.entries()).filter(([_, result]) => !result.success).map(([url, result]) => `${url}: ${result.reason || "unknown"}`);
        this.logger.warn("Failed to publish event to any relay", {
          eventId: event2.id,
          eventKind: event2.kind,
          failureCount: failureReasons.length,
          failures: failureReasons
        });
        return {
          success: false,
          event: null,
          relayResults
        };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "unknown error";
      this.logger.error("Failed to publish event", {
        eventId: event2.id,
        eventKind: event2.kind,
        error: errorMessage
      });
      return {
        success: false,
        event: null,
        relayResults: /* @__PURE__ */ new Map()
      };
    }
  }
  async publishTextNote(content2, tags2 = [], options) {
    const rateLimitCheck = checkRateLimit(this.publishRateLimit, this.RATE_LIMITS.PUBLISH.limit, this.RATE_LIMITS.PUBLISH.windowMs);
    if (!rateLimitCheck.allowed) {
      throw new SecurityValidationError(`Publish rate limit exceeded. Try again in ${Math.ceil((rateLimitCheck.retryAfter || 0) / 1e3)} seconds`, "RATE_LIMIT_EXCEEDED", "publish");
    }
    this.publishRateLimit.count++;
    if (!this.privateKey || !this.publicKey) {
      throw new Error("Private key is not set");
    }
    try {
      const validatedContent2 = validateEventContent(content2);
      const validatedTags2 = validateTags(tags2);
      const contentByteLength2 = new TextEncoder().encode(validatedContent2).length;
      if (contentByteLength2 > SECURITY_LIMITS.MAX_CONTENT_SIZE) {
        throw new Error(`Content too large: ${contentByteLength2} bytes (max ${SECURITY_LIMITS.MAX_CONTENT_SIZE})`);
      }
      const noteTemplate = createTextNote(validatedContent2, this.privateKey, validatedTags2);
      const signedEvent = await createSignedEvent(noteTemplate, this.privateKey);
      const publishResult = await this.publishEvent(signedEvent, options);
      return publishResult.success ? publishResult.event : null;
    } catch (error) {
      throw new Error(`publishTextNote validation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async publishDirectMessage(content2, recipientPubkey2, tags2 = [], options) {
    if (!this.privateKey || !this.publicKey) {
      throw new Error("Private key is not set");
    }
    const dmTemplate = await createDirectMessage(content2, recipientPubkey2, this.privateKey, tags2);
    const signedEvent = await createSignedEvent(dmTemplate, this.privateKey);
    const publishResult = await this.publishEvent(signedEvent, options);
    return publishResult.success ? publishResult.event : null;
  }
  /**
   * Decrypt a direct message received from another user
   *
   * Uses NIP-04 encryption which is the standard for kind:4 direct messages
   */
  decryptDirectMessage(event) {
    if (!this.privateKey) {
      throw new Error("Private key is not set");
    }
    if (event.kind !== 4) {
      throw new Error("Event is not a direct message (kind 4)");
    }
    const senderPubkey = event.pubkey;
    const pTag = event.tags.find((tag) => tag[0] === "p");
    if (!pTag || !pTag[1]) {
      throw new Error("Direct message is missing recipient pubkey in p tag");
    }
    const recipientPubkey = pTag[1];
    if (this.publicKey && recipientPubkey !== this.publicKey) {
      this.logger.warn("Direct message not intended for this user", {
        recipientPubkey,
        currentUserPubkey: this.publicKey,
        senderPubkey
      });
    }
    try {
      const decryptNIP04 = (() => {
        try {
          if (typeof process !== "undefined" && process.versions && process.versions.node) {
            return eval('require("../nip04")').decrypt;
          }
        } catch (_e) {
        }
        try {
          return eval('require("../nip04/web")').decrypt;
        } catch (_e) {
        }
        throw new Error("NIP-04 module not available in this environment");
      })();
      return decryptNIP04(this.privateKey, senderPubkey, event.content);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "unknown error";
      this.logger.error("Failed to decrypt direct message", {
        eventId: event.id,
        senderPubkey,
        recipientPubkey,
        error: errorMessage
      });
      throw new Error("Failed to decrypt message. Make sure you are the intended recipient.");
    }
  }
  async publishMetadata(metadata, options) {
    if (!this.privateKey || !this.publicKey) {
      throw new Error("Private key is not set");
    }
    const metadataTemplate = createMetadataEvent(metadata, this.privateKey);
    const signedEvent = await createSignedEvent(metadataTemplate, this.privateKey);
    const publishResult = await this.publishEvent(signedEvent, options);
    return publishResult.success ? publishResult.event : null;
  }
  subscribe(filters, onEvent, onEOSE, options = {}) {
    const rateLimitCheck = checkRateLimit(this.subscribeRateLimit, this.RATE_LIMITS.SUBSCRIBE.limit, this.RATE_LIMITS.SUBSCRIBE.windowMs);
    if (!rateLimitCheck.allowed) {
      throw new SecurityValidationError(`Subscription rate limit exceeded. Try again in ${Math.ceil((rateLimitCheck.retryAfter || 0) / 1e3)} seconds`, "RATE_LIMIT_EXCEEDED", "subscribe");
    }
    this.subscribeRateLimit.count++;
    try {
      const validatedFilters = validateFilters(filters);
      const subscriptionIds = [];
      this.relays.forEach((relay, url) => {
        const id = relay.subscribe(validatedFilters, (event2) => onEvent(event2, url), onEOSE, options);
        subscriptionIds.push(id);
      });
      return subscriptionIds;
    } catch (error) {
      throw new Error(`Filter validation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  unsubscribe(subscriptionIds) {
    this.relays.forEach((relay) => {
      subscriptionIds.forEach((id) => relay.unsubscribe(id));
    });
  }
  unsubscribeAll() {
    this.relays.forEach((relay) => {
      const subscriptionIds = Array.from(relay.getSubscriptionIds());
      subscriptionIds.forEach((id) => relay.unsubscribe(id));
    });
  }
  /**
   * Collect events matching the given filters from all connected relays.
   *
   * @param filters Array of filters to apply
   * @param options Optional max wait time in milliseconds (defaults to 5000ms if not provided)
   * @returns Promise resolving to all received events
   */
  async fetchMany(filters, options = {}) {
    const rateLimitCheck = checkRateLimit(this.fetchRateLimit, this.RATE_LIMITS.FETCH.limit, this.RATE_LIMITS.FETCH.windowMs);
    if (!rateLimitCheck.allowed) {
      throw new SecurityValidationError(`Fetch rate limit exceeded. Try again in ${Math.ceil((rateLimitCheck.retryAfter || 0) / 1e3)} seconds`, "RATE_LIMIT_EXCEEDED", "fetch");
    }
    this.fetchRateLimit.count++;
    if (this.relays.size === 0)
      return [];
    try {
      const validatedFilters = validateFilters(filters);
      const maxWait = options.maxWait ? validateNumber(options.maxWait, 0, 3e5, "fetchMany.maxWait") : 5e3;
      return new Promise((resolve, reject) => {
        const eventsMap = /* @__PURE__ */ new Map();
        let eoseCount = 0;
        let isCleanedUp = false;
        const subIds = this.subscribe(validatedFilters, (event2) => {
          eventsMap.set(event2.id, event2);
        }, () => {
          eoseCount++;
          if (eoseCount >= this.relays.size) {
            cleanup(false);
          }
        });
        let timeoutId = null;
        let abortListener = null;
        const cleanup = (isAborted = false) => {
          if (isCleanedUp)
            return;
          isCleanedUp = true;
          if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          if (abortListener && options.signal) {
            options.signal.removeEventListener("abort", abortListener);
            abortListener = null;
          }
          this.unsubscribe(subIds);
          if (isAborted) {
            reject(new Error("Fetch operation was aborted"));
          } else {
            resolve(Array.from(eventsMap.values()));
          }
        };
        if (options.signal) {
          if (options.signal.aborted) {
            cleanup(true);
            return;
          }
          abortListener = () => cleanup(true);
          options.signal.addEventListener("abort", abortListener);
        }
        if (maxWait > 0) {
          timeoutId = setTimeout(() => cleanup(false), maxWait);
        }
      });
    } catch (error) {
      throw new Error(`fetchMany validation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Retrieve the newest single event matching the filters from all relays.
   *
   * @param filters Filters to apply (limit will be forced to 1)
   * @param options Optional max wait time in milliseconds and abort signal
   * @returns The newest matching event or null
   */
  async fetchOne(filters, options) {
    const limitedFilters = filters.map((f) => ({ ...f, limit: 1 }));
    const events = await this.fetchMany(limitedFilters, options);
    if (events.length === 0)
      return null;
    events.sort((a, b) => {
      if (a.created_at !== b.created_at) {
        return b.created_at - a.created_at;
      }
      return a.id.localeCompare(b.id);
    });
    return events[0];
  }
  on(event2, callback) {
    if (typeof callback !== "function") {
      throw new Error("Callback must be a function");
    }
    let callbacksForEvent = this.eventCallbacks.get(event2);
    if (!callbacksForEvent) {
      callbacksForEvent = /* @__PURE__ */ new Set();
      this.eventCallbacks.set(event2, callbacksForEvent);
    }
    callbacksForEvent.add(callback);
    this.relays.forEach((relay, url) => {
      const handler = this._createRelayEventHandler(url, callback, event2);
      switch (event2) {
        case RelayEvent.Connect:
        case RelayEvent.Disconnect:
          relay.on(event2, handler);
          break;
        case RelayEvent.Error:
          relay.on(event2, handler);
          break;
        case RelayEvent.Notice:
          relay.on(event2, handler);
          break;
        case RelayEvent.OK:
          relay.on(event2, handler);
          break;
        case RelayEvent.Closed:
          relay.on(event2, handler);
          break;
        case RelayEvent.Auth:
          relay.on(event2, handler);
          break;
      }
    });
  }
  /**
   * Publish an event and get detailed results from all relays
   *
   * @param event The NostrEvent to publish
   * @param options Options including timeout
   * @returns Detailed publish results including success status and relay-specific information
   */
  async publishWithDetails(event2, options) {
    const result = await this.publishEvent(event2, options);
    let successCount = 0;
    let failureCount = 0;
    result.relayResults.forEach((relayResult) => {
      if (relayResult.success) {
        successCount++;
      } else {
        failureCount++;
      }
    });
    return {
      ...result,
      event: result.event || event2,
      successCount,
      failureCount
    };
  }
  /**
   * Get the latest replaceable event of a specific kind for a pubkey from all connected relays
   *
   * @param pubkey The public key of the user
   * @param kind The kind of event to retrieve (0, 3, or 10000-19999)
   * @returns The latest event or null if none exists
   */
  getLatestReplaceableEvent(pubkey2, kind) {
    let latestEvent = null;
    for (const relay of this.relays.values()) {
      const event2 = relay.getLatestReplaceableEvent(pubkey2, kind);
      if (event2 && (!latestEvent || event2.created_at > latestEvent.created_at || event2.created_at === latestEvent.created_at && event2.id < latestEvent.id)) {
        latestEvent = event2;
      }
    }
    return latestEvent;
  }
  /**
   * Get the latest addressable event for a specific kind, pubkey, and d-tag value
   * from all connected relays
   *
   * @param kind The kind of event to retrieve (30000-39999)
   * @param pubkey The public key of the user
   * @param dTagValue The value of the d tag
   * @returns The latest event or null if none exists
   */
  getLatestAddressableEvent(kind, pubkey2, dTagValue = "") {
    let latestEvent = null;
    for (const relay of this.relays.values()) {
      const event2 = relay.getLatestAddressableEvent(kind, pubkey2, dTagValue);
      if (event2 && (!latestEvent || event2.created_at > latestEvent.created_at || event2.created_at === latestEvent.created_at && event2.id < latestEvent.id)) {
        latestEvent = event2;
      }
    }
    return latestEvent;
  }
  /**
   * Get all addressable events for a specific pubkey from all connected relays
   *
   * @param pubkey The public key of the user
   * @returns Array of unique addressable events
   */
  getAddressableEventsByPubkey(pubkey2) {
    const eventsMap = /* @__PURE__ */ new Map();
    for (const relay of this.relays.values()) {
      const events = relay.getAddressableEventsByPubkey(pubkey2);
      for (const event2 of events) {
        const dTag = event2.tags.find((tag) => tag[0] === "d");
        const dValue = dTag ? dTag[1] : "";
        const key = `${event2.kind}:${event2.pubkey}:${dValue}`;
        const existing = eventsMap.get(key);
        if (!existing || event2.created_at > existing.created_at) {
          eventsMap.set(key, event2);
        }
      }
    }
    return Array.from(eventsMap.values());
  }
  /**
   * Get all addressable events for a specific kind from all connected relays
   *
   * @param kind The kind of event to retrieve (30000-39999)
   * @returns Array of unique addressable events
   */
  getAddressableEventsByKind(kind) {
    const eventsMap = /* @__PURE__ */ new Map();
    for (const relay of this.relays.values()) {
      const events = relay.getAddressableEventsByKind(kind);
      for (const event2 of events) {
        const dTag = event2.tags.find((tag) => tag[0] === "d");
        const dValue = dTag ? dTag[1] : "";
        const key = `${event2.pubkey}:${dValue}`;
        const existing = eventsMap.get(key);
        if (!existing || event2.created_at > existing.created_at) {
          eventsMap.set(key, event2);
        }
      }
    }
    return Array.from(eventsMap.values());
  }
};

// node_modules/snstr/dist/esm/src/nip01/relayPool.js
var RemoveRelayResult;
(function(RemoveRelayResult2) {
  RemoveRelayResult2["Removed"] = "removed";
  RemoveRelayResult2["NotFound"] = "not_found";
  RemoveRelayResult2["InvalidUrl"] = "invalid_url";
})(RemoveRelayResult || (RemoveRelayResult = {}));
var RelayPool = class {
  constructor(relayUrls = [], options) {
    this.relays = /* @__PURE__ */ new Map();
    this.relayOptions = options?.relayOptions;
    relayUrls.forEach((url) => {
      try {
        this.addRelay(url);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.warn(`Failed to add relay "${url}" during pool construction:`, errorMessage);
      }
    });
  }
  /**
   * Normalize a relay URL by preprocessing, case normalizing, and validating.
   * This ensures consistent URL keys in the relay map and prevents duplicates.
   *
   * @param url - The input URL string to normalize
   * @returns The canonicalized URL
   * @throws Error if the URL is invalid or normalization fails
   */
  normalizeRelayUrl(url) {
    const normalizedUrl = normalizeRelayUrl(url);
    if (normalizedUrl === void 0 || normalizedUrl === null || typeof normalizedUrl !== "string") {
      throw new Error(`Failed to normalize relay URL "${url}": received invalid result`);
    }
    if (normalizedUrl.length === 0) {
      throw new Error(`Failed to normalize relay URL "${url}": received empty string`);
    }
    return normalizedUrl;
  }
  /**
   * Add a relay to the pool or update an existing relay's configuration.
   *
   * @param url - The relay URL to add
   * @param options - Connection options for the relay
   * @returns The relay instance (new or existing)
   *
   * Note: If the relay already exists, most options will be merged into the existing
   * relay's configuration. However, `bufferFlushDelay` can only be set during
   * relay construction and will be ignored for existing relays.
   */
  addRelay(url, options) {
    const normalizedUrl = this.normalizeRelayUrl(url);
    let relay = this.relays.get(normalizedUrl);
    if (!relay) {
      relay = new Relay(normalizedUrl, options || this.relayOptions);
      this.relays.set(normalizedUrl, relay);
    } else if (options) {
      if (options.connectionTimeout !== void 0) {
        relay.setConnectionTimeout(options.connectionTimeout);
      }
      if (options.autoReconnect !== void 0) {
        relay.setAutoReconnect(options.autoReconnect);
      }
      if (options.maxReconnectAttempts !== void 0) {
        relay.setMaxReconnectAttempts(options.maxReconnectAttempts);
      }
      if (options.maxReconnectDelay !== void 0) {
        relay.setMaxReconnectDelay(options.maxReconnectDelay);
      }
    }
    return relay;
  }
  removeRelay(url) {
    let normalizedUrl;
    try {
      normalizedUrl = this.normalizeRelayUrl(url);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.warn(`Invalid relay URL "${url}":`, errorMessage);
      return RemoveRelayResult.InvalidUrl;
    }
    const relay = this.relays.get(normalizedUrl);
    if (!relay) {
      return RemoveRelayResult.NotFound;
    }
    try {
      relay.disconnect();
      this.relays.delete(normalizedUrl);
      return RemoveRelayResult.Removed;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Unexpected error during relay removal for "${url}": ${errorMessage}`);
    }
  }
  async ensureRelay(url) {
    const relay = this.addRelay(url);
    await relay.connect();
    return relay;
  }
  /**
   * Close relay connections. Invalid relay URLs are ignored.
   * @param relayUrls Optional array of relay URLs to close. If not provided, all relays are closed.
   */
  async close(relayUrls) {
    if (relayUrls) {
      relayUrls.forEach((url) => {
        try {
          const normalizedUrl = this.normalizeRelayUrl(url);
          const relay = this.relays.get(normalizedUrl);
          if (relay)
            relay.disconnect();
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.warn(`Failed to close relay "${url}":`, errorMessage);
        }
      });
    } else {
      this.relays.forEach((relay) => relay.disconnect());
    }
    await new Promise((resolve) => setTimeout(resolve, 10));
  }
  publish(relays, event2, options) {
    return relays.map(async (url) => {
      const relay = await this.ensureRelay(url);
      return relay.publish(event2, options);
    });
  }
  async subscribe(relays, filters, onEvent, onEOSE) {
    const subscriptions = [];
    let eoseCount = 0;
    let isClosed = false;
    let successfulRelayCount = 0;
    let eoseSent = false;
    const safeOnEvent = (event2, relayUrl) => {
      if (isClosed)
        return;
      try {
        onEvent(event2, relayUrl);
      } catch (eventError) {
        console.warn(`Error processing event from ${relayUrl}:`, eventError, event2);
      }
    };
    const subscriptionPromises = relays.map(async (url) => {
      try {
        const relay = await this.ensureRelay(url);
        return { success: true, url, relay };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.warn(`Failed to subscribe to relay ${url}:`, errorMessage);
        return { success: false, url, error: errorMessage };
      }
    });
    const results = await Promise.all(subscriptionPromises);
    const successfulRelays = [];
    results.forEach((result) => {
      if (result.success) {
        successfulRelays.push({ url: result.url, relay: result.relay });
      }
    });
    successfulRelayCount = successfulRelays.length;
    const safeOnEOSE = () => {
      if (isClosed || eoseSent)
        return;
      eoseCount++;
      if (eoseCount >= successfulRelayCount && onEOSE) {
        try {
          eoseSent = true;
          onEOSE();
        } catch (eoseError) {
          console.warn("Error in EOSE callback:", eoseError);
        }
      }
    };
    successfulRelays.forEach(({ url, relay }) => {
      try {
        const id = relay.subscribe(filters, (ev) => safeOnEvent(ev, url), safeOnEOSE);
        const subscription = { relay, id, ready: true };
        subscriptions.push(subscription);
      } catch (error) {
        console.warn(`Failed to create subscription for relay ${url}:`, error);
        if (successfulRelayCount > 0) {
          successfulRelayCount--;
          if (eoseCount >= successfulRelayCount && onEOSE && !isClosed && !eoseSent) {
            try {
              eoseSent = true;
              onEOSE();
            } catch (eoseError) {
              console.warn("Error in EOSE callback (after subscription failure):", eoseError);
            }
          }
        }
      }
    });
    if (successfulRelayCount === 0 && onEOSE && !isClosed && !eoseSent) {
      try {
        eoseSent = true;
        onEOSE();
      } catch (eoseError) {
        console.warn("Error in EOSE callback (all relays failed):", eoseError);
      }
    }
    const immediateClose = () => {
      if (isClosed)
        return;
      isClosed = true;
      subscriptions.forEach(({ relay, id, ready }) => {
        if (ready) {
          try {
            relay.unsubscribe(id);
          } catch (unsubError) {
            console.warn("Error during unsubscribe:", unsubError);
          }
        }
      });
      subscriptions.length = 0;
    };
    return {
      close: immediateClose
    };
  }
  async querySync(relays, filter, options = {}) {
    return new Promise((resolve, reject) => {
      const events = [];
      let timer = null;
      let sub = null;
      let isResolved = false;
      const cleanup = () => {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        if (sub) {
          try {
            sub.close();
          } catch (cleanupError) {
            console.warn("Error during subscription cleanup:", cleanupError);
          }
          sub = null;
        }
      };
      const safeResolve = (result) => {
        if (!isResolved) {
          isResolved = true;
          cleanup();
          resolve(result);
        }
      };
      const safeReject = (error) => {
        if (!isResolved) {
          isResolved = true;
          cleanup();
          reject(error);
        }
      };
      try {
        this.subscribe(relays, [filter], (ev) => {
          try {
            events.push(ev);
          } catch (eventError) {
            console.warn("Error processing event:", eventError, ev);
          }
        }, () => {
          safeResolve(events);
        }).then((subscription) => {
          try {
            sub = subscription;
            if (options.timeout && options.timeout > 0) {
              timer = setTimeout(() => {
                safeResolve(events);
              }, options.timeout);
            }
          } catch (subscriptionError) {
            safeReject(new Error(`Failed to setup subscription: ${subscriptionError instanceof Error ? subscriptionError.message : String(subscriptionError)}`));
          }
        }).catch((subscribeError) => {
          safeReject(new Error(`Failed to subscribe to relays: ${subscribeError.message}`));
        });
      } catch (error) {
        safeReject(new Error(`Failed to initialize querySync: ${error instanceof Error ? error.message : String(error)}`));
      }
    });
  }
  async get(relays, filter, options = {}) {
    const f = { ...filter, limit: 1 };
    const events = await this.querySync(relays, f, options);
    events.sort((a, b) => b.created_at - a.created_at);
    return events[0] || null;
  }
};

// node_modules/snstr/dist/esm/src/nip02/index.js
function createContactListEvent(contacts, existingContent = "") {
  const tags2 = contacts.map((contact) => {
    const tag = ["p", contact.pubkey];
    if (contact.relayUrl || contact.petname) {
      tag.push(contact.relayUrl || "");
    }
    if (contact.petname) {
      tag.push(contact.petname);
    }
    return tag;
  });
  return {
    kind: 3,
    tags: tags2,
    content: existingContent,
    created_at: getUnixTime()
  };
}
function parseContactsFromEvent(event2, options = {}) {
  if (event2.kind !== 3) {
    throw new Error("Invalid event: Expected kind 3 for contact list.");
  }
  const parsedContacts = [];
  const warnings = [];
  const seenPubkeys = /* @__PURE__ */ new Set();
  const addWarning = (type, message, value, context) => {
    const warning = { type, message, value, context };
    warnings.push(warning);
    if (options.logger) {
      try {
        options.logger.warn(message, { value, context });
      } catch {
      }
    }
  };
  event2.tags.forEach((tag, tagIndex) => {
    try {
      if (!validateArrayAccess(tag, 0) || safeArrayAccess(tag, 0) !== "p") {
        return;
      }
      const pubkeyValue = safeArrayAccess(tag, 1);
      if (typeof pubkeyValue !== "string") {
        addWarning("invalid_pubkey", `Invalid p tag structure: pubkey at index 1 must be a string`, String(pubkeyValue), { tagIndex });
        return;
      }
      const normalizedPubkey = pubkeyValue.toLowerCase();
      if (!isValidPublicKeyPoint(normalizedPubkey)) {
        addWarning("invalid_pubkey", `Invalid public key (not a valid curve point): ${pubkeyValue}`, pubkeyValue, { tagIndex });
        return;
      }
      if (seenPubkeys.has(normalizedPubkey)) {
        addWarning("duplicate_pubkey", `Duplicate public key: ${normalizedPubkey}`, normalizedPubkey, { tagIndex });
        return;
      }
      seenPubkeys.add(normalizedPubkey);
      const contact = {
        pubkey: normalizedPubkey
      };
      const relayUrlValue = safeArrayAccess(tag, 2);
      if (typeof relayUrlValue === "string" && relayUrlValue.length > 0) {
        const trimmedRelayUrl = relayUrlValue.trim();
        if (trimmedRelayUrl.length > 0) {
          const hasWebSocketScheme = /^wss?:\/\//i.test(trimmedRelayUrl);
          if (!hasWebSocketScheme) {
            addWarning("invalid_relay_url", `Invalid relay URL (missing ws/wss scheme): ${relayUrlValue}`, relayUrlValue, {
              pubkey: normalizedPubkey,
              tagIndex
            });
          } else {
            let canonicalUrl;
            try {
              canonicalUrl = normalizeRelayUrl(trimmedRelayUrl);
            } catch {
              canonicalUrl = void 0;
            }
            if (canonicalUrl && isValidRelayUrl(canonicalUrl)) {
              contact.relayUrl = canonicalUrl;
            } else {
              addWarning("invalid_relay_url", `Invalid relay URL (failed validation): ${relayUrlValue}`, relayUrlValue, {
                pubkey: normalizedPubkey,
                tagIndex
              });
            }
          }
        }
      }
      const petnameValue = safeArrayAccess(tag, 3);
      if (typeof petnameValue === "string" && petnameValue.length > 0) {
        contact.petname = petnameValue;
      }
      parsedContacts.push(contact);
    } catch (error) {
      if (error instanceof SecurityValidationError) {
        addWarning("invalid_pubkey", `Bounds checking error: ${error.message}`, "", { tagIndex });
      }
    }
  });
  if (options.returnWarnings) {
    return { contacts: parsedContacts, warnings };
  }
  return parsedContacts;
}
function parseContactsFromEventWithWarnings(event2, logger) {
  return parseContactsFromEvent(event2, { logger, returnWarnings: true });
}

// node_modules/snstr/dist/esm/src/nip04/web.js
var CryptoJS = require_crypto_js();
var NIP04DecryptionError = class extends Error {
  constructor(message, originalError) {
    super(message);
    this.name = "NIP04DecryptionError";
    this.originalError = originalError;
  }
};
function base64Encode2(bytes2) {
  if (typeof globalThis?.btoa === "function") {
    try {
      const CHUNK_SIZE = 32768;
      const parts = [];
      for (let i2 = 0; i2 < bytes2.length; i2 += CHUNK_SIZE) {
        const chunk = bytes2.subarray(i2, i2 + CHUNK_SIZE);
        let s = "";
        for (let j = 0; j < chunk.length; j++)
          s += String.fromCharCode(chunk[j]);
        parts.push(s);
      }
      return globalThis.btoa(parts.join(""));
    } catch {
    }
  }
  if (typeof Buffer !== "undefined") {
    try {
      return Buffer.from(bytes2).toString("base64");
    } catch {
    }
  }
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  let out = "";
  let i = 0;
  while (i < bytes2.length) {
    const a = bytes2[i++];
    const b = i < bytes2.length ? bytes2[i++] : 0;
    const c = i < bytes2.length ? bytes2[i++] : 0;
    const t = a << 16 | b << 8 | c;
    out += chars[t >> 18 & 63] + chars[t >> 12 & 63];
    out += i - 2 < bytes2.length ? chars[t >> 6 & 63] : "=";
    out += i - 1 < bytes2.length ? chars[t & 63] : "=";
  }
  return out;
}
var BASE64_VALIDATION_REGEX2 = /^(?:(?:[A-Za-z0-9+/]{4})+(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?|[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)$/;
function base64Decode2(str) {
  if (!BASE64_VALIDATION_REGEX2.test(str)) {
    throw new Error("Invalid base64 alphabet");
  }
  if (typeof globalThis?.atob === "function") {
    try {
      const bin = globalThis.atob(str);
      const bytes2 = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++)
        bytes2[i] = bin.charCodeAt(i);
      return bytes2;
    } catch {
      throw new Error("Invalid base64 encoding");
    }
  }
  if (typeof Buffer !== "undefined") {
    try {
      return new Uint8Array(Buffer.from(str, "base64"));
    } catch {
      throw new Error("Invalid base64 encoding");
    }
  }
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  const lut = new Int16Array(256).fill(-1);
  for (let i = 0; i < chars.length; i++)
    lut[chars.charCodeAt(i)] = i;
  lut["=".charCodeAt(0)] = 0;
  const len = str.length;
  let outLen = Math.floor(len * 0.75);
  if (str[len - 1] === "=") {
    outLen--;
    if (str[len - 2] === "=")
      outLen--;
  }
  const out = new Uint8Array(outLen);
  let p = 0;
  for (let i = 0; i < len; i += 4) {
    const a = lut[str.charCodeAt(i)];
    const b = lut[str.charCodeAt(i + 1)];
    const c = lut[str.charCodeAt(i + 2)];
    const d = lut[str.charCodeAt(i + 3)];
    if (a < 0 || b < 0 || c < 0 || d < 0)
      throw new Error("Invalid base64");
    out[p++] = a << 2 | b >> 4;
    if (p < outLen)
      out[p++] = (b & 15) << 4 | c >> 2;
    if (p < outLen)
      out[p++] = (c & 3) << 6 | d;
  }
  return out;
}
function getSharedSecret2(privateKey2, publicKey) {
  const sk = hexToBytes(privateKey2);
  const pk = hexToBytes("02" + publicKey);
  const shared = secp256k1.getSharedSecret(sk, pk);
  return shared.slice(1, 33);
}
function encrypt2(privateKey2, publicKey, message) {
  const keyBytes = getSharedSecret2(privateKey2, publicKey);
  const iv = randomBytes(16);
  const keyWA = CryptoJS.enc.Hex.parse(bytesToHex(keyBytes));
  const ivWA = CryptoJS.enc.Hex.parse(bytesToHex(iv));
  const plaintextWA = CryptoJS.enc.Utf8.parse(message);
  const encrypted = CryptoJS.AES.encrypt(plaintextWA, keyWA, {
    iv: ivWA,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  });
  const ciphertextB64 = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
  const ivB64 = base64Encode2(iv);
  return `${ciphertextB64}?iv=${ivB64}`;
}
function isValidBase64(str) {
  try {
    base64Decode2(str);
    return true;
  } catch {
    return false;
  }
}
function decrypt2(privateKey2, publicKey, encryptedMessage) {
  try {
    if (typeof encryptedMessage !== "string") {
      throw new NIP04DecryptionError("Invalid encrypted message: must be a string");
    }
    if (!encryptedMessage.includes("?iv=")) {
      throw new NIP04DecryptionError("Invalid encrypted message format: missing IV separator");
    }
    const parts = encryptedMessage.split("?iv=");
    if (parts.length !== 2) {
      throw new NIP04DecryptionError("Invalid encrypted message format: multiple IV separators found");
    }
    const [encryptedText, ivBase64] = parts;
    if (!encryptedText || !ivBase64) {
      throw new NIP04DecryptionError("Invalid encrypted message format: empty ciphertext or IV");
    }
    if (!isValidBase64(encryptedText)) {
      throw new NIP04DecryptionError("Invalid encrypted message: ciphertext is not valid base64");
    }
    if (!isValidBase64(ivBase64)) {
      throw new NIP04DecryptionError("Invalid encrypted message: IV is not valid base64");
    }
    const iv = base64Decode2(ivBase64);
    if (iv.length !== 16) {
      throw new NIP04DecryptionError(`Invalid IV length: expected 16 bytes, got ${iv.length}`);
    }
    const keyBytes = getSharedSecret2(privateKey2, publicKey);
    const keyWA = CryptoJS.enc.Hex.parse(bytesToHex(keyBytes));
    const ivWA = CryptoJS.enc.Hex.parse(bytesToHex(iv));
    const cipherParams = CryptoJS.lib.CipherParams.create({
      ciphertext: CryptoJS.enc.Base64.parse(encryptedText)
    });
    const decrypted = CryptoJS.AES.decrypt(cipherParams, keyWA, {
      iv: ivWA,
      mode: CryptoJS.mode.CBC,
      padding: CryptoJS.pad.Pkcs7
    });
    const plaintext = CryptoJS.enc.Utf8.stringify(decrypted);
    const reEnc = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(plaintext), keyWA, {
      iv: ivWA,
      mode: CryptoJS.mode.CBC,
      padding: CryptoJS.pad.Pkcs7
    });
    const reEncB64 = reEnc.ciphertext.toString(CryptoJS.enc.Base64);
    if (reEncB64 !== encryptedText) {
      throw new NIP04DecryptionError("Failed to decrypt message");
    }
    return plaintext;
  } catch (error) {
    if (error instanceof NIP04DecryptionError)
      throw error;
    throw new NIP04DecryptionError("Failed to decrypt message");
  }
}

// node_modules/snstr/dist/esm/src/nip11/index.js
var relayInfoCache = {};
var CACHE_TTL = 1e3 * 60 * 60;
var fetchImplementation = globalThis.fetch;
function isValidWebSocketURL(url) {
  return /^wss?:\/\/[^\s/$.?#].[^\s]*$/i.test(url);
}
async function fetchRelayInformation(url, options = {}) {
  const { useCache = true, timeoutMs = 5e3 } = options;
  if (!isValidWebSocketURL(url)) {
    console.error(`Invalid WebSocket URL: ${url}`);
    return null;
  }
  const now = Date.now();
  if (useCache && relayInfoCache[url] && now - relayInfoCache[url].timestamp < CACHE_TTL) {
    return relayInfoCache[url].info;
  }
  try {
    const httpUrl = url.replace(/^ws(s)?:\/\//, "http$1://");
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    const response = await fetchImplementation(httpUrl, {
      headers: {
        Accept: "application/nostr+json"
      },
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    if (response.ok) {
      const relayInfo = await response.json();
      if (useCache) {
        relayInfoCache[url] = { info: relayInfo, timestamp: now };
      }
      return relayInfo;
    }
    if (useCache) {
      relayInfoCache[url] = { info: null, timestamp: now };
    }
    return null;
  } catch (error) {
    console.error(`Failed to fetch relay information from ${url}:`, error);
    if (useCache) {
      relayInfoCache[url] = { info: null, timestamp: now };
    }
    return null;
  }
}
async function supportsNIP11(url) {
  const info = await fetchRelayInformation(url);
  return info !== null;
}
async function relaySupportsNIPs(url, nipNumbers) {
  const info = await fetchRelayInformation(url);
  if (!info || !info.supported_nips) {
    return false;
  }
  return nipNumbers.every((nip) => info.supported_nips.includes(nip));
}
async function getRelayPaymentInfo(url) {
  const info = await fetchRelayInformation(url);
  return info?.payments_url || null;
}
async function relayRequiresPayment(url) {
  const info = await fetchRelayInformation(url);
  return !!info?.limitation?.payments_required;
}

// node_modules/snstr/dist/esm/src/nip17/index.js
var nodeCryptoModule = null;
var cryptoInitialized = false;
async function initializeCrypto() {
  if (typeof process !== "undefined" && process.versions && process.versions.node && !cryptoInitialized) {
    try {
      nodeCryptoModule = await import("./crypto-L37LMFJK.js");
      cryptoInitialized = true;
    } catch (error) {
    }
  }
}
function randomTimestampInPast() {
  const twoDays = 2 * 24 * 60 * 60 * 1e3;
  const secureRandomValue = (() => {
    if (typeof crypto !== "undefined" && crypto.getRandomValues) {
      const array = new Uint32Array(1);
      crypto.getRandomValues(array);
      return array[0] / (4294967295 + 1);
    } else if (typeof process !== "undefined" && process.versions && process.versions.node) {
      if (nodeCryptoModule) {
        return nodeCryptoModule.randomInt(0, 4294967296) / 4294967296;
      }
      try {
        const nodeCrypto2 = require_crypto();
        return nodeCrypto2.randomInt(0, 4294967296) / 4294967296;
      } catch (requireError) {
        throw new Error("No secure random source available for gift wrap timing. In ESM environments, call initializeCrypto() before using NIP-17 functions.");
      }
    }
    throw new Error("No secure random source available for gift wrap timing");
  })();
  const offset = Math.floor(secureRandomValue * twoDays);
  return Math.floor((Date.now() - offset) / 1e3);
}
var DM_KIND = 14;
var FILE_KIND = 15;
var SEAL_KIND = 13;
var GIFT_WRAP_KIND = 1059;
async function createDirectMessage2(message, senderPrivateKey, receiverPublicKey) {
  const senderPub = getPublicKey(senderPrivateKey);
  const rumor = {
    pubkey: senderPub,
    created_at: randomTimestampInPast(),
    kind: DM_KIND,
    tags: [["p", receiverPublicKey]],
    content: message
  };
  const sealedContent = encrypt(JSON.stringify(rumor), senderPrivateKey, receiverPublicKey);
  const seal = {
    pubkey: senderPub,
    created_at: randomTimestampInPast(),
    kind: SEAL_KIND,
    content: sealedContent,
    tags: []
  };
  const signedSeal = await createSignedEvent(seal, senderPrivateKey);
  const ephemeral = await generateKeypair();
  const wrappedContent = encrypt(JSON.stringify(signedSeal), ephemeral.privateKey, receiverPublicKey);
  const wrap = {
    pubkey: ephemeral.publicKey,
    created_at: randomTimestampInPast(),
    kind: GIFT_WRAP_KIND,
    content: wrappedContent,
    tags: [["p", receiverPublicKey]]
  };
  const signedWrap = await createSignedEvent(wrap, ephemeral.privateKey);
  return signedWrap;
}
function decryptDirectMessage(giftWrap, receiverPrivateKey) {
  if (giftWrap.kind !== GIFT_WRAP_KIND) {
    throw new Error("Invalid gift wrap kind");
  }
  const sealJson = decrypt(giftWrap.content, receiverPrivateKey, giftWrap.pubkey);
  const seal = JSON.parse(sealJson);
  if (seal.kind !== SEAL_KIND) {
    throw new Error("Invalid seal kind");
  }
  const validSeal = verifySignature(seal.id, seal.sig, seal.pubkey);
  if (!validSeal) {
    throw new Error("Invalid seal signature");
  }
  const rumorJson = decrypt(seal.content, receiverPrivateKey, seal.pubkey);
  const rumor = JSON.parse(rumorJson);
  if (rumor.pubkey !== seal.pubkey) {
    throw new Error("Sender mismatch between seal and rumor");
  }
  if (rumor.kind !== DM_KIND && rumor.kind !== FILE_KIND) {
    throw new Error("Invalid rumor kind");
  }
  return rumor;
}

// node_modules/snstr/dist/esm/src/nip21/index.js
var NOSTR_URI_PREFIX = "nostr:";
function encodeNostrURI(entity) {
  if (!entity || typeof entity !== "string") {
    throw new Error("Invalid NIP-19 entity");
  }
  if (entity.startsWith(Prefix.PrivateKey)) {
    throw new Error("nsec entities are not allowed in nostr URIs");
  }
  if (!entity.includes("1")) {
    throw new Error("Invalid bech32 format for NIP-19 entity");
  }
  return `${NOSTR_URI_PREFIX}${entity}`;
}
function decodeNostrURI(uri) {
  if (!uri.startsWith(NOSTR_URI_PREFIX)) {
    throw new Error("Invalid nostr URI format");
  }
  const entity = uri.slice(NOSTR_URI_PREFIX.length);
  return decode(entity);
}

// node_modules/snstr/dist/esm/src/nip05/index.js
async function verifyNIP05(identifier, pubkey2) {
  try {
    let name, domain;
    const parts = identifier.split("@");
    if (parts.length === 1) {
      name = "_";
      domain = parts[0];
    } else if (parts.length === 2) {
      name = parts[0];
      domain = parts[1];
    } else {
      return false;
    }
    if (!name || !domain) {
      return false;
    }
    const modifiedIdentifier = name === "_" && parts.length === 1 ? domain : identifier;
    const response = await lookupNIP05(modifiedIdentifier);
    if (!response)
      return false;
    return response.names[name.toLowerCase()] === pubkey2;
  } catch (error) {
    return false;
  }
}
async function lookupNIP05(identifier) {
  try {
    let name, domain;
    const parts = identifier.split("@");
    if (parts.length === 1) {
      name = "_";
      domain = parts[0];
    } else if (parts.length === 2) {
      name = parts[0];
      domain = parts[1];
    } else {
      return null;
    }
    if (!name || !domain) {
      return null;
    }
    const url = `https://${domain}/.well-known/nostr.json?name=${name.toLowerCase()}`;
    const fetchOptions = {
      method: "GET",
      headers: { Accept: "application/json" },
      redirect: "error"
    };
    const response = await fetch(url, fetchOptions);
    if (!response.ok) {
      return null;
    }
    const data = await response.json();
    if (!data || !data.names) {
      return null;
    }
    return data;
  } catch (error) {
    return null;
  }
}
async function getNIP05PubKey(identifier) {
  try {
    let name, domain;
    const parts = identifier.split("@");
    if (parts.length === 1) {
      name = "_";
      domain = parts[0];
    } else if (parts.length === 2) {
      name = parts[0];
      domain = parts[1];
    } else {
      return null;
    }
    if (!name || !domain) {
      return null;
    }
    const modifiedIdentifier = name === "_" && parts.length === 1 ? domain : identifier;
    const response = await lookupNIP05(modifiedIdentifier);
    if (!response)
      return null;
    return response.names[name.toLowerCase()] || null;
  } catch (error) {
    return null;
  }
}
async function getNIP05Relays(identifier, pubkey2) {
  try {
    const response = await lookupNIP05(identifier);
    if (!response || !response.relays || !response.relays[pubkey2])
      return null;
    return response.relays[pubkey2];
  } catch (error) {
    return null;
  }
}

// node_modules/snstr/dist/esm/src/nip07/index.js
function getNostr() {
  if (typeof window === "undefined")
    return void 0;
  const w = window;
  return w.nostr;
}
var hasNip07Support = () => {
  return typeof window !== "undefined" && !!getNostr();
};
var getPublicKey2 = async () => {
  if (!hasNip07Support()) {
    throw new Error("NIP-07 extension not available");
  }
  const nostr = getNostr();
  if (!nostr) {
    throw new Error("NIP-07 extension not available");
  }
  try {
    return await nostr.getPublicKey();
  } catch (error) {
    throw new Error(`Failed to get public key from NIP-07 extension: ${error}`);
  }
};
var signEvent2 = async (event2) => {
  if (!hasNip07Support()) {
    throw new Error("NIP-07 extension not available");
  }
  const nostr = getNostr();
  if (!nostr) {
    throw new Error("NIP-07 extension not available");
  }
  try {
    return await nostr.signEvent(event2);
  } catch (error) {
    throw new Error(`Failed to sign event with NIP-07 extension: ${error}`);
  }
};
var encryptNip04 = async (pubkey2, plaintext) => {
  if (!hasNip07Support()) {
    throw new Error("NIP-07 extension not available");
  }
  const nostr = getNostr();
  if (!nostr?.nip04?.encrypt) {
    throw new Error("NIP-04 encryption not supported by the extension");
  }
  try {
    return await nostr.nip04.encrypt(pubkey2, plaintext);
  } catch (error) {
    throw new Error(`Failed to encrypt message with NIP-04: ${error}`);
  }
};
var decryptNip04 = async (pubkey2, ciphertext) => {
  if (!hasNip07Support()) {
    throw new Error("NIP-07 extension not available");
  }
  const nostr = getNostr();
  if (!nostr?.nip04?.decrypt) {
    throw new Error("NIP-04 decryption not supported by the extension");
  }
  try {
    return await nostr.nip04.decrypt(pubkey2, ciphertext);
  } catch (error) {
    throw new Error(`Failed to decrypt message with NIP-04: ${error}`);
  }
};
var encryptNip44 = async (pubkey2, plaintext) => {
  if (!hasNip07Support()) {
    throw new Error("NIP-07 extension not available");
  }
  const nostr = getNostr();
  if (!nostr?.nip44?.encrypt) {
    throw new Error("NIP-44 encryption not supported by the extension");
  }
  try {
    return await nostr.nip44.encrypt(pubkey2, plaintext);
  } catch (error) {
    throw new Error(`Failed to encrypt message with NIP-44: ${error}`);
  }
};
var decryptNip44 = async (pubkey2, ciphertext) => {
  if (!hasNip07Support()) {
    throw new Error("NIP-07 extension not available");
  }
  const nostr = getNostr();
  if (!nostr?.nip44?.decrypt) {
    throw new Error("NIP-44 decryption not supported by the extension");
  }
  try {
    return await nostr.nip44.decrypt(pubkey2, ciphertext);
  } catch (error) {
    throw new Error(`Failed to decrypt message with NIP-44: ${error}`);
  }
};

// node_modules/snstr/dist/esm/src/nip09/index.js
function createDeletionRequest(opts, pubkey2) {
  const tags2 = [];
  for (const id of opts.ids || []) {
    tags2.push(["e", id]);
  }
  for (const addr of opts.addresses || []) {
    tags2.push(["a", addr]);
  }
  for (const kind of opts.kinds || []) {
    tags2.push(["k", kind.toString()]);
  }
  return createEvent({
    kind: NostrKind.Deletion,
    content: opts.content || "",
    tags: tags2
  }, pubkey2);
}
function parseDeletionTargets(event2) {
  const result = {
    ids: [],
    addresses: [],
    kinds: []
  };
  for (const tag of event2.tags) {
    try {
      if (!validateArrayAccess(tag, 0) || !validateArrayAccess(tag, 1)) {
        continue;
      }
      const tagName = safeArrayAccess(tag, 0);
      const tagValue = safeArrayAccess(tag, 1);
      if (typeof tagName !== "string" || typeof tagValue !== "string") {
        continue;
      }
      if (tagName === "e" && tagValue) {
        result.ids.push(tagValue);
      } else if (tagName === "a" && tagValue) {
        result.addresses.push(tagValue);
      } else if (tagName === "k" && tagValue) {
        const k = parseInt(tagValue, 10);
        if (!isNaN(k)) {
          result.kinds.push(k);
        }
      }
    } catch (error) {
      if (error instanceof SecurityValidationError) {
        if (typeof console !== "undefined" && console.warn) {
          console.warn(`NIP-09: Bounds checking error in tag processing: ${error.message}`);
        }
      }
    }
  }
  return result;
}
function isDeletionRequestForEvent(deletion, event2) {
  if (deletion.kind !== NostrKind.Deletion)
    return false;
  if (deletion.pubkey !== event2.pubkey)
    return false;
  const targets = parseDeletionTargets(deletion);
  if (targets.ids.includes(event2.id))
    return true;
  try {
    const dTag = event2.tags.find((t) => {
      try {
        return validateArrayAccess(t, 0) && safeArrayAccess(t, 0) === "d";
      } catch {
        return false;
      }
    });
    if (dTag && validateArrayAccess(dTag, 1)) {
      const dValue = safeArrayAccess(dTag, 1);
      if (typeof dValue === "string") {
        const addr = `${event2.kind}:${event2.pubkey}:${dValue}`;
        if (targets.addresses.includes(addr))
          return true;
      }
    }
  } catch (error) {
    if (error instanceof SecurityValidationError) {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(`NIP-09: Bounds checking error in d-tag processing: ${error.message}`);
      }
    }
  }
  return false;
}

// node_modules/snstr/dist/esm/src/nip10/index.js
function createReplyTags(root, reply) {
  const tags2 = [];
  const rootTag = ["e", root.id];
  rootTag.push(root.relay || "");
  rootTag.push("root");
  if (root.pubkey) {
    rootTag.push(root.pubkey);
  }
  tags2.push(rootTag);
  if (reply) {
    const replyTag = ["e", reply.id];
    replyTag.push(reply.relay || "");
    replyTag.push("reply");
    if (reply.pubkey) {
      replyTag.push(reply.pubkey);
    }
    tags2.push(replyTag);
  }
  return tags2;
}
function createQuoteTag(pointer) {
  const tag = ["e", pointer.id];
  tag.push(pointer.relay || "");
  tag.push("mention");
  if (pointer.pubkey) {
    tag.push(pointer.pubkey);
  }
  return tag;
}
function parseThreadReferences(event2) {
  const eTags = event2.tags.filter((t) => {
    try {
      return validateArrayAccess(t, 0) && safeArrayAccess(t, 0) === "e";
    } catch {
      return false;
    }
  });
  let root;
  let reply;
  const mentions = [];
  const quotes = [];
  const unmarked = [];
  for (const tag of eTags) {
    try {
      const id = tag[1];
      if (!id || typeof id !== "string" || !id.trim()) {
        continue;
      }
      const relay = safeArrayAccess(tag, 2);
      const marker = safeArrayAccess(tag, 3);
      const pubkey2 = safeArrayAccess(tag, 4);
      const relayValue = typeof relay === "string" && relay.trim() ? relay : void 0;
      const pubkeyValue = typeof pubkey2 === "string" && pubkey2.trim() && pubkey2 !== "" ? pubkey2 : void 0;
      if (marker === "root") {
        root = { id, relay: relayValue, pubkey: pubkeyValue };
      } else if (marker === "reply") {
        reply = { id, relay: relayValue, pubkey: pubkeyValue };
      } else if (marker === "mention") {
        quotes.push({ id, relay: relayValue, pubkey: pubkeyValue });
      } else {
        unmarked.push({ id, relay: relayValue, pubkey: pubkeyValue });
      }
    } catch (error) {
      if (error instanceof SecurityValidationError) {
        console.warn(`NIP-10: Bounds checking error in thread parsing: ${error.message}`);
      }
      continue;
    }
  }
  if (!root && !reply && unmarked.length > 0) {
    try {
      if (unmarked.length === 1) {
        reply = unmarked[0];
      } else {
        root = unmarked[0];
        reply = unmarked[unmarked.length - 1];
        if (unmarked.length > 2) {
          mentions.push(...unmarked.slice(1, -1));
        }
      }
    } catch (error) {
      if (error instanceof SecurityValidationError) {
        console.warn(`NIP-10: Bounds checking error in positional parsing: ${error.message}`);
      }
    }
  } else {
    mentions.push(...unmarked);
  }
  return { root, reply, mentions, quotes };
}

// node_modules/snstr/dist/esm/src/nip07/adapter.js
var Nip07Nostr = class extends Nostr {
  /**
   * Creates a new Nostr client that uses NIP-07 browser extension
   * @param relayUrls Array of relay URLs to connect to
   * @throws Error if NIP-07 extension is not available
   */
  constructor(relayUrls = []) {
    super(relayUrls);
    if (!hasNip07Support()) {
      throw new Error("NIP-07 extension not available in this browser");
    }
  }
  /**
   * Initialize the client with the public key from the NIP-07 extension
   * @returns The initialized public key
   */
  async initializeWithNip07() {
    try {
      this.nip07PublicKey = await getPublicKey2();
      return this.nip07PublicKey;
    } catch (error) {
      throw new Error(`Failed to initialize with NIP-07 extension: ${error}`);
    }
  }
  /**
   * Override getPublicKey to use the NIP-07 public key
   * @returns The public key from NIP-07 extension
   */
  getPublicKey() {
    return this.nip07PublicKey;
  }
  /**
   * Override setPrivateKey to prevent setting private key directly
   * @throws Error as private key can't be set manually with NIP-07
   */
  setPrivateKey(_privateKey) {
    throw new Error("Cannot set private key directly when using NIP-07 extension");
  }
  /**
   * Override generateKeys to use NIP-07 extension
   * @returns Object with publicKey (privateKey is empty string)
   */
  async generateKeys() {
    const publicKey = await this.initializeWithNip07();
    return { publicKey, privateKey: "" };
  }
  /**
   * Publishes a text note using the NIP-07 extension for signing
   * @param content Content of the note
   * @param tags Optional tags to add to the note
   * @returns The published event or null if failed
   */
  async publishTextNote(content2, tags2 = []) {
    if (!this.nip07PublicKey) {
      await this.initializeWithNip07();
    }
    const event2 = {
      kind: 1,
      created_at: getUnixTime(),
      tags: tags2,
      content: content2
    };
    try {
      const signedEvent = await signEvent2(event2);
      await this.publishEvent(signedEvent);
      return signedEvent;
    } catch (error) {
      console.error("Failed to publish text note:", error);
      return null;
    }
  }
  /**
   * Publishes a direct message to a recipient using the NIP-07 extension
   * @param content Message content
   * @param recipientPubkey Recipient's public key
   * @param tags Additional tags
   * @returns The published event or null if failed
   */
  async publishDirectMessage(content2, recipientPubkey2, tags2 = []) {
    if (!this.nip07PublicKey) {
      await this.initializeWithNip07();
    }
    try {
      let encryptedContent2;
      try {
        encryptedContent2 = await encryptNip44(recipientPubkey2, content2);
      } catch (e) {
        encryptedContent2 = await encryptNip04(recipientPubkey2, content2);
      }
      const recipientTag = ["p", recipientPubkey2];
      const updatedTags = [...tags2];
      if (!updatedTags.some((tag) => tag[0] === "p" && tag[1] === recipientPubkey2)) {
        updatedTags.push(recipientTag);
      }
      const event2 = {
        kind: 4,
        created_at: getUnixTime(),
        tags: updatedTags,
        content: encryptedContent2
      };
      const signedEvent = await signEvent2(event2);
      await this.publishEvent(signedEvent);
      return signedEvent;
    } catch (error) {
      console.error("Failed to publish direct message:", error);
      return null;
    }
  }
  /**
   * Decrypt a direct message using the NIP-07 extension
   * @param event The encrypted message event
   * @returns The decrypted content
   * @throws Error if decryption fails
   */
  decryptDirectMessage(event2) {
    if (event2.kind !== 4) {
      throw new Error("Event is not a direct message (kind 4)");
    }
    try {
      throw new Error("With NIP-07, use decryptDirectMessageAsync instead");
    } catch (error) {
      throw new Error(`Cannot decrypt synchronously with NIP-07. Use decryptDirectMessageAsync: ${error}`);
    }
  }
  /**
   * Async version of decryptDirectMessage that works with NIP-07
   * @param event The encrypted message event
   * @returns Promise resolving to the decrypted content
   */
  async decryptDirectMessageAsync(event2) {
    if (event2.kind !== 4) {
      throw new Error("Event is not a direct message (kind 4)");
    }
    const senderPubkey2 = event2.pubkey;
    try {
      try {
        return await decryptNip44(senderPubkey2, event2.content);
      } catch (e) {
        return await decryptNip04(senderPubkey2, event2.content);
      }
    } catch (error) {
      throw new Error(`Failed to decrypt message: ${error}`);
    }
  }
};

// node_modules/snstr/dist/esm/src/nip57/utils.js
var import_light_bolt11_decoder = __toESM(require_bolt11(), 1);
function getLightningAddressUrl(lightningAddress) {
  try {
    if (!lightningAddress || !lightningAddress.includes("@")) {
      return null;
    }
    const [username, domain] = lightningAddress.split("@");
    if (!username || !domain) {
      return null;
    }
    return `https://${domain}/.well-known/lnurlp/${username}`;
  } catch (error) {
    console.error("Error converting Lightning Address:", error);
    return null;
  }
}
async function fetchLnurlPayMetadata(lnurlOrUrl) {
  try {
    let url = lnurlOrUrl;
    if (lnurlOrUrl.includes("@")) {
      url = getLightningAddressUrl(lnurlOrUrl) || lnurlOrUrl;
    } else if (lnurlOrUrl.toLowerCase().startsWith("lnurl")) {
      url = decodeLnurl(lnurlOrUrl) || lnurlOrUrl;
    }
    if (!url) {
      return null;
    }
    const response = await fetch(url);
    const data = await response.json();
    if (!data || typeof data !== "object" || !data.callback || !data.maxSendable || !data.minSendable || !data.metadata || data.tag !== "payRequest") {
      return null;
    }
    return {
      callback: data.callback,
      maxSendable: data.maxSendable,
      minSendable: data.minSendable,
      metadata: data.metadata,
      commentAllowed: data.commentAllowed,
      tag: data.tag,
      allowsNostr: data.allowsNostr,
      nostrPubkey: data.nostrPubkey
    };
  } catch (error) {
    console.error("Error fetching LNURL metadata:", error);
    return null;
  }
}
function supportsNostrZaps(metadata) {
  return !!(metadata.allowsNostr && metadata.nostrPubkey);
}
function decodeLnurl(lnurl) {
  try {
    if (!lnurl.toLowerCase().startsWith("lnurl")) {
      return null;
    }
    const decoded = bech32.decode(lnurl.toLowerCase(), 1023);
    const words = decoded.words;
    const bytes2 = bech32.fromWords(words);
    return new TextDecoder().decode(new Uint8Array(bytes2));
  } catch (error) {
    console.error("Error decoding LNURL:", error);
    return null;
  }
}
function parseBolt11Invoice(bolt11) {
  try {
    const decoded = (0, import_light_bolt11_decoder.decode)(bolt11);
    const result = {};
    const timestampSection = decoded.sections.find((s) => s.name === "timestamp");
    if (timestampSection?.value !== void 0) {
      result.timestamp = Number(timestampSection.value);
    }
    if (decoded.millisatoshis) {
      result.amount = String(decoded.millisatoshis);
    } else if (decoded.satoshis) {
      const sats = typeof decoded.satoshis === "number" ? decoded.satoshis : parseInt(decoded.satoshis, 10);
      result.amount = String(sats * 1e3);
    }
    if (decoded.paymentHash) {
      result.paymentHash = decoded.paymentHash;
    } else {
      const paymentHashSection = decoded.sections.find((s) => s.name === "payment_hash");
      if (paymentHashSection?.value !== void 0) {
        result.paymentHash = String(paymentHashSection.value);
      }
    }
    if (decoded.description) {
      result.description = decoded.description;
    } else {
      const descriptionSection = decoded.sections.find((s) => s.name === "description");
      if (descriptionSection?.value !== void 0) {
        result.description = String(descriptionSection.value);
      }
    }
    if (decoded.descriptionHash) {
      result.descriptionHash = decoded.descriptionHash;
    } else {
      for (const section of decoded.sections) {
        if (section.name === "description_hash" || section.name === "purpose_commit_hash") {
          if (section.value !== void 0) {
            result.descriptionHash = String(section.value);
            break;
          }
        }
      }
    }
    return result;
  } catch (error) {
    console.error("Error parsing bolt11 invoice:", error);
    return null;
  }
}
function buildZapCallbackUrl(callbackUrl, zapRequestEvent, amount) {
  const url = new URL(callbackUrl);
  url.searchParams.append("amount", amount.toString());
  url.searchParams.append("nostr", encodeURIComponent(zapRequestEvent));
  return url.toString();
}
function extractLnurlMetadata(metadataString) {
  try {
    const metadata = JSON.parse(metadataString);
    if (!Array.isArray(metadata)) {
      return null;
    }
    const result = {};
    for (const item of metadata) {
      if (Array.isArray(item) && item.length === 2 && typeof item[0] === "string") {
        result[item[0]] = String(item[1]);
      }
    }
    return result;
  } catch (error) {
    console.error("Error parsing LNURL metadata:", error);
    return null;
  }
}

// node_modules/snstr/dist/esm/src/nip57/client.js
var NostrZapClient = class {
  /**
   * Create a new zap client
   * @param options Options for configuring the client
   */
  constructor(options) {
    this.client = options.client;
    this.defaultRelays = options.defaultRelays || [];
  }
  /**
   * Private method to safely unsubscribe from a subscription
   *
   * @param subscriptionIds Array of subscription IDs
   * @param context Context string for error logging
   */
  cleanupSubscription(subscriptionIds, context = "cleanup") {
    try {
      if (validateArrayAccess(subscriptionIds, 0)) {
        const subId = safeArrayAccess(subscriptionIds, 0);
        if (typeof subId === "string") {
          this.client.unsubscribe([subId]);
        }
      }
    } catch (error) {
      if (error instanceof SecurityValidationError) {
        console.warn(`NIP-57: Bounds checking error in ${context}: ${error.message}`);
      }
    }
  }
  /**
   * Check if a user can receive zaps
   *
   * This method checks if a user's LNURL endpoint supports NIP-57 Nostr zaps.
   *
   * @param pubkey The user's public key
   * @param lnurl Optional LNURL from profile (if known)
   * @returns Whether the user can receive zaps
   */
  async canReceiveZaps(pubkey2, lnurl) {
    const zapClient = new ZapClient({
      nostrClient: this.client,
      defaultRelays: this.defaultRelays
    });
    return zapClient.canReceiveZaps(pubkey2, lnurl);
  }
  /**
   * Send a zap to a user or event
   *
   * This method:
   * 1. Creates a zap request
   * 2. Sends it to the recipient's LNURL server
   * 3. Returns the invoice for payment
   *
   * Note: After getting the invoice, you need to pay it with a Lightning wallet.
   * The LNURL server will create and publish a zap receipt after payment.
   *
   * @param options Zap options including recipient, amount, and comment
   * @param privateKey Private key for signing the request
   * @returns Object with success status and invoice or error
   */
  async sendZap(options, privateKey2) {
    const zapClient = new ZapClient({
      nostrClient: this.client,
      defaultRelays: this.defaultRelays
    });
    const result = await zapClient.getZapInvoice(options, privateKey2);
    if (result.error) {
      return {
        success: false,
        error: result.error
      };
    }
    return {
      success: true,
      invoice: result.invoice
    };
  }
  /**
   * Fetch zaps received by a user
   *
   * @param pubkey User's public key
   * @param options Filter options
   * @returns Array of zap receipt events
   */
  async fetchUserReceivedZaps(pubkey2, options = {}) {
    const filter = {
      kinds: [9735],
      "#p": [pubkey2],
      limit: options.limit || 20
    };
    if (options.since) {
      filter.since = options.since;
    }
    if (options.until) {
      filter.until = options.until;
    }
    if (options.authors && options.authors.length > 0) {
      filter.authors = options.authors;
    }
    return new Promise((resolve) => {
      const events = [];
      const subscriptionIds = this.client.subscribe([filter], (event2) => {
        events.push(event2);
      }, () => {
        this.cleanupSubscription(subscriptionIds);
        resolve(events);
      });
      setTimeout(() => {
        this.cleanupSubscription(subscriptionIds, "timeout");
        resolve(events);
      }, 1e4);
    });
  }
  /**
   * Fetch zaps sent by a user
   *
   * @param pubkey User's public key
   * @param options Filter options
   * @returns Array of zap receipt events
   */
  async fetchUserSentZaps(pubkey2, options = {}) {
    const allZapReceipts = await this.fetchZapReceipts(options);
    return allZapReceipts.filter((zapReceipt) => {
      try {
        const descriptionTag = zapReceipt.tags.find((tag) => Array.isArray(tag) && tag.length > 0 && tag[0] === "description");
        if (!Array.isArray(descriptionTag) || descriptionTag.length < 2 || typeof descriptionTag[1] !== "string")
          return false;
        const zapRequest = JSON.parse(descriptionTag[1]);
        return zapRequest.pubkey === pubkey2;
      } catch (e) {
        if (e instanceof SecurityValidationError) {
          console.warn(`NIP-57: Bounds checking error in zap filtering: ${e.message}`);
        }
        return false;
      }
    });
  }
  /**
   * Fetch zaps for a specific event
   *
   * @param eventId The event ID to get zaps for
   * @param options Filter options
   * @returns Array of zap receipt events
   */
  async fetchEventZaps(eventId, options = {}) {
    const filter = {
      kinds: [9735],
      "#e": [eventId],
      limit: options.limit || 20
    };
    if (options.since) {
      filter.since = options.since;
    }
    if (options.until) {
      filter.until = options.until;
    }
    if (options.authors && options.authors.length > 0) {
      filter.authors = options.authors;
    }
    return new Promise((resolve) => {
      const events = [];
      const subscriptionIds = this.client.subscribe([filter], (event2) => {
        events.push(event2);
      }, () => {
        this.cleanupSubscription(subscriptionIds);
        resolve(events);
      });
      setTimeout(() => {
        this.cleanupSubscription(subscriptionIds, "timeout");
        resolve(events);
      }, 1e4);
    });
  }
  /**
   * Fetch all zap receipts matching the filter criteria
   *
   * @param options Filter options
   * @returns Array of zap receipt events
   */
  async fetchZapReceipts(options = {}) {
    const filter = {
      kinds: [9735],
      limit: options.limit || 20
    };
    if (options.since) {
      filter.since = options.since;
    }
    if (options.until) {
      filter.until = options.until;
    }
    if (options.authors && options.authors.length > 0) {
      filter.authors = options.authors;
    }
    if (options.events && options.events.length > 0) {
      filter["#e"] = options.events;
    }
    return new Promise((resolve) => {
      const events = [];
      const subscriptionIds = this.client.subscribe([filter], (event2) => {
        events.push(event2);
      }, () => {
        this.cleanupSubscription(subscriptionIds);
        resolve(events);
      });
      setTimeout(() => {
        this.cleanupSubscription(subscriptionIds, "timeout");
        resolve(events);
      }, 1e4);
    });
  }
  /**
   * Validate a zap receipt
   *
   * This validates that:
   * 1. The receipt is properly formatted
   * 2. The signature is valid
   * 3. The description hash in the bolt11 invoice matches the zap request
   * 4. The amount matches between invoice and zap request
   *
   * @param zapReceipt The zap receipt event to validate
   * @param lnurlPubkey Public key of the LNURL server (if known)
   * @returns Validation result with details
   */
  validateZapReceipt(zapReceipt, lnurlPubkey) {
    return validateZapReceipt(zapReceipt, lnurlPubkey || zapReceipt.pubkey);
  }
  /**
   * Calculate total zaps received by a user
   *
   * @param pubkey User's public key
   * @param options Filter options
   * @returns Zap statistics
   */
  async getTotalZapsReceived(pubkey2, options = {}) {
    const zaps = await this.fetchUserReceivedZaps(pubkey2, options);
    if (zaps.length === 0) {
      return { total: 0, count: 0 };
    }
    const stats = {
      total: 0,
      count: 0,
      largest: 0,
      smallest: Number.MAX_SAFE_INTEGER,
      average: 0,
      firstAt: Number.MAX_SAFE_INTEGER,
      latestAt: 0
    };
    for (const zap of zaps) {
      const validation = this.validateZapReceipt(zap);
      if (validation.valid && validation.amount) {
        stats.total += validation.amount;
        stats.count++;
        if (validation.amount > (stats.largest || 0)) {
          stats.largest = validation.amount;
        }
        if (validation.amount < (stats.smallest || Number.MAX_SAFE_INTEGER)) {
          stats.smallest = validation.amount;
        }
        if (zap.created_at < stats.firstAt) {
          stats.firstAt = zap.created_at;
        }
        if (zap.created_at > stats.latestAt) {
          stats.latestAt = zap.created_at;
        }
      }
    }
    if (stats.count > 0) {
      stats.average = Math.floor(stats.total / stats.count);
    }
    if (stats.smallest === Number.MAX_SAFE_INTEGER) {
      stats.smallest = void 0;
    }
    if (stats.firstAt === Number.MAX_SAFE_INTEGER) {
      stats.firstAt = void 0;
    }
    return stats;
  }
  /**
   * Calculate total zaps for a specific event
   *
   * @param eventId Event ID to calculate zaps for
   * @param options Filter options
   * @returns Zap statistics
   */
  async getTotalZapsForEvent(eventId, options = {}) {
    const zaps = await this.fetchEventZaps(eventId, options);
    if (zaps.length === 0) {
      return { total: 0, count: 0 };
    }
    const stats = {
      total: 0,
      count: 0,
      largest: 0,
      smallest: Number.MAX_SAFE_INTEGER,
      average: 0,
      firstAt: Number.MAX_SAFE_INTEGER,
      latestAt: 0
    };
    for (const zap of zaps) {
      const validation = this.validateZapReceipt(zap);
      if (validation.valid && validation.amount) {
        stats.total += validation.amount;
        stats.count++;
        if (validation.amount > (stats.largest || 0)) {
          stats.largest = validation.amount;
        }
        if (validation.amount < (stats.smallest || Number.MAX_SAFE_INTEGER)) {
          stats.smallest = validation.amount;
        }
        if (zap.created_at < stats.firstAt) {
          stats.firstAt = zap.created_at;
        }
        if (zap.created_at > stats.latestAt) {
          stats.latestAt = zap.created_at;
        }
      }
    }
    if (stats.count > 0) {
      stats.average = Math.floor(stats.total / stats.count);
    }
    if (stats.smallest === Number.MAX_SAFE_INTEGER) {
      stats.smallest = void 0;
    }
    if (stats.firstAt === Number.MAX_SAFE_INTEGER) {
      stats.firstAt = void 0;
    }
    return stats;
  }
  /**
   * Parse zap split information from an event
   *
   * @param event The event to parse zap split information from
   * @returns Array of zap split recipients with weights
   */
  parseZapSplit(event2) {
    return parseZapSplit(event2);
  }
  /**
   * Calculate zap split amounts
   *
   * @param totalAmount Total amount to split in millisats
   * @param splitInfo Array of zap split recipients with weights
   * @returns Array of recipients with calculated amounts
   */
  calculateZapSplitAmounts(totalAmount, splitInfo) {
    return calculateZapSplitAmounts(totalAmount, splitInfo);
  }
};
var ZapClient = class {
  /**
   * Create a new ZapClient
   * @param options Options for the client
   */
  constructor(options) {
    this.lnurlCache = /* @__PURE__ */ new Map();
    this.nostrClient = options.nostrClient;
    this.defaultRelays = options.defaultRelays || [];
  }
  /**
   * Check if a user has a valid LNURL that supports zaps
   * @param pubkey User's public key
   * @param lnurlFromProfile LNURL from the user's profile (optional)
   * @returns Whether the user can receive zaps
   */
  async canReceiveZaps(pubkey2, lnurlFromProfile) {
    try {
      const cached = this.lnurlCache.get(pubkey2);
      if (cached) {
        return cached.supportsZaps;
      }
      const lnurl = lnurlFromProfile;
      if (!lnurl) {
        return false;
      }
      const metadata = await fetchLnurlPayMetadata(lnurl);
      if (!metadata) {
        this.lnurlCache.set(pubkey2, { pubkey: pubkey2, lnurl, supportsZaps: false });
        return false;
      }
      const supportsZaps = supportsNostrZaps(metadata);
      this.lnurlCache.set(pubkey2, { pubkey: pubkey2, lnurl, supportsZaps });
      return supportsZaps;
    } catch (error) {
      console.error("Error checking zap support:", error);
      return false;
    }
  }
  /**
   * Generate a zap invoice for a user or event
   * @param options Options for the zap
   * @param privateKey Private key to sign the zap request
   * @returns Zap invoice result
   */
  async getZapInvoice(options, privateKey2) {
    try {
      const senderPubkey2 = this.nostrClient.getPublicKey();
      if (!senderPubkey2 && !options.anonymousZap) {
        return {
          invoice: "",
          zapRequest: {},
          error: "No public key available and not anonymous zap"
        };
      }
      const metadata = await fetchLnurlPayMetadata(options.lnurl);
      if (!metadata) {
        return {
          invoice: "",
          zapRequest: {},
          error: "Invalid LNURL or failed to fetch metadata"
        };
      }
      if (!supportsNostrZaps(metadata)) {
        return {
          invoice: "",
          zapRequest: {},
          error: "LNURL does not support Nostr zaps"
        };
      }
      if (options.amount < metadata.minSendable || options.amount > metadata.maxSendable) {
        return {
          invoice: "",
          zapRequest: {},
          error: `Amount out of range (${metadata.minSendable}-${metadata.maxSendable} millisats)`
        };
      }
      const zapRequestOptions = {
        recipientPubkey: options.recipientPubkey,
        amount: options.amount,
        relays: options.relays || this.defaultRelays,
        content: options.comment || "",
        lnurl: options.lnurl
      };
      if (options.eventId) {
        zapRequestOptions.eventId = options.eventId;
      }
      if (options.aTag) {
        zapRequestOptions.aTag = options.aTag;
      }
      if (options.anonymousZap && senderPubkey2) {
        zapRequestOptions.senderPubkey = senderPubkey2;
      }
      const requestTemplate = createZapRequest(zapRequestOptions, options.anonymousZap ? "00000000000000000000000000000000000000000000000000000000000000" : senderPubkey2 || "");
      const signedZapRequest = await createSignedEvent({
        ...requestTemplate,
        tags: requestTemplate.tags || [],
        pubkey: options.anonymousZap ? "00000000000000000000000000000000000000000000000000000000000000" : senderPubkey2 || "",
        created_at: getUnixTime()
      }, privateKey2);
      const callbackUrl = buildZapCallbackUrl(metadata.callback, JSON.stringify(signedZapRequest), options.amount);
      const invoiceResponse = await fetch(callbackUrl);
      const invoiceData = await invoiceResponse.json();
      if (invoiceData.status === "ERROR") {
        return {
          invoice: "",
          zapRequest: signedZapRequest,
          error: invoiceData.reason || "LNURL error"
        };
      }
      return {
        invoice: invoiceData.pr,
        zapRequest: signedZapRequest,
        paymentHash: invoiceData.payment_hash,
        successAction: invoiceData.successAction
      };
    } catch (error) {
      console.error("Error getting zap invoice:", error);
      return {
        invoice: "",
        zapRequest: {},
        error: `Error: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Validate a zap receipt
   * @param zapReceipt Zap receipt event
   * @param lnurlPubkey LNURL server pubkey
   * @returns Validation result
   */
  validateZapReceipt(zapReceipt, lnurlPubkey) {
    return validateZapReceipt(zapReceipt, lnurlPubkey);
  }
  /**
   * Handle zap splits for an event
   * @param event Event with zap split tags
   * @param totalAmount Total amount to split
   * @returns Split information for each recipient
   */
  getZapSplitAmounts(event2, totalAmount) {
    const splitInfo = parseZapSplit(event2);
    return calculateZapSplitAmounts(totalAmount, splitInfo);
  }
};

// node_modules/snstr/dist/esm/src/nip57/index.js
var ZAP_REQUEST_KIND = 9734;
var ZAP_RECEIPT_KIND = 9735;
function createZapRequest(options, signerPubkey) {
  const tags2 = [["p", options.recipientPubkey]];
  tags2.push(["relays", ...options.relays]);
  if (options.eventId) {
    tags2.push(["e", options.eventId]);
  }
  if (options.amount) {
    tags2.push(["amount", options.amount.toString()]);
  }
  if (options.lnurl) {
    tags2.push(["lnurl", options.lnurl]);
  }
  if (options.aTag) {
    tags2.push(["a", options.aTag]);
  }
  if (options.senderPubkey) {
    tags2.push(["P", options.senderPubkey]);
  }
  return createEvent({
    kind: ZAP_REQUEST_KIND,
    content: options.content || "",
    tags: tags2
  }, signerPubkey);
}
function createZapReceipt(options, signerPubkey) {
  const tags2 = [["p", options.recipientPubkey]];
  if (options.eventId) {
    tags2.push(["e", options.eventId]);
  }
  if (options.senderPubkey) {
    tags2.push(["P", options.senderPubkey]);
  }
  if (options.aTag) {
    tags2.push(["a", options.aTag]);
  }
  tags2.push(["bolt11", options.bolt11]);
  tags2.push(["description", JSON.stringify(options.zapRequest)]);
  if (options.preimage) {
    tags2.push(["preimage", options.preimage]);
  }
  return createEvent({
    kind: ZAP_RECEIPT_KIND,
    content: "",
    tags: tags2
  }, signerPubkey);
}
function validateZapReceipt(zapReceipt, lnurlPubkey) {
  if (!zapReceipt) {
    return { valid: false, message: "Zap receipt is null or undefined" };
  }
  if (zapReceipt.kind !== ZAP_RECEIPT_KIND) {
    return {
      valid: false,
      message: `Not a zap receipt event: kind ${zapReceipt.kind} instead of ${ZAP_RECEIPT_KIND}`
    };
  }
  if (zapReceipt.pubkey !== lnurlPubkey) {
    return {
      valid: false,
      message: `Zap receipt not from expected LNURL provider: ${zapReceipt.pubkey} vs expected ${lnurlPubkey}`
    };
  }
  const bolt11Tag = zapReceipt.tags.find((tag) => tag[0] === "bolt11");
  const descriptionTag = zapReceipt.tags.find((tag) => tag[0] === "description");
  const pTag2 = zapReceipt.tags.find((tag) => tag[0] === "p");
  const eTag = zapReceipt.tags.find((tag) => tag[0] === "e");
  if (!bolt11Tag) {
    return { valid: false, message: "Missing bolt11 tag" };
  }
  if (!descriptionTag) {
    return { valid: false, message: "Missing description tag" };
  }
  if (!pTag2) {
    return { valid: false, message: "Missing p tag" };
  }
  let zapRequest;
  try {
    zapRequest = JSON.parse(descriptionTag[1]);
  } catch (e) {
    return {
      valid: false,
      message: `Invalid zap request description: ${e instanceof Error ? e.message : String(e)}`
    };
  }
  try {
    const isValid = verifySignature(zapRequest.id, zapRequest.sig, zapRequest.pubkey);
    if (!isValid) {
      return { valid: false, message: "Invalid zap request signature" };
    }
  } catch (error) {
    return {
      valid: false,
      message: `Error verifying signature: ${error instanceof Error ? error.message : String(error)}`
    };
  }
  if (zapRequest.kind !== ZAP_REQUEST_KIND) {
    return {
      valid: false,
      message: `Not a zap request event: kind ${zapRequest.kind} instead of ${ZAP_REQUEST_KIND}`
    };
  }
  const amountTag = zapRequest.tags.find((tag) => tag[0] === "amount");
  const amount = amountTag ? parseInt(amountTag[1], 10) : void 0;
  const zapRequestPTag = zapRequest.tags.find((tag) => tag[0] === "p");
  if (!zapRequestPTag) {
    return { valid: false, message: "Missing p tag in zap request" };
  }
  if (zapRequestPTag[1] !== pTag2[1]) {
    return {
      valid: false,
      message: `Recipient mismatch: ${zapRequestPTag[1]} vs ${pTag2[1]}`
    };
  }
  const zapRequestETag = zapRequest.tags.find((tag) => tag[0] === "e");
  if (eTag && zapRequestETag && eTag[1] !== zapRequestETag[1]) {
    return {
      valid: false,
      message: `Event ID mismatch: ${eTag[1]} vs ${zapRequestETag[1]}`
    };
  }
  try {
    const bolt11 = bolt11Tag[1];
    const parsedInvoice = parseBolt11Invoice(bolt11);
    if (!parsedInvoice) {
      return { valid: false, message: "Failed to parse bolt11 invoice" };
    }
    const invoiceDescriptionHash = parsedInvoice.descriptionHash;
    if (!invoiceDescriptionHash) {
      return { valid: false, message: "Invoice is missing description hash" };
    }
    const zapRequestJson = descriptionTag[1];
    const calculatedHash = sha256Hex(zapRequestJson);
    if (calculatedHash !== invoiceDescriptionHash) {
      return {
        valid: false,
        message: `Description hash mismatch: invoice=${invoiceDescriptionHash}, calculated=${calculatedHash}`
      };
    }
  } catch (error) {
    return {
      valid: false,
      message: `Error validating description hash: ${error instanceof Error ? error.message : String(error)}`
    };
  }
  return {
    valid: true,
    amount,
    sender: zapRequest.pubkey,
    recipient: pTag2[1],
    eventId: eTag?.[1],
    content: zapRequest.content
  };
}
function parseZapSplit(event2) {
  const zapTags = event2.tags.filter((tag) => tag[0] === "zap");
  if (zapTags.length === 0) {
    return [];
  }
  const splitInfo = zapTags.map((tag) => {
    const [_, pubkey2, relay, weightStr] = tag;
    const weight = weightStr ? parseInt(weightStr, 10) : 0;
    return { pubkey: pubkey2, relay, weight };
  });
  const hasWeights = splitInfo.some((info) => info.weight > 0);
  if (!hasWeights) {
    const equalWeight = 1;
    return splitInfo.map((info) => ({
      ...info,
      weight: equalWeight
    }));
  }
  return splitInfo;
}
function calculateZapSplitAmounts(totalAmount, splitInfo) {
  const totalWeight = splitInfo.reduce((sum, info) => sum + info.weight, 0);
  if (totalWeight === 0) {
    return [];
  }
  return splitInfo.map((info) => {
    const amount = Math.floor(info.weight / totalWeight * totalAmount);
    return {
      pubkey: info.pubkey,
      relay: info.relay,
      amount
    };
  });
}

// node_modules/snstr/dist/esm/src/nip50/index.js
function createSearchFilter(query, other = {}) {
  if (!query || typeof query !== "string" || query.trim() === "") {
    throw new Error("Query must be a non-empty string");
  }
  return { ...other, search: query };
}
export {
  DM_KIND,
  FILE_KIND,
  GIFT_WRAP_KIND,
  NIP20Prefix,
  NOSTR_URI_PREFIX,
  Nip07Nostr,
  Nostr,
  NostrKind,
  NostrZapClient,
  Prefix,
  Relay,
  RelayErrorType,
  RelayEvent,
  RelayPool,
  RelayStatus,
  SEAL_KIND,
  TLVType,
  WebSocketReadyState,
  ZAP_RECEIPT_KIND,
  ZAP_REQUEST_KIND,
  ZapClient,
  buildZapCallbackUrl,
  calculateZapSplitAmounts,
  constantTimeEqual,
  createAddressableEvent,
  createContactListEvent,
  createDeletionRequest,
  createDirectMessage2 as createDirectMessage,
  createEvent,
  createQuoteTag,
  createReplyTags,
  createSearchFilter,
  createZapReceipt,
  createZapRequest,
  decode,
  decodeAddress,
  decodeBech32,
  decodeEvent,
  decodeLnurl,
  decodeNostrURI,
  decodeNoteId,
  decodePrivateKey,
  decodeProfile,
  decodePublicKey,
  decryptDirectMessage,
  decrypt2 as decryptNIP04,
  decrypt as decryptNIP44,
  decryptNip04 as decryptNip04WithExtension,
  decryptNip44 as decryptNip44WithExtension,
  encodeAddress,
  encodeBech32,
  encodeEvent,
  encodeNostrURI,
  encodeNoteId,
  encodePrivateKey,
  encodeProfile,
  encodePublicKey,
  encrypt2 as encryptNIP04,
  encrypt as encryptNIP44,
  encryptNip04 as encryptNip04WithExtension,
  encryptNip44 as encryptNip44WithExtension,
  extractLnurlMetadata,
  fetchLnurlPayMetadata,
  fetchRelayInformation,
  generateKeypair,
  generateNonce as generateNIP44Nonce,
  getEventHash,
  getSharedSecret2 as getNIP04SharedSecret,
  getNIP05PubKey,
  getNIP05Relays,
  getSharedSecret as getNIP44SharedSecret,
  getPublicKey2 as getNip07PublicKey,
  getPublicKey,
  getRelayPaymentInfo,
  getUnixTime,
  hasNip07Support,
  initializeCrypto as initializeNIP17Crypto,
  isDeletionRequestForEvent,
  lookupNIP05,
  parseBolt11Invoice,
  parseContactsFromEvent,
  parseContactsFromEventWithWarnings,
  parseDeletionTargets,
  parseThreadReferences,
  parseZapSplit,
  relayRequiresPayment,
  relaySupportsNIPs,
  resetWebSocketImplementation,
  secureWipe as secureWipeNIP44,
  signEvent,
  signEvent2 as signEventWithNip07,
  supportsNIP11,
  supportsNostrZaps,
  useWebSocketImplementation,
  validateZapReceipt,
  verifyNIP05,
  verifySignature
};
//# sourceMappingURL=snstr.js.map
